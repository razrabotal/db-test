var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    function log(message) {
      console.log(`[dotenv][DEBUG] ${message}`);
    }
    var NEWLINE = "\n";
    var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
    var RE_NEWLINES = /\\n/g;
    var NEWLINES_MATCH = /\r\n|\n|\r/;
    function parse(src2, options2) {
      const debug = Boolean(options2 && options2.debug);
      const obj = {};
      src2.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
        const keyValueArr = line.match(RE_INI_KEY_VAL);
        if (keyValueArr != null) {
          const key = keyValueArr[1];
          let val = keyValueArr[2] || "";
          const end = val.length - 1;
          const isDoubleQuoted = val[0] === '"' && val[end] === '"';
          const isSingleQuoted = val[0] === "'" && val[end] === "'";
          if (isSingleQuoted || isDoubleQuoted) {
            val = val.substring(1, end);
            if (isDoubleQuoted) {
              val = val.replace(RE_NEWLINES, NEWLINE);
            }
          } else {
            val = val.trim();
          }
          obj[key] = val;
        } else if (debug) {
          log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
        }
      });
      return obj;
    }
    function resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function config(options2) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      let debug = false;
      if (options2) {
        if (options2.path != null) {
          dotenvPath = resolveHome(options2.path);
        }
        if (options2.encoding != null) {
          encoding = options2.encoding;
        }
        if (options2.debug != null) {
          debug = true;
        }
      }
      try {
        const parsed = parse(fs.readFileSync(dotenvPath, {encoding}), {debug});
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else if (debug) {
            log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
          }
        });
        return {parsed};
      } catch (e) {
        return {error: e};
      }
    }
    module2.exports.config = config;
    module2.exports.parse = parse;
  }
});

// node_modules/bson/lib/bson/map.js
var require_map = __commonJS({
  "node_modules/bson/lib/bson/map.js"(exports2, module2) {
    "use strict";
    if (typeof global.Map !== "undefined") {
      module2.exports = global.Map;
      module2.exports.Map = global.Map;
    } else {
      Map2 = function(array) {
        this._keys = [];
        this._values = {};
        for (var i = 0; i < array.length; i++) {
          if (array[i] == null)
            continue;
          var entry = array[i];
          var key = entry[0];
          var value = entry[1];
          this._keys.push(key);
          this._values[key] = {v: value, i: this._keys.length - 1};
        }
      };
      Map2.prototype.clear = function() {
        this._keys = [];
        this._values = {};
      };
      Map2.prototype.delete = function(key) {
        var value = this._values[key];
        if (value == null)
          return false;
        delete this._values[key];
        this._keys.splice(value.i, 1);
        return true;
      };
      Map2.prototype.entries = function() {
        var self = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self._keys[index2++];
            return {
              value: key !== void 0 ? [key, self._values[key].v] : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.forEach = function(callback, self) {
        self = self || this;
        for (var i = 0; i < this._keys.length; i++) {
          var key = this._keys[i];
          callback.call(self, this._values[key].v, key, self);
        }
      };
      Map2.prototype.get = function(key) {
        return this._values[key] ? this._values[key].v : void 0;
      };
      Map2.prototype.has = function(key) {
        return this._values[key] != null;
      };
      Map2.prototype.keys = function() {
        var self = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self._keys[index2++];
            return {
              value: key !== void 0 ? key : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.set = function(key, value) {
        if (this._values[key]) {
          this._values[key].v = value;
          return this;
        }
        this._keys.push(key);
        this._values[key] = {v: value, i: this._keys.length - 1};
        return this;
      };
      Map2.prototype.values = function() {
        var self = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self._keys[index2++];
            return {
              value: key !== void 0 ? self._values[key].v : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Object.defineProperty(Map2.prototype, "size", {
        enumerable: true,
        get: function() {
          return this._keys.length;
        }
      });
      module2.exports = Map2;
      module2.exports.Map = Map2;
    }
    var Map2;
  }
});

// node_modules/bson/lib/bson/long.js
var require_long = __commonJS({
  "node_modules/bson/lib/bson/long.js"(exports2, module2) {
    function Long2(low, high) {
      if (!(this instanceof Long2))
        return new Long2(low, high);
      this._bsontype = "Long";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Long2.prototype.toInt = function() {
      return this.low_;
    };
    Long2.prototype.toNumber = function() {
      return this.high_ * Long2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Long2.prototype.toBigInt = function() {
      return BigInt(this.toString());
    };
    Long2.prototype.toJSON = function() {
      return this.toString();
    };
    Long2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          var radixLong = Long2.fromNumber(radix);
          var div = this.div(radixLong);
          var rem = div.multiply(radixLong).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Long2.prototype.getHighBits = function() {
      return this.high_;
    };
    Long2.prototype.getLowBits = function() {
      return this.low_;
    };
    Long2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Long2.TWO_PWR_32_DBL_ + this.low_;
    };
    Long2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Long2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Long2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Long2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Long2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Long2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Long2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Long2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Long2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Long2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Long2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Long2.prototype.negate = function() {
      if (this.equals(Long2.MIN_VALUE)) {
        return Long2.MIN_VALUE;
      } else {
        return this.not().add(Long2.ONE);
      }
    };
    Long2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Long2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Long2.ZERO;
      } else if (other.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        return other.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      } else if (other.equals(Long2.MIN_VALUE)) {
        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Long2.TWO_PWR_24_) && other.lessThan(Long2.TWO_PWR_24_)) {
        return Long2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        if (other.equals(Long2.ONE) || other.equals(Long2.NEG_ONE)) {
          return Long2.MIN_VALUE;
        } else if (other.equals(Long2.MIN_VALUE)) {
          return Long2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Long2.ZERO)) {
            return other.isNegative() ? Long2.ONE : Long2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Long2.MIN_VALUE)) {
        return Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Long2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Long2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Long2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Long2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Long2.prototype.not = function() {
      return Long2.fromBits(~this.low_, ~this.high_);
    };
    Long2.prototype.and = function(other) {
      return Long2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Long2.prototype.or = function(other) {
      return Long2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Long2.prototype.xor = function(other) {
      return Long2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Long2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Long2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Long2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Long2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Long2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Long2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Long2.fromBits(high, 0);
        } else {
          return Long2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Long2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Long2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Long2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Long2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Long2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Long2.ZERO;
      } else if (value <= -Long2.TWO_PWR_63_DBL_) {
        return Long2.MIN_VALUE;
      } else if (value + 1 >= Long2.TWO_PWR_63_DBL_) {
        return Long2.MAX_VALUE;
      } else if (value < 0) {
        return Long2.fromNumber(-value).negate();
      } else {
        return new Long2(value % Long2.TWO_PWR_32_DBL_ | 0, value / Long2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Long2.fromBigInt = function(value) {
      return Long2.fromString(value.toString(10), 10);
    };
    Long2.fromBits = function(lowBits, highBits) {
      return new Long2(lowBits, highBits);
    };
    Long2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Long2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
      var result = Long2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Long2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Long2.fromNumber(value));
        }
      }
      return result;
    };
    Long2.INT_CACHE_ = {};
    Long2.TWO_PWR_16_DBL_ = 1 << 16;
    Long2.TWO_PWR_24_DBL_ = 1 << 24;
    Long2.TWO_PWR_32_DBL_ = Long2.TWO_PWR_16_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_31_DBL_ = Long2.TWO_PWR_32_DBL_ / 2;
    Long2.TWO_PWR_48_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_64_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_32_DBL_;
    Long2.TWO_PWR_63_DBL_ = Long2.TWO_PWR_64_DBL_ / 2;
    Long2.ZERO = Long2.fromInt(0);
    Long2.ONE = Long2.fromInt(1);
    Long2.NEG_ONE = Long2.fromInt(-1);
    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0);
    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0);
    Long2.TWO_PWR_24_ = Long2.fromInt(1 << 24);
    module2.exports = Long2;
    module2.exports.Long = Long2;
  }
});

// node_modules/bson/lib/bson/double.js
var require_double = __commonJS({
  "node_modules/bson/lib/bson/double.js"(exports2, module2) {
    function Double2(value) {
      if (!(this instanceof Double2))
        return new Double2(value);
      this._bsontype = "Double";
      this.value = value;
    }
    Double2.prototype.valueOf = function() {
      return this.value;
    };
    Double2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Double2;
    module2.exports.Double = Double2;
  }
});

// node_modules/bson/lib/bson/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/bson/lib/bson/timestamp.js"(exports2, module2) {
    function Timestamp2(low, high) {
      if (!(this instanceof Timestamp2))
        return new Timestamp2(low, high);
      this._bsontype = "Timestamp";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Timestamp2.prototype.toInt = function() {
      return this.low_;
    };
    Timestamp2.prototype.toNumber = function() {
      return this.high_ * Timestamp2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Timestamp2.prototype.toJSON = function() {
      return this.toString();
    };
    Timestamp2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          var radixTimestamp = Timestamp2.fromNumber(radix);
          var div = this.div(radixTimestamp);
          var rem = div.multiply(radixTimestamp).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Timestamp2.prototype.getHighBits = function() {
      return this.high_;
    };
    Timestamp2.prototype.getLowBits = function() {
      return this.low_;
    };
    Timestamp2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Timestamp2.TWO_PWR_32_DBL_ + this.low_;
    };
    Timestamp2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Timestamp2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Timestamp2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Timestamp2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Timestamp2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Timestamp2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Timestamp2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Timestamp2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Timestamp2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Timestamp2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Timestamp2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Timestamp2.prototype.negate = function() {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.MIN_VALUE;
      } else {
        return this.not().add(Timestamp2.ONE);
      }
    };
    Timestamp2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Timestamp2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Timestamp2.ZERO;
      } else if (other.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return other.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return this.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Timestamp2.TWO_PWR_24_) && other.lessThan(Timestamp2.TWO_PWR_24_)) {
        return Timestamp2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        if (other.equals(Timestamp2.ONE) || other.equals(Timestamp2.NEG_ONE)) {
          return Timestamp2.MIN_VALUE;
        } else if (other.equals(Timestamp2.MIN_VALUE)) {
          return Timestamp2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Timestamp2.ZERO)) {
            return other.isNegative() ? Timestamp2.ONE : Timestamp2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Timestamp2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Timestamp2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Timestamp2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Timestamp2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Timestamp2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Timestamp2.prototype.not = function() {
      return Timestamp2.fromBits(~this.low_, ~this.high_);
    };
    Timestamp2.prototype.and = function(other) {
      return Timestamp2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Timestamp2.prototype.or = function(other) {
      return Timestamp2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Timestamp2.prototype.xor = function(other) {
      return Timestamp2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Timestamp2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Timestamp2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Timestamp2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Timestamp2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Timestamp2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Timestamp2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Timestamp2.fromBits(high, 0);
        } else {
          return Timestamp2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Timestamp2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Timestamp2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Timestamp2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Timestamp2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Timestamp2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Timestamp2.ZERO;
      } else if (value <= -Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MIN_VALUE;
      } else if (value + 1 >= Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MAX_VALUE;
      } else if (value < 0) {
        return Timestamp2.fromNumber(-value).negate();
      } else {
        return new Timestamp2(value % Timestamp2.TWO_PWR_32_DBL_ | 0, value / Timestamp2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Timestamp2.fromBits = function(lowBits, highBits) {
      return new Timestamp2(lowBits, highBits);
    };
    Timestamp2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Timestamp2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 8));
      var result = Timestamp2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Timestamp2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Timestamp2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Timestamp2.fromNumber(value));
        }
      }
      return result;
    };
    Timestamp2.INT_CACHE_ = {};
    Timestamp2.TWO_PWR_16_DBL_ = 1 << 16;
    Timestamp2.TWO_PWR_24_DBL_ = 1 << 24;
    Timestamp2.TWO_PWR_32_DBL_ = Timestamp2.TWO_PWR_16_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_31_DBL_ = Timestamp2.TWO_PWR_32_DBL_ / 2;
    Timestamp2.TWO_PWR_48_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_64_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_32_DBL_;
    Timestamp2.TWO_PWR_63_DBL_ = Timestamp2.TWO_PWR_64_DBL_ / 2;
    Timestamp2.ZERO = Timestamp2.fromInt(0);
    Timestamp2.ONE = Timestamp2.fromInt(1);
    Timestamp2.NEG_ONE = Timestamp2.fromInt(-1);
    Timestamp2.MAX_VALUE = Timestamp2.fromBits(4294967295 | 0, 2147483647 | 0);
    Timestamp2.MIN_VALUE = Timestamp2.fromBits(0, 2147483648 | 0);
    Timestamp2.TWO_PWR_24_ = Timestamp2.fromInt(1 << 24);
    module2.exports = Timestamp2;
    module2.exports.Timestamp = Timestamp2;
  }
});

// node_modules/bson/lib/bson/parser/utils.js
var require_utils = __commonJS({
  "node_modules/bson/lib/bson/parser/utils.js"(exports2, module2) {
    "use strict";
    function normalizedFunctionString(fn) {
      return fn.toString().replace(/function *\(/, "function (");
    }
    function newBuffer(item, encoding) {
      return new Buffer(item, encoding);
    }
    function allocBuffer() {
      return Buffer.alloc.apply(Buffer, arguments);
    }
    function toBuffer() {
      return Buffer.from.apply(Buffer, arguments);
    }
    module2.exports = {
      normalizedFunctionString,
      allocBuffer: typeof Buffer.alloc === "function" ? allocBuffer : newBuffer,
      toBuffer: typeof Buffer.from === "function" ? toBuffer : newBuffer
    };
  }
});

// node_modules/bson/lib/bson/objectid.js
var require_objectid = __commonJS({
  "node_modules/bson/lib/bson/objectid.js"(exports2, module2) {
    var inspect = "inspect";
    var utils2 = require_utils();
    var MACHINE_ID = parseInt(Math.random() * 16777215, 10);
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    try {
      if (Buffer && Buffer.from) {
        hasBufferType = true;
        inspect = require("util").inspect.custom || "inspect";
      }
    } catch (err) {
      hasBufferType = false;
    }
    var hasBufferType;
    var ObjectID2 = function ObjectID3(id) {
      if (id instanceof ObjectID3)
        return id;
      if (!(this instanceof ObjectID3))
        return new ObjectID3(id);
      this._bsontype = "ObjectID";
      if (id == null || typeof id === "number") {
        this.id = this.generate(id);
        if (ObjectID3.cacheHexString)
          this.__id = this.toString("hex");
        return;
      }
      var valid = ObjectID3.isValid(id);
      if (!valid && id != null) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      } else if (valid && typeof id === "string" && id.length === 24 && hasBufferType) {
        return new ObjectID3(utils2.toBuffer(id, "hex"));
      } else if (valid && typeof id === "string" && id.length === 24) {
        return ObjectID3.createFromHexString(id);
      } else if (id != null && id.length === 12) {
        this.id = id;
      } else if (id != null && typeof id.toHexString === "function") {
        return id;
      } else {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (ObjectID3.cacheHexString)
        this.__id = this.toString("hex");
    };
    var hexTable = [];
    for (var i = 0; i < 256; i++) {
      hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
    }
    ObjectID2.prototype.toHexString = function() {
      if (ObjectID2.cacheHexString && this.__id)
        return this.__id;
      var hexString = "";
      if (!this.id || !this.id.length) {
        throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]");
      }
      if (this.id instanceof _Buffer) {
        hexString = convertToHex(this.id);
        if (ObjectID2.cacheHexString)
          this.__id = hexString;
        return hexString;
      }
      for (var i2 = 0; i2 < this.id.length; i2++) {
        hexString += hexTable[this.id.charCodeAt(i2)];
      }
      if (ObjectID2.cacheHexString)
        this.__id = hexString;
      return hexString;
    };
    ObjectID2.prototype.get_inc = function() {
      return ObjectID2.index = (ObjectID2.index + 1) % 16777215;
    };
    ObjectID2.prototype.getInc = function() {
      return this.get_inc();
    };
    ObjectID2.prototype.generate = function(time) {
      if (typeof time !== "number") {
        time = ~~(Date.now() / 1e3);
      }
      var pid = (typeof process === "undefined" || process.pid === 1 ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
      var inc = this.get_inc();
      var buffer = utils2.allocBuffer(12);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      buffer[6] = MACHINE_ID & 255;
      buffer[5] = MACHINE_ID >> 8 & 255;
      buffer[4] = MACHINE_ID >> 16 & 255;
      buffer[8] = pid & 255;
      buffer[7] = pid >> 8 & 255;
      buffer[11] = inc & 255;
      buffer[10] = inc >> 8 & 255;
      buffer[9] = inc >> 16 & 255;
      return buffer;
    };
    ObjectID2.prototype.toString = function(format2) {
      if (this.id && this.id.copy) {
        return this.id.toString(typeof format2 === "string" ? format2 : "hex");
      }
      return this.toHexString();
    };
    ObjectID2.prototype[inspect] = ObjectID2.prototype.toString;
    ObjectID2.prototype.toJSON = function() {
      return this.toHexString();
    };
    ObjectID2.prototype.equals = function equals(otherId) {
      if (otherId instanceof ObjectID2) {
        return this.toString() === otherId.toString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
        return otherId === this.id.toString("binary");
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12) {
        return otherId === this.id;
      } else if (otherId != null && (otherId instanceof ObjectID2 || otherId.toHexString)) {
        return otherId.toHexString() === this.toHexString();
      } else {
        return false;
      }
    };
    ObjectID2.prototype.getTimestamp = function() {
      var timestamp = new Date();
      var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      timestamp.setTime(Math.floor(time) * 1e3);
      return timestamp;
    };
    ObjectID2.index = ~~(Math.random() * 16777215);
    ObjectID2.createPk = function createPk() {
      return new ObjectID2();
    };
    ObjectID2.createFromTime = function createFromTime(time) {
      var buffer = utils2.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      return new ObjectID2(buffer);
    };
    var decodeLookup = [];
    i = 0;
    while (i < 10)
      decodeLookup[48 + i] = i++;
    while (i < 16)
      decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
    var _Buffer = Buffer;
    var convertToHex = function(bytes) {
      return bytes.toString("hex");
    };
    ObjectID2.createFromHexString = function createFromHexString(string) {
      if (typeof string === "undefined" || string != null && string.length !== 24) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (hasBufferType)
        return new ObjectID2(utils2.toBuffer(string, "hex"));
      var array = new _Buffer(12);
      var n = 0;
      var i2 = 0;
      while (i2 < 24) {
        array[n++] = decodeLookup[string.charCodeAt(i2++)] << 4 | decodeLookup[string.charCodeAt(i2++)];
      }
      return new ObjectID2(array);
    };
    ObjectID2.isValid = function isValid(id) {
      if (id == null)
        return false;
      if (typeof id === "number") {
        return true;
      }
      if (typeof id === "string") {
        return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
      }
      if (id instanceof ObjectID2) {
        return true;
      }
      if (id instanceof _Buffer) {
        return true;
      }
      if (typeof id.toHexString === "function" && (id.id instanceof _Buffer || typeof id.id === "string")) {
        return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
      }
      return false;
    };
    Object.defineProperty(ObjectID2.prototype, "generationTime", {
      enumerable: true,
      get: function() {
        return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      },
      set: function(value) {
        this.id[3] = value & 255;
        this.id[2] = value >> 8 & 255;
        this.id[1] = value >> 16 & 255;
        this.id[0] = value >> 24 & 255;
      }
    });
    module2.exports = ObjectID2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.ObjectId = ObjectID2;
  }
});

// node_modules/bson/lib/bson/regexp.js
var require_regexp = __commonJS({
  "node_modules/bson/lib/bson/regexp.js"(exports2, module2) {
    function BSONRegExp2(pattern, options2) {
      if (!(this instanceof BSONRegExp2))
        return new BSONRegExp2();
      this._bsontype = "BSONRegExp";
      this.pattern = pattern || "";
      this.options = options2 || "";
      for (var i = 0; i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new Error("the regular expression options [" + this.options[i] + "] is not supported");
        }
      }
    }
    module2.exports = BSONRegExp2;
    module2.exports.BSONRegExp = BSONRegExp2;
  }
});

// node_modules/bson/lib/bson/symbol.js
var require_symbol = __commonJS({
  "node_modules/bson/lib/bson/symbol.js"(exports2, module2) {
    var inspect = Buffer ? require("util").inspect.custom || "inspect" : "inspect";
    function Symbol2(value) {
      if (!(this instanceof Symbol2))
        return new Symbol2(value);
      this._bsontype = "Symbol";
      this.value = value;
    }
    Symbol2.prototype.valueOf = function() {
      return this.value;
    };
    Symbol2.prototype.toString = function() {
      return this.value;
    };
    Symbol2.prototype[inspect] = function() {
      return this.value;
    };
    Symbol2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Symbol2;
    module2.exports.Symbol = Symbol2;
  }
});

// node_modules/bson/lib/bson/int_32.js
var require_int_32 = __commonJS({
  "node_modules/bson/lib/bson/int_32.js"(exports2, module2) {
    var Int322 = function(value) {
      if (!(this instanceof Int322))
        return new Int322(value);
      this._bsontype = "Int32";
      this.value = value;
    };
    Int322.prototype.valueOf = function() {
      return this.value;
    };
    Int322.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Int322;
    module2.exports.Int32 = Int322;
  }
});

// node_modules/bson/lib/bson/code.js
var require_code = __commonJS({
  "node_modules/bson/lib/bson/code.js"(exports2, module2) {
    var Code2 = function Code3(code, scope) {
      if (!(this instanceof Code3))
        return new Code3(code, scope);
      this._bsontype = "Code";
      this.code = code;
      this.scope = scope;
    };
    Code2.prototype.toJSON = function() {
      return {scope: this.scope, code: this.code};
    };
    module2.exports = Code2;
    module2.exports.Code = Code2;
  }
});

// node_modules/bson/lib/bson/decimal128.js
var require_decimal128 = __commonJS({
  "node_modules/bson/lib/bson/decimal128.js"(exports2, module2) {
    "use strict";
    var Long2 = require_long();
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = [
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_NEGATIVE_BUFFER = [
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_POSITIVE_BUFFER = [
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var utils2 = require_utils();
    var isDigit = function(value) {
      return !isNaN(parseInt(value, 10));
    };
    var divideu128 = function(value) {
      var DIVISOR = Long2.fromNumber(1e3 * 1e3 * 1e3);
      var _rem = Long2.fromNumber(0);
      var i = 0;
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return {quotient: value, rem: _rem};
      }
      for (i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long2(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low_;
        _rem = _rem.modulo(DIVISOR);
      }
      return {quotient: value, rem: _rem};
    };
    var multiply64x2 = function(left, right) {
      if (!left && !right) {
        return {high: Long2.fromNumber(0), low: Long2.fromNumber(0)};
      }
      var leftHigh = left.shiftRightUnsigned(32);
      var leftLow = new Long2(left.getLowBits(), 0);
      var rightHigh = right.shiftRightUnsigned(32);
      var rightLow = new Long2(right.getLowBits(), 0);
      var productHigh = leftHigh.multiply(rightHigh);
      var productMid = leftHigh.multiply(rightLow);
      var productMid2 = leftLow.multiply(rightHigh);
      var productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long2(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long2(productLow.getLowBits(), 0));
      return {high: productHigh, low: productLow};
    };
    var lessThan = function(left, right) {
      var uhleft = left.high_ >>> 0;
      var uhright = right.high_ >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        var ulleft = left.low_ >>> 0;
        var ulright = right.low_ >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    };
    var Decimal1282 = function(bytes) {
      this._bsontype = "Decimal128";
      this.bytes = bytes;
    };
    Decimal1282.fromString = function(string) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = [0, 0];
      var significandLow = [0, 0];
      var biasedExponent = 0;
      var index2 = 0;
      string = string.trim();
      if (string.length >= 7e3) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      var stringMatch = string.match(PARSE_STRING_REGEXP);
      var infMatch = string.match(PARSE_INF_REGEXP);
      var nanMatch = string.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || string.length === 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (stringMatch && stringMatch[4] && stringMatch[2] === void 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index2] === "+" || string[index2] === "-") {
        isNegative = string[index2++] === "-";
      }
      if (!isDigit(string[index2]) && string[index2] !== ".") {
        if (string[index2] === "i" || string[index2] === "I") {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        } else if (string[index2] === "N") {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
      }
      while (isDigit(string[index2]) || string[index2] === ".") {
        if (string[index2] === ".") {
          if (sawRadix) {
            return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
          }
          sawRadix = true;
          index2 = index2 + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (string[index2] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(string[index2], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) {
          nDigits = nDigits + 1;
        }
        if (sawRadix) {
          radixPosition = radixPosition + 1;
        }
        nDigitsRead = nDigitsRead + 1;
        index2 = index2 + 1;
      }
      if (sawRadix && !nDigitsRead) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index2] === "e" || string[index2] === "E") {
        var match = string.substr(++index2).match(EXPONENT_REGEX);
        if (!match || !match[2]) {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
        exponent = parseInt(match[0], 10);
        index2 = index2 + match[0].length;
      }
      if (string[index2]) {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (exponent !== 0 && significantDigits !== 1) {
          while (string[firstNonZero + significantDigits - 1] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits && string[significantDigits] !== "0") {
        var endOfString = nDigitsRead;
        if (sawRadix && exponent === EXPONENT_MIN) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1;
            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(string[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                }
              }
            } else {
              break;
            }
          }
        }
      }
      significandHigh = Long2.fromNumber(0);
      significandLow = Long2.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long2.fromNumber(0);
        significandLow = Long2.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        dIdx = firstDigit;
        significandLow = Long2.fromNumber(digits[dIdx++]);
        significandHigh = new Long2(0, 0);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      } else {
        dIdx = firstDigit;
        significandHigh = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long2.fromNumber(10));
          significandHigh = significandHigh.add(Long2.fromNumber(digits[dIdx]));
        }
        significandLow = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      }
      var significand = multiply64x2(significandHigh, Long2.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long2.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec = {low: Long2.fromNumber(0), high: Long2.fromNumber(0)};
      if (significand.high.shiftRightUnsigned(49).and(Long2.fromNumber(1)).equals(Long2.fromNumber)) {
        dec.high = dec.high.or(Long2.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long2.fromNumber(biasedExponent).and(Long2.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long2.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long2.fromString("9223372036854775808"));
      }
      var buffer = utils2.allocBuffer(16);
      index2 = 0;
      buffer[index2++] = dec.low.low_ & 255;
      buffer[index2++] = dec.low.low_ >> 8 & 255;
      buffer[index2++] = dec.low.low_ >> 16 & 255;
      buffer[index2++] = dec.low.low_ >> 24 & 255;
      buffer[index2++] = dec.low.high_ & 255;
      buffer[index2++] = dec.low.high_ >> 8 & 255;
      buffer[index2++] = dec.low.high_ >> 16 & 255;
      buffer[index2++] = dec.low.high_ >> 24 & 255;
      buffer[index2++] = dec.high.low_ & 255;
      buffer[index2++] = dec.high.low_ >> 8 & 255;
      buffer[index2++] = dec.high.low_ >> 16 & 255;
      buffer[index2++] = dec.high.low_ >> 24 & 255;
      buffer[index2++] = dec.high.high_ & 255;
      buffer[index2++] = dec.high.high_ >> 8 & 255;
      buffer[index2++] = dec.high.high_ >> 16 & 255;
      buffer[index2++] = dec.high.high_ >> 24 & 255;
      return new Decimal1282(buffer);
    };
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    EXPONENT_BIAS = 6176;
    Decimal1282.prototype.toString = function() {
      var high;
      var midh;
      var midl;
      var low;
      var combination;
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++)
        significand[i] = 0;
      var index2 = 0;
      var exponent;
      var scientific_exponent;
      var is_zero = false;
      var significand_msb;
      var significand128 = {parts: new Array(4)};
      i;
      var j, k;
      var string = [];
      index2 = 0;
      var buffer = this.bytes;
      low = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      midl = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      midh = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      high = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      index2 = 0;
      var dec = {
        low: new Long2(low, midl),
        high: new Long2(midh, high)
      };
      if (dec.high.lessThan(Long2.ZERO)) {
        string.push("-");
      }
      combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low_;
          if (!least_digits)
            continue;
          for (j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index2] = 0;
      } else {
        significand_digits = 36;
        i = 0;
        while (!significand[index2]) {
          i++;
          significand_digits = significand_digits - 1;
          index2 = index2 + 1;
        }
      }
      scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        string.push(significand[index2++]);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (i = 0; i < significand_digits; i++) {
          string.push(significand[index2++]);
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push("+" + scientific_exponent);
        } else {
          string.push(scientific_exponent);
        }
      } else {
        if (exponent >= 0) {
          for (i = 0; i < significand_digits; i++) {
            string.push(significand[index2++]);
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (i = 0; i < radix_position; i++) {
              string.push(significand[index2++]);
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(significand[index2++]);
          }
        }
      }
      return string.join("");
    };
    Decimal1282.prototype.toJSON = function() {
      return {$numberDecimal: this.toString()};
    };
    module2.exports = Decimal1282;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/lib/bson/min_key.js
var require_min_key = __commonJS({
  "node_modules/bson/lib/bson/min_key.js"(exports2, module2) {
    function MinKey2() {
      if (!(this instanceof MinKey2))
        return new MinKey2();
      this._bsontype = "MinKey";
    }
    module2.exports = MinKey2;
    module2.exports.MinKey = MinKey2;
  }
});

// node_modules/bson/lib/bson/max_key.js
var require_max_key = __commonJS({
  "node_modules/bson/lib/bson/max_key.js"(exports2, module2) {
    function MaxKey2() {
      if (!(this instanceof MaxKey2))
        return new MaxKey2();
      this._bsontype = "MaxKey";
    }
    module2.exports = MaxKey2;
    module2.exports.MaxKey = MaxKey2;
  }
});

// node_modules/bson/lib/bson/db_ref.js
var require_db_ref = __commonJS({
  "node_modules/bson/lib/bson/db_ref.js"(exports2, module2) {
    function DBRef2(namespace, oid, db) {
      if (!(this instanceof DBRef2))
        return new DBRef2(namespace, oid, db);
      this._bsontype = "DBRef";
      this.namespace = namespace;
      this.oid = oid;
      this.db = db;
    }
    DBRef2.prototype.toJSON = function() {
      return {
        $ref: this.namespace,
        $id: this.oid,
        $db: this.db == null ? "" : this.db
      };
    };
    module2.exports = DBRef2;
    module2.exports.DBRef = DBRef2;
  }
});

// node_modules/bson/lib/bson/binary.js
var require_binary = __commonJS({
  "node_modules/bson/lib/bson/binary.js"(exports2, module2) {
    if (typeof global !== "undefined") {
      Buffer2 = require("buffer").Buffer;
    }
    var Buffer2;
    var utils2 = require_utils();
    function Binary2(buffer, subType) {
      if (!(this instanceof Binary2))
        return new Binary2(buffer, subType);
      if (buffer != null && !(typeof buffer === "string") && !Buffer2.isBuffer(buffer) && !(buffer instanceof Uint8Array) && !Array.isArray(buffer)) {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
      this._bsontype = "Binary";
      if (buffer instanceof Number) {
        this.sub_type = buffer;
        this.position = 0;
      } else {
        this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
        this.position = 0;
      }
      if (buffer != null && !(buffer instanceof Number)) {
        if (typeof buffer === "string") {
          if (typeof Buffer2 !== "undefined") {
            this.buffer = utils2.toBuffer(buffer);
          } else if (typeof Uint8Array !== "undefined" || Object.prototype.toString.call(buffer) === "[object Array]") {
            this.buffer = writeStringToArray(buffer);
          } else {
            throw new Error("only String, Buffer, Uint8Array or Array accepted");
          }
        } else {
          this.buffer = buffer;
        }
        this.position = buffer.length;
      } else {
        if (typeof Buffer2 !== "undefined") {
          this.buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE);
        } else if (typeof Uint8Array !== "undefined") {
          this.buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE));
        } else {
          this.buffer = new Array(Binary2.BUFFER_SIZE);
        }
        this.position = 0;
      }
    }
    Binary2.prototype.put = function put2(byte_value) {
      if (byte_value["length"] != null && typeof byte_value !== "number" && byte_value.length !== 1)
        throw new Error("only accepts single character String, Uint8Array or Array");
      if (typeof byte_value !== "number" && byte_value < 0 || byte_value > 255)
        throw new Error("only accepts number in a valid unsigned byte range 0-255");
      var decoded_byte = null;
      if (typeof byte_value === "string") {
        decoded_byte = byte_value.charCodeAt(0);
      } else if (byte_value["length"] != null) {
        decoded_byte = byte_value[0];
      } else {
        decoded_byte = byte_value;
      }
      if (this.buffer.length > this.position) {
        this.buffer[this.position++] = decoded_byte;
      } else {
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          var buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE + this.buffer.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        } else {
          buffer = null;
          if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
            buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE + this.buffer.length));
          } else {
            buffer = new Array(Binary2.BUFFER_SIZE + this.buffer.length);
          }
          for (var i = 0; i < this.buffer.length; i++) {
            buffer[i] = this.buffer[i];
          }
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        }
      }
    };
    Binary2.prototype.write = function write(string, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.length < offset + string.length) {
        var buffer = null;
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          buffer = utils2.allocBuffer(this.buffer.length + string.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
        } else if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
          buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
          for (var i = 0; i < this.position; i++) {
            buffer[i] = this.buffer[i];
          }
        }
        this.buffer = buffer;
      }
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(string) && Buffer2.isBuffer(this.buffer)) {
        string.copy(this.buffer, offset, 0, string.length);
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (typeof Buffer2 !== "undefined" && typeof string === "string" && Buffer2.isBuffer(this.buffer)) {
        this.buffer.write(string, offset, "binary");
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (Object.prototype.toString.call(string) === "[object Uint8Array]" || Object.prototype.toString.call(string) === "[object Array]" && typeof string !== "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string[i];
        }
        this.position = offset > this.position ? offset : this.position;
      } else if (typeof string === "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string.charCodeAt(i);
        }
        this.position = offset > this.position ? offset : this.position;
      }
    };
    Binary2.prototype.read = function read2(position, length) {
      length = length && length > 0 ? length : this.position;
      if (this.buffer["slice"]) {
        return this.buffer.slice(position, position + length);
      } else {
        var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
        for (var i = 0; i < length; i++) {
          buffer[i] = this.buffer[position++];
        }
      }
      return buffer;
    };
    Binary2.prototype.value = function value(asRaw) {
      asRaw = asRaw == null ? false : asRaw;
      if (asRaw && typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer) && this.buffer.length === this.position)
        return this.buffer;
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString("binary", 0, this.position);
      } else {
        if (asRaw) {
          if (this.buffer["slice"] != null) {
            return this.buffer.slice(0, this.position);
          } else {
            var newBuffer = Object.prototype.toString.call(this.buffer) === "[object Uint8Array]" ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
            for (var i = 0; i < this.position; i++) {
              newBuffer[i] = this.buffer[i];
            }
            return newBuffer;
          }
        } else {
          return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
        }
      }
    };
    Binary2.prototype.length = function length() {
      return this.position;
    };
    Binary2.prototype.toJSON = function() {
      return this.buffer != null ? this.buffer.toString("base64") : "";
    };
    Binary2.prototype.toString = function(format2) {
      return this.buffer != null ? this.buffer.slice(0, this.position).toString(format2) : "";
    };
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var writeStringToArray = function(data) {
      var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        buffer[i] = data.charCodeAt(i);
      }
      return buffer;
    };
    var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
      var result = "";
      for (var i = startIndex; i < endIndex; i++) {
        result = result + String.fromCharCode(byteArray[i]);
      }
      return result;
    };
    Binary2.BUFFER_SIZE = 256;
    Binary2.SUBTYPE_DEFAULT = 0;
    Binary2.SUBTYPE_FUNCTION = 1;
    Binary2.SUBTYPE_BYTE_ARRAY = 2;
    Binary2.SUBTYPE_UUID_OLD = 3;
    Binary2.SUBTYPE_UUID = 4;
    Binary2.SUBTYPE_MD5 = 5;
    Binary2.SUBTYPE_USER_DEFINED = 128;
    module2.exports = Binary2;
    module2.exports.Binary = Binary2;
  }
});

// node_modules/bson/lib/bson/parser/deserializer.js
var require_deserializer = __commonJS({
  "node_modules/bson/lib/bson/parser/deserializer.js"(exports, module) {
    "use strict";
    var Long = require_long().Long;
    var Double = require_double().Double;
    var Timestamp = require_timestamp().Timestamp;
    var ObjectID = require_objectid().ObjectID;
    var Symbol = require_symbol().Symbol;
    var Code = require_code().Code;
    var MinKey = require_min_key().MinKey;
    var MaxKey = require_max_key().MaxKey;
    var Decimal128 = require_decimal128();
    var Int32 = require_int_32();
    var DBRef = require_db_ref().DBRef;
    var BSONRegExp = require_regexp().BSONRegExp;
    var Binary = require_binary().Binary;
    var utils = require_utils();
    var deserialize = function(buffer, options2, isArray) {
      options2 = options2 == null ? {} : options2;
      var index2 = options2 && options2.index ? options2.index : 0;
      var size = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
      if (size < 5 || buffer.length < size || size + index2 > buffer.length) {
        throw new Error("corrupt bson message");
      }
      if (buffer[index2 + size - 1] !== 0) {
        throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer, index2, options2, isArray);
    };
    var deserializeObject = function(buffer, index2, options2, isArray) {
      var evalFunctions = options2["evalFunctions"] == null ? false : options2["evalFunctions"];
      var cacheFunctions = options2["cacheFunctions"] == null ? false : options2["cacheFunctions"];
      var cacheFunctionsCrc32 = options2["cacheFunctionsCrc32"] == null ? false : options2["cacheFunctionsCrc32"];
      if (!cacheFunctionsCrc32)
        var crc32 = null;
      var fieldsAsRaw = options2["fieldsAsRaw"] == null ? null : options2["fieldsAsRaw"];
      var raw = options2["raw"] == null ? false : options2["raw"];
      var bsonRegExp = typeof options2["bsonRegExp"] === "boolean" ? options2["bsonRegExp"] : false;
      var promoteBuffers = options2["promoteBuffers"] == null ? false : options2["promoteBuffers"];
      var promoteLongs = options2["promoteLongs"] == null ? true : options2["promoteLongs"];
      var promoteValues = options2["promoteValues"] == null ? true : options2["promoteValues"];
      var startIndex = index2;
      if (buffer.length < 5)
        throw new Error("corrupt bson message < 5 bytes long");
      var size = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      if (size < 5 || size > buffer.length)
        throw new Error("corrupt bson message");
      var object = isArray ? [] : {};
      var arrayIndex = 0;
      var done = false;
      while (!done) {
        var elementType = buffer[index2++];
        if (elementType === 0)
          break;
        var i = index2;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        var name = isArray ? arrayIndex++ : buffer.toString("utf8", index2, i);
        index2 = i + 1;
        if (elementType === BSON.BSON_DATA_STRING) {
          var stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name] = buffer.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_OID) {
          var oid = utils.allocBuffer(12);
          buffer.copy(oid, 0, index2, index2 + 12);
          object[name] = new ObjectID(oid);
          index2 = index2 + 12;
        } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {
          object[name] = new Int32(buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24);
        } else if (elementType === BSON.BSON_DATA_INT) {
          object[name] = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
        } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {
          object[name] = new Double(buffer.readDoubleLE(index2));
          index2 = index2 + 8;
        } else if (elementType === BSON.BSON_DATA_NUMBER) {
          object[name] = buffer.readDoubleLE(index2);
          index2 = index2 + 8;
        } else if (elementType === BSON.BSON_DATA_DATE) {
          var lowBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          var highBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          object[name] = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType === BSON.BSON_DATA_BOOLEAN) {
          if (buffer[index2] !== 0 && buffer[index2] !== 1)
            throw new Error("illegal boolean type value");
          object[name] = buffer[index2++] === 1;
        } else if (elementType === BSON.BSON_DATA_OBJECT) {
          var _index = index2;
          var objectSize = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
          if (objectSize <= 0 || objectSize > buffer.length - index2)
            throw new Error("bad embedded document length in bson");
          if (raw) {
            object[name] = buffer.slice(index2, index2 + objectSize);
          } else {
            object[name] = deserializeObject(buffer, _index, options2, false);
          }
          index2 = index2 + objectSize;
        } else if (elementType === BSON.BSON_DATA_ARRAY) {
          _index = index2;
          objectSize = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
          var arrayOptions = options2;
          var stopIndex = index2 + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name]) {
            arrayOptions = {};
            for (var n in options2)
              arrayOptions[n] = options2[n];
            arrayOptions["raw"] = true;
          }
          object[name] = deserializeObject(buffer, _index, arrayOptions, true);
          index2 = index2 + objectSize;
          if (buffer[index2 - 1] !== 0)
            throw new Error("invalid array terminator byte");
          if (index2 !== stopIndex)
            throw new Error("corrupted array bson");
        } else if (elementType === BSON.BSON_DATA_UNDEFINED) {
          object[name] = void 0;
        } else if (elementType === BSON.BSON_DATA_NULL) {
          object[name] = null;
        } else if (elementType === BSON.BSON_DATA_LONG) {
          lowBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          highBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          var long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            object[name] = long;
          }
        } else if (elementType === BSON.BSON_DATA_DECIMAL128) {
          var bytes = utils.allocBuffer(16);
          buffer.copy(bytes, 0, index2, index2 + 16);
          index2 = index2 + 16;
          var decimal128 = new Decimal128(bytes);
          object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;
        } else if (elementType === BSON.BSON_DATA_BINARY) {
          var binarySize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          var totalBinarySize = binarySize;
          var subType = buffer[index2++];
          if (binarySize < 0)
            throw new Error("Negative binary type element size found");
          if (binarySize > buffer.length)
            throw new Error("Binary type size larger than document size");
          if (buffer["slice"] != null) {
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            if (promoteBuffers && promoteValues) {
              object[name] = buffer.slice(index2, index2 + binarySize);
            } else {
              object[name] = new Binary(buffer.slice(index2, index2 + binarySize), subType);
            }
          } else {
            var _buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            for (i = 0; i < binarySize; i++) {
              _buffer[i] = buffer[index2 + i];
            }
            if (promoteBuffers && promoteValues) {
              object[name] = _buffer;
            } else {
              object[name] = new Binary(_buffer, subType);
            }
          }
          index2 = index2 + binarySize;
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var source = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var regExpOptions = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          var optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          object[name] = new RegExp(source, optionsArray.join(""));
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          source = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          regExpOptions = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          object[name] = new BSONRegExp(source, regExpOptions);
        } else if (elementType === BSON.BSON_DATA_SYMBOL) {
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name] = new Symbol(buffer.toString("utf8", index2, index2 + stringSize - 1));
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {
          lowBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          highBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          object[name] = new Timestamp(lowBits, highBits);
        } else if (elementType === BSON.BSON_DATA_MIN_KEY) {
          object[name] = new MinKey();
        } else if (elementType === BSON.BSON_DATA_MAX_KEY) {
          object[name] = new MaxKey();
        } else if (elementType === BSON.BSON_DATA_CODE) {
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var functionString = buffer.toString("utf8", index2, index2 + stringSize - 1);
          if (evalFunctions) {
            if (cacheFunctions) {
              var hash2 = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name] = isolateEvalWithHash(functionCache, hash2, functionString, object);
            } else {
              object[name] = isolateEval(functionString);
            }
          } else {
            object[name] = new Code(functionString);
          }
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {
          var totalSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new Error("code_w_scope total size shorter minimum expected length");
          }
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          functionString = buffer.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
          _index = index2;
          objectSize = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
          var scopeObject = deserializeObject(buffer, _index, options2, false);
          index2 = index2 + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to long, clips outer document");
          }
          if (evalFunctions) {
            if (cacheFunctions) {
              hash2 = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name] = isolateEvalWithHash(functionCache, hash2, functionString, object);
            } else {
              object[name] = isolateEval(functionString);
            }
            object[name].scope = scopeObject;
          } else {
            object[name] = new Code(functionString, scopeObject);
          }
        } else if (elementType === BSON.BSON_DATA_DBPOINTER) {
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var namespace = buffer.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
          var oidBuffer = utils.allocBuffer(12);
          buffer.copy(oidBuffer, 0, index2, index2 + 12);
          oid = new ObjectID(oidBuffer);
          index2 = index2 + 12;
          var parts = namespace.split(".");
          var db = parts.shift();
          var collection = parts.join(".");
          object[name] = new DBRef(collection, oid, db);
        } else {
          throw new Error("Detected unknown BSON type " + elementType.toString(16) + ' for fieldname "' + name + '", are you using the latest BSON parser');
        }
      }
      if (size !== index2 - startIndex) {
        if (isArray)
          throw new Error("corrupt array bson");
        throw new Error("corrupt object bson");
      }
      if (object["$id"] != null)
        object = new DBRef(object["$ref"], object["$id"], object["$db"]);
      return object;
    };
    var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
      var value = null;
      if (functionCache[hash] == null) {
        eval("value = " + functionString);
        functionCache[hash] = value;
      }
      return functionCache[hash].bind(object);
    };
    var isolateEval = function(functionString) {
      var value = null;
      eval("value = " + functionString);
      return value;
    };
    var BSON = {};
    var functionCache = BSON.functionCache = {};
    BSON.BSON_DATA_NUMBER = 1;
    BSON.BSON_DATA_STRING = 2;
    BSON.BSON_DATA_OBJECT = 3;
    BSON.BSON_DATA_ARRAY = 4;
    BSON.BSON_DATA_BINARY = 5;
    BSON.BSON_DATA_UNDEFINED = 6;
    BSON.BSON_DATA_OID = 7;
    BSON.BSON_DATA_BOOLEAN = 8;
    BSON.BSON_DATA_DATE = 9;
    BSON.BSON_DATA_NULL = 10;
    BSON.BSON_DATA_REGEXP = 11;
    BSON.BSON_DATA_DBPOINTER = 12;
    BSON.BSON_DATA_CODE = 13;
    BSON.BSON_DATA_SYMBOL = 14;
    BSON.BSON_DATA_CODE_W_SCOPE = 15;
    BSON.BSON_DATA_INT = 16;
    BSON.BSON_DATA_TIMESTAMP = 17;
    BSON.BSON_DATA_LONG = 18;
    BSON.BSON_DATA_DECIMAL128 = 19;
    BSON.BSON_DATA_MIN_KEY = 255;
    BSON.BSON_DATA_MAX_KEY = 127;
    BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON.BSON_INT32_MAX = 2147483647;
    BSON.BSON_INT32_MIN = -2147483648;
    BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON.JS_INT_MAX = 9007199254740992;
    BSON.JS_INT_MIN = -9007199254740992;
    var JS_INT_MAX_LONG = Long.fromNumber(9007199254740992);
    var JS_INT_MIN_LONG = Long.fromNumber(-9007199254740992);
    module.exports = deserialize;
  }
});

// node_modules/bson/lib/bson/float_parser.js
var require_float_parser = __commonJS({
  "node_modules/bson/lib/bson/float_parser.js"(exports2) {
    var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
      var e, m, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = bBE ? 0 : nBytes - 1, d = bBE ? 1 : -1, s2 = buffer[offset + i];
      i += d;
      e = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
      var e, m, c, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = bBE ? nBytes - 1 : 0, d = bBE ? -1 : 1, s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8)
        ;
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8)
        ;
      buffer[offset + i - d] |= s2 * 128;
    };
    exports2.readIEEE754 = readIEEE754;
    exports2.writeIEEE754 = writeIEEE754;
  }
});

// node_modules/bson/lib/bson/parser/serializer.js
var require_serializer = __commonJS({
  "node_modules/bson/lib/bson/parser/serializer.js"(exports2, module2) {
    "use strict";
    var writeIEEE754 = require_float_parser().writeIEEE754;
    var Long2 = require_long().Long;
    var Map2 = require_map();
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils().normalizedFunctionString;
    var regexp = /\x00/;
    var ignoreKeys = ["$db", "$ref", "$id", "$clusterTime"];
    var isDate = function isDate2(d) {
      return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
    };
    var isRegExp = function isRegExp2(d) {
      return Object.prototype.toString.call(d) === "[object RegExp]";
    };
    var serializeString = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_STRING;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes + 1;
      buffer[index2 - 1] = 0;
      var size = buffer.write(value, index2 + 4, "utf8");
      buffer[index2 + 3] = size + 1 >> 24 & 255;
      buffer[index2 + 2] = size + 1 >> 16 & 255;
      buffer[index2 + 1] = size + 1 >> 8 & 255;
      buffer[index2] = size + 1 & 255;
      index2 = index2 + 4 + size;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeNumber = function(buffer, key, value, index2, isArray) {
      if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
        if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
          buffer[index2++] = BSON2.BSON_DATA_INT;
          var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer[index2++] = 0;
          buffer[index2++] = value & 255;
          buffer[index2++] = value >> 8 & 255;
          buffer[index2++] = value >> 16 & 255;
          buffer[index2++] = value >> 24 & 255;
        } else if (value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
          buffer[index2++] = BSON2.BSON_DATA_NUMBER;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer[index2++] = 0;
          writeIEEE754(buffer, value, index2, "little", 52, 8);
          index2 = index2 + 8;
        } else {
          buffer[index2++] = BSON2.BSON_DATA_LONG;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer[index2++] = 0;
          var longVal = Long2.fromNumber(value);
          var lowBits = longVal.getLowBits();
          var highBits = longVal.getHighBits();
          buffer[index2++] = lowBits & 255;
          buffer[index2++] = lowBits >> 8 & 255;
          buffer[index2++] = lowBits >> 16 & 255;
          buffer[index2++] = lowBits >> 24 & 255;
          buffer[index2++] = highBits & 255;
          buffer[index2++] = highBits >> 8 & 255;
          buffer[index2++] = highBits >> 16 & 255;
          buffer[index2++] = highBits >> 24 & 255;
        }
      } else {
        buffer[index2++] = BSON2.BSON_DATA_NUMBER;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer[index2++] = 0;
        writeIEEE754(buffer, value, index2, "little", 52, 8);
        index2 = index2 + 8;
      }
      return index2;
    };
    var serializeNull = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_NULL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeBoolean = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_BOOLEAN;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      buffer[index2++] = value ? 1 : 0;
      return index2;
    };
    var serializeDate = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_DATE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var dateInMilis = Long2.fromNumber(value.getTime());
      var lowBits = dateInMilis.getLowBits();
      var highBits = dateInMilis.getHighBits();
      buffer[index2++] = lowBits & 255;
      buffer[index2++] = lowBits >> 8 & 255;
      buffer[index2++] = lowBits >> 16 & 255;
      buffer[index2++] = lowBits >> 24 & 255;
      buffer[index2++] = highBits & 255;
      buffer[index2++] = highBits >> 8 & 255;
      buffer[index2++] = highBits >> 16 & 255;
      buffer[index2++] = highBits >> 24 & 255;
      return index2;
    };
    var serializeRegExp = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw Error("value " + value.source + " must not contain null bytes");
      }
      index2 = index2 + buffer.write(value.source, index2, "utf8");
      buffer[index2++] = 0;
      if (value.global)
        buffer[index2++] = 115;
      if (value.ignoreCase)
        buffer[index2++] = 105;
      if (value.multiline)
        buffer[index2++] = 109;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeBSONRegExp = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      if (value.pattern.match(regexp) != null) {
        throw Error("pattern " + value.pattern + " must not contain null bytes");
      }
      index2 = index2 + buffer.write(value.pattern, index2, "utf8");
      buffer[index2++] = 0;
      index2 = index2 + buffer.write(value.options.split("").sort().join(""), index2, "utf8");
      buffer[index2++] = 0;
      return index2;
    };
    var serializeMinMax = function(buffer, key, value, index2, isArray) {
      if (value === null) {
        buffer[index2++] = BSON2.BSON_DATA_NULL;
      } else if (value._bsontype === "MinKey") {
        buffer[index2++] = BSON2.BSON_DATA_MIN_KEY;
      } else {
        buffer[index2++] = BSON2.BSON_DATA_MAX_KEY;
      }
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeObjectId = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_OID;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      if (typeof value.id === "string") {
        buffer.write(value.id, index2, "binary");
      } else if (value.id && value.id.copy) {
        value.id.copy(buffer, index2, 0, 12);
      } else {
        throw new Error("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
      }
      return index2 + 12;
    };
    var serializeBuffer = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var size = value.length;
      buffer[index2++] = size & 255;
      buffer[index2++] = size >> 8 & 255;
      buffer[index2++] = size >> 16 & 255;
      buffer[index2++] = size >> 24 & 255;
      buffer[index2++] = BSON2.BSON_BINARY_SUBTYPE_DEFAULT;
      value.copy(buffer, index2, 0, size);
      index2 = index2 + size;
      return index2;
    };
    var serializeObject = function(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === value)
          throw new Error("cyclic dependency detected");
      }
      path.push(value);
      buffer[index2++] = Array.isArray(value) ? BSON2.BSON_DATA_ARRAY : BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var endIndex = serializeInto(buffer, value, checkKeys, index2, depth + 1, serializeFunctions, ignoreUndefined, path);
      path.pop();
      return endIndex;
    };
    var serializeDecimal128 = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_DECIMAL128;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      value.bytes.copy(buffer, index2, 0, 16);
      return index2 + 16;
    };
    var serializeLong = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = value._bsontype === "Long" ? BSON2.BSON_DATA_LONG : BSON2.BSON_DATA_TIMESTAMP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var lowBits = value.getLowBits();
      var highBits = value.getHighBits();
      buffer[index2++] = lowBits & 255;
      buffer[index2++] = lowBits >> 8 & 255;
      buffer[index2++] = lowBits >> 16 & 255;
      buffer[index2++] = lowBits >> 24 & 255;
      buffer[index2++] = highBits & 255;
      buffer[index2++] = highBits >> 8 & 255;
      buffer[index2++] = highBits >> 16 & 255;
      buffer[index2++] = highBits >> 24 & 255;
      return index2;
    };
    var serializeInt32 = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      buffer[index2++] = value & 255;
      buffer[index2++] = value >> 8 & 255;
      buffer[index2++] = value >> 16 & 255;
      buffer[index2++] = value >> 24 & 255;
      return index2;
    };
    var serializeDouble = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_NUMBER;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      writeIEEE754(buffer, value, index2, "little", 52, 8);
      index2 = index2 + 8;
      return index2;
    };
    var serializeFunction = function(buffer, key, value, index2, checkKeys, depth, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_CODE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var functionString = normalizedFunctionString(value);
      var size = buffer.write(functionString, index2 + 4, "utf8") + 1;
      buffer[index2] = size & 255;
      buffer[index2 + 1] = size >> 8 & 255;
      buffer[index2 + 2] = size >> 16 & 255;
      buffer[index2 + 3] = size >> 24 & 255;
      index2 = index2 + 4 + size - 1;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeCode = function(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
      if (value.scope && typeof value.scope === "object") {
        buffer[index2++] = BSON2.BSON_DATA_CODE_W_SCOPE;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer[index2++] = 0;
        var startIndex = index2;
        var functionString = typeof value.code === "string" ? value.code : value.code.toString();
        index2 = index2 + 4;
        var codeSize = buffer.write(functionString, index2 + 4, "utf8") + 1;
        buffer[index2] = codeSize & 255;
        buffer[index2 + 1] = codeSize >> 8 & 255;
        buffer[index2 + 2] = codeSize >> 16 & 255;
        buffer[index2 + 3] = codeSize >> 24 & 255;
        buffer[index2 + 4 + codeSize - 1] = 0;
        index2 = index2 + codeSize + 4;
        var endIndex = serializeInto(buffer, value.scope, checkKeys, index2, depth + 1, serializeFunctions, ignoreUndefined);
        index2 = endIndex - 1;
        var totalSize = endIndex - startIndex;
        buffer[startIndex++] = totalSize & 255;
        buffer[startIndex++] = totalSize >> 8 & 255;
        buffer[startIndex++] = totalSize >> 16 & 255;
        buffer[startIndex++] = totalSize >> 24 & 255;
        buffer[index2++] = 0;
      } else {
        buffer[index2++] = BSON2.BSON_DATA_CODE;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer[index2++] = 0;
        functionString = value.code.toString();
        var size = buffer.write(functionString, index2 + 4, "utf8") + 1;
        buffer[index2] = size & 255;
        buffer[index2 + 1] = size >> 8 & 255;
        buffer[index2 + 2] = size >> 16 & 255;
        buffer[index2 + 3] = size >> 24 & 255;
        index2 = index2 + 4 + size - 1;
        buffer[index2++] = 0;
      }
      return index2;
    };
    var serializeBinary = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var data = value.value(true);
      var size = value.position;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      buffer[index2++] = size & 255;
      buffer[index2++] = size >> 8 & 255;
      buffer[index2++] = size >> 16 & 255;
      buffer[index2++] = size >> 24 & 255;
      buffer[index2++] = value.sub_type;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        buffer[index2++] = size & 255;
        buffer[index2++] = size >> 8 & 255;
        buffer[index2++] = size >> 16 & 255;
        buffer[index2++] = size >> 24 & 255;
      }
      data.copy(buffer, index2, 0, value.position);
      index2 = index2 + value.position;
      return index2;
    };
    var serializeSymbol = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_SYMBOL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var size = buffer.write(value.value, index2 + 4, "utf8") + 1;
      buffer[index2] = size & 255;
      buffer[index2 + 1] = size >> 8 & 255;
      buffer[index2 + 2] = size >> 16 & 255;
      buffer[index2 + 3] = size >> 24 & 255;
      index2 = index2 + 4 + size - 1;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeDBRef = function(buffer, key, value, index2, depth, serializeFunctions, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var startIndex = index2;
      var endIndex;
      if (value.db != null) {
        endIndex = serializeInto(buffer, {
          $ref: value.namespace,
          $id: value.oid,
          $db: value.db
        }, false, index2, depth + 1, serializeFunctions);
      } else {
        endIndex = serializeInto(buffer, {
          $ref: value.namespace,
          $id: value.oid
        }, false, index2, depth + 1, serializeFunctions);
      }
      var size = endIndex - startIndex;
      buffer[startIndex++] = size & 255;
      buffer[startIndex++] = size >> 8 & 255;
      buffer[startIndex++] = size >> 16 & 255;
      buffer[startIndex++] = size >> 24 & 255;
      return endIndex;
    };
    var serializeInto = function serializeInto2(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
      startingIndex = startingIndex || 0;
      path = path || [];
      path.push(object);
      var index2 = startingIndex + 4;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          var key = "" + i;
          var value = object[i];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          var type = typeof value;
          if (type === "string") {
            index2 = serializeString(buffer, key, value, index2, true);
          } else if (type === "number") {
            index2 = serializeNumber(buffer, key, value, index2, true);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer, key, value, index2, true);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer, key, value, index2, true);
          } else if (value === void 0) {
            index2 = serializeNull(buffer, key, value, index2, true);
          } else if (value === null) {
            index2 = serializeNull(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer, key, value, index2, true);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer, key, value, index2, true);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer, key, value, index2, true);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer, key, value, index2, true);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer, key, value, index2, checkKeys, depth, serializeFunctions, true);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer, key, value, index2, depth, serializeFunctions, true);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer, key, value, index2, true);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else if (object instanceof Map2) {
        var iterator = object.entries();
        var done = false;
        while (!done) {
          var entry = iterator.next();
          done = entry.done;
          if (done)
            continue;
          key = entry.value[0];
          value = entry.value[1];
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index2 = serializeString(buffer, key, value, index2);
          } else if (type === "number") {
            index2 = serializeNumber(buffer, key, value, index2);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer, key, value, index2);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer, key, value, index2);
          } else if (value === null || value === void 0 && ignoreUndefined === false) {
            index2 = serializeNull(buffer, key, value, index2);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer, key, value, index2);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer, key, value, index2);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer, key, value, index2);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer, key, value, index2, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer, key, value, index2);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer, key, value, index2, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer, key, value, index2);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer, key, value, index2);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else {
        if (object.toBSON) {
          if (typeof object.toBSON !== "function")
            throw new Error("toBSON is not a function");
          object = object.toBSON();
          if (object != null && typeof object !== "object")
            throw new Error("toBSON function did not return an object");
        }
        for (key in object) {
          value = object[key];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index2 = serializeString(buffer, key, value, index2);
          } else if (type === "number") {
            index2 = serializeNumber(buffer, key, value, index2);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer, key, value, index2);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer, key, value, index2);
          } else if (value === void 0) {
            if (ignoreUndefined === false)
              index2 = serializeNull(buffer, key, value, index2);
          } else if (value === null) {
            index2 = serializeNull(buffer, key, value, index2);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer, key, value, index2);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer, key, value, index2);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer, key, value, index2);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer, key, value, index2, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer, key, value, index2);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer, key, value, index2, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer, key, value, index2);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer, key, value, index2);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      }
      path.pop();
      buffer[index2++] = 0;
      var size = index2 - startingIndex;
      buffer[startingIndex++] = size & 255;
      buffer[startingIndex++] = size >> 8 & 255;
      buffer[startingIndex++] = size >> 16 & 255;
      buffer[startingIndex++] = size >> 24 & 255;
      return index2;
    };
    var BSON2 = {};
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_UNDEFINED = 6;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_DECIMAL128 = 19;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = serializeInto;
  }
});

// node_modules/bson/lib/bson/parser/calculate_size.js
var require_calculate_size = __commonJS({
  "node_modules/bson/lib/bson/parser/calculate_size.js"(exports2, module2) {
    "use strict";
    var Long2 = require_long().Long;
    var Double2 = require_double().Double;
    var Timestamp2 = require_timestamp().Timestamp;
    var ObjectID2 = require_objectid().ObjectID;
    var Symbol2 = require_symbol().Symbol;
    var BSONRegExp2 = require_regexp().BSONRegExp;
    var Code2 = require_code().Code;
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key().MinKey;
    var MaxKey2 = require_max_key().MaxKey;
    var DBRef2 = require_db_ref().DBRef;
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils().normalizedFunctionString;
    var isDate = function isDate2(d) {
      return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
    };
    var calculateObjectSize = function calculateObjectSize2(object, serializeFunctions, ignoreUndefined) {
      var totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (object.toBSON) {
          object = object.toBSON();
        }
        for (var key in object) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    };
    function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
      if (value && value.toBSON) {
        value = value.toBSON();
      }
      switch (typeof value) {
        case "string":
          return 1 + Buffer.byteLength(name, "utf8") + 1 + 4 + Buffer.byteLength(value, "utf8") + 1;
        case "number":
          if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
            if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (4 + 1);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
            }
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray || !ignoreUndefined)
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 1);
        case "object":
          if (value == null || value instanceof MinKey2 || value instanceof MaxKey2 || value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          } else if (value instanceof ObjectID2 || value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || isDate(value)) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(value)) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 4 + 1) + value.length;
          } else if (value instanceof Long2 || value instanceof Double2 || value instanceof Timestamp2 || value["_bsontype"] === "Long" || value["_bsontype"] === "Double" || value["_bsontype"] === "Timestamp") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (value instanceof Decimal1282 || value["_bsontype"] === "Decimal128") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (16 + 1);
          } else if (value instanceof Code2 || value["_bsontype"] === "Code") {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1;
            }
          } else if (value instanceof Binary2 || value["_bsontype"] === "Binary") {
            if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1 + 4);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1);
            }
          } else if (value instanceof Symbol2 || value["_bsontype"] === "Symbol") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + Buffer.byteLength(value.value, "utf8") + 4 + 1 + 1;
          } else if (value instanceof DBRef2 || value["_bsontype"] === "DBRef") {
            var ordered_values = {
              $ref: value.namespace,
              $id: value.oid
            };
            if (value.db != null) {
              ordered_values["$db"] = value.db;
            }
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value instanceof BSONRegExp2 || value["_bsontype"] === "BSONRegExp") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.pattern, "utf8") + 1 + Buffer.byteLength(value.options, "utf8") + 1;
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]" || String.call(value) === "[object RegExp]") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else {
            if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else if (serializeFunctions) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1;
            }
          }
      }
      return 0;
    }
    var BSON2 = {};
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = calculateObjectSize;
  }
});

// node_modules/bson/lib/bson/bson.js
var require_bson = __commonJS({
  "node_modules/bson/lib/bson/bson.js"(exports2, module2) {
    "use strict";
    var Map2 = require_map();
    var Long2 = require_long();
    var Double2 = require_double();
    var Timestamp2 = require_timestamp();
    var ObjectID2 = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Int322 = require_int_32();
    var Code2 = require_code();
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key();
    var MaxKey2 = require_max_key();
    var DBRef2 = require_db_ref();
    var Binary2 = require_binary();
    var deserialize2 = require_deserializer();
    var serializer = require_serializer();
    var calculateObjectSize = require_calculate_size();
    var utils2 = require_utils();
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = utils2.allocBuffer(MAXSIZE);
    var BSON2 = function() {
    };
    BSON2.prototype.serialize = function serialize(object, options2) {
      options2 = options2 || {};
      var checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      var minInternalBufferSize = typeof options2.minInternalBufferSize === "number" ? options2.minInternalBufferSize : MAXSIZE;
      if (buffer.length < minInternalBufferSize) {
        buffer = utils2.allocBuffer(minInternalBufferSize);
      }
      var serializationIndex = serializer(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
      var finishedBuffer = utils2.allocBuffer(serializationIndex);
      buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
      return finishedBuffer;
    };
    BSON2.prototype.serializeWithBufferAndIndex = function(object, finalBuffer, options2) {
      options2 = options2 || {};
      var checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      var startIndex = typeof options2.index === "number" ? options2.index : 0;
      var serializationIndex = serializer(finalBuffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
      return serializationIndex - 1;
    };
    BSON2.prototype.deserialize = function(buffer2, options2) {
      return deserialize2(buffer2, options2);
    };
    BSON2.prototype.calculateObjectSize = function(object, options2) {
      options2 = options2 || {};
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
    };
    BSON2.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options2) {
      options2 = options2 != null ? options2 : {};
      var index2 = startIndex;
      for (var i = 0; i < numberOfDocuments; i++) {
        var size = data[index2] | data[index2 + 1] << 8 | data[index2 + 2] << 16 | data[index2 + 3] << 24;
        options2["index"] = index2;
        documents[docStartIndex + i] = this.deserialize(data, options2);
        index2 = index2 + size;
      }
      return index2;
    };
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    module2.exports = BSON2;
    module2.exports.Code = Code2;
    module2.exports.Map = Map2;
    module2.exports.Symbol = Symbol2;
    module2.exports.BSON = BSON2;
    module2.exports.DBRef = DBRef2;
    module2.exports.Binary = Binary2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.Long = Long2;
    module2.exports.Timestamp = Timestamp2;
    module2.exports.Double = Double2;
    module2.exports.Int32 = Int322;
    module2.exports.MinKey = MinKey2;
    module2.exports.MaxKey = MaxKey2;
    module2.exports.BSONRegExp = BSONRegExp2;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/index.js
var require_bson2 = __commonJS({
  "node_modules/bson/index.js"(exports2, module2) {
    var BSON2 = require_bson();
    var Binary2 = require_binary();
    var Code2 = require_code();
    var DBRef2 = require_db_ref();
    var Decimal1282 = require_decimal128();
    var Double2 = require_double();
    var Int322 = require_int_32();
    var Long2 = require_long();
    var Map2 = require_map();
    var MaxKey2 = require_max_key();
    var MinKey2 = require_min_key();
    var ObjectId = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Timestamp2 = require_timestamp();
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.Binary = Binary2;
    BSON2.Code = Code2;
    BSON2.DBRef = DBRef2;
    BSON2.Decimal128 = Decimal1282;
    BSON2.Double = Double2;
    BSON2.Int32 = Int322;
    BSON2.Long = Long2;
    BSON2.Map = Map2;
    BSON2.MaxKey = MaxKey2;
    BSON2.MinKey = MinKey2;
    BSON2.ObjectId = ObjectId;
    BSON2.ObjectID = ObjectId;
    BSON2.BSONRegExp = BSONRegExp2;
    BSON2.Symbol = Symbol2;
    BSON2.Timestamp = Timestamp2;
    module2.exports = BSON2;
  }
});

// node_modules/optional-require/index.js
var require_optional_require = __commonJS({
  "node_modules/optional-require/index.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    function findModuleNotFound(err, name) {
      const msg = err.message.split("\n")[0];
      return msg && (msg.includes(`'${name}'`) || msg.includes(` ${name} `) || msg.includes(` ${name}. `) || msg.includes(` ${name}, `));
    }
    function _optionalRequire(callerRequire, resolve2, path, message) {
      let opts;
      if (typeof message === "object") {
        opts = message;
        assert(!(opts.hasOwnProperty("notFound") && opts.hasOwnProperty("default")), "optionalRequire: options set with both `notFound` and `default`");
      } else {
        opts = {message};
      }
      try {
        return resolve2 ? callerRequire.resolve(path) : callerRequire(path);
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" || !findModuleNotFound(e, path)) {
          if (typeof opts.fail === "function") {
            return opts.fail(e);
          }
          throw e;
        }
        if (opts.message) {
          const message2 = typeof opts.message === "string" ? `${opts.message} - ` : "";
          const r = resolve2 ? "resolved" : "found";
          optionalRequire.log(`${message2}optional module not ${r}`, path);
        }
        if (typeof opts.notFound === "function") {
          return opts.notFound(e);
        }
        return opts.default;
      }
    }
    var tryRequire = (callerRequire, path, message) => _optionalRequire(callerRequire, false, path, message);
    var tryResolve = (callerRequire, path, message) => _optionalRequire(callerRequire, true, path, message);
    function optionalRequire(callerRequire) {
      const x = (path, message) => tryRequire(callerRequire, path, message);
      x.resolve = (path, message) => tryResolve(callerRequire, path, message);
      return x;
    }
    optionalRequire.try = tryRequire;
    optionalRequire.tryResolve = tryResolve;
    optionalRequire.resolve = tryResolve;
    optionalRequire.log = (message, path) => console.log(`Just FYI: ${message}; Path "${path}"`);
    module2.exports = optionalRequire;
  }
});

// node_modules/mongodb/package.json
var require_package = __commonJS({
  "node_modules/mongodb/package.json"(exports2, module2) {
    module2.exports = {
      _args: [
        [
          "mongodb@3.6.9",
          "/Users/tarasgordienko/Documents/sveltekit/github-deploy-to-netlify-db/db-test"
        ]
      ],
      _from: "mongodb@3.6.9",
      _id: "mongodb@3.6.9",
      _inBundle: false,
      _integrity: "sha512-1nSCKgSunzn/CXwgOWgbPHUWOO5OfERcuOWISmqd610jn0s8BU9K4879iJVabqgpPPbA6hO7rG48eq+fGED3Mg==",
      _location: "/mongodb",
      _phantomChildren: {},
      _requested: {
        type: "version",
        registry: true,
        raw: "mongodb@3.6.9",
        name: "mongodb",
        escapedName: "mongodb",
        rawSpec: "3.6.9",
        saveSpec: null,
        fetchSpec: "3.6.9"
      },
      _requiredBy: [
        "/"
      ],
      _resolved: "https://registry.npmjs.org/mongodb/-/mongodb-3.6.9.tgz",
      _spec: "3.6.9",
      _where: "/Users/tarasgordienko/Documents/sveltekit/github-deploy-to-netlify-db/db-test",
      bugs: {
        url: "https://github.com/mongodb/node-mongodb-native/issues"
      },
      dependencies: {
        bl: "^2.2.1",
        bson: "^1.1.4",
        denque: "^1.4.1",
        "optional-require": "^1.0.3",
        "safe-buffer": "^5.1.2",
        saslprep: "^1.0.0"
      },
      description: "The official MongoDB driver for Node.js",
      devDependencies: {
        "@types/chai": "^4.2.16",
        "@types/mocha": "^8.2.2",
        "@types/node": "^14.14.37",
        "array-includes": "^3.1.3",
        chai: "^4.1.1",
        "chai-subset": "^1.6.0",
        chalk: "^2.4.2",
        co: "4.6.0",
        eslint: "^7.10.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-es": "^3.0.1",
        "eslint-plugin-prettier": "^3.1.3",
        jsdoc: "^3.5.5",
        "lodash.camelcase": "^4.3.0",
        mocha: "5.2.0",
        "mocha-sinon": "^2.1.0",
        "mongodb-extjson": "^2.1.1",
        "mongodb-mock-server": "^1.0.1",
        nyc: "^15.1.0",
        "object.entries": "^1.1.3",
        prettier: "^1.19.1",
        semver: "^5.5.0",
        sinon: "^4.3.0",
        "sinon-chai": "^3.2.0",
        snappy: "^6.3.4",
        "spec-xunit-file": "0.0.1-3",
        "standard-version": "^9.2.0",
        tslib: "^2.2.0",
        typescript: "^4.2.4",
        "util.promisify": "^1.0.1",
        "worker-farm": "^1.5.0",
        wtfnode: "^0.8.0",
        yargs: "^14.2.0"
      },
      engines: {
        node: ">=4"
      },
      files: [
        "index.js",
        "lib"
      ],
      homepage: "https://github.com/mongodb/node-mongodb-native",
      keywords: [
        "mongodb",
        "driver",
        "official"
      ],
      license: "Apache-2.0",
      main: "index.js",
      name: "mongodb",
      optionalDependencies: {
        saslprep: "^1.0.0"
      },
      peerDependenciesMeta: {
        kerberos: {
          optional: true
        },
        "mongodb-client-encryption": {
          optional: true
        },
        "mongodb-extjson": {
          optional: true
        },
        snappy: {
          optional: true
        },
        "bson-ext": {
          optional: true
        },
        aws4: {
          optional: true
        }
      },
      repository: {
        type: "git",
        url: "git+ssh://git@github.com/mongodb/node-mongodb-native.git"
      },
      scripts: {
        "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
        "build:unified": "tsc -p test/functional/unified-spec-runner/tsconfig.unified.json",
        "check:atlas": "mocha --opts '{}' ./test/manual/atlas_connectivity.test.js",
        "check:bench": "node test/benchmarks/driverBench/",
        "check:coverage": "nyc npm run check:test",
        "check:kerberos": "mocha --opts '{}' -t 60000 test/manual/kerberos.test.js",
        "check:ldap": "mocha --opts '{}' test/manual/ldap.test.js",
        "check:lint": "eslint -v && eslint lib test",
        "check:test": "mocha --recursive test/functional test/unit",
        "check:tls": "mocha --opts '{}' test/manual/tls_support.test.js",
        format: "npm run check:lint -- --fix",
        release: "standard-version -i HISTORY.md",
        test: "npm run lint && mocha --recursive test/functional test/unit"
      },
      version: "3.6.9"
    };
  }
});

// node_modules/mongodb/lib/core/utils.js
var require_utils2 = __commonJS({
  "node_modules/mongodb/lib/core/utils.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var crypto = require("crypto");
    var requireOptional = require_optional_require()(require);
    var uuidV4 = () => {
      const result = crypto.randomBytes(16);
      result[6] = result[6] & 15 | 64;
      result[8] = result[8] & 63 | 128;
      return result;
    };
    function relayEvents(listener, emitter, events) {
      events.forEach((eventName) => listener.on(eventName, (event) => emitter.emit(eventName, event)));
    }
    function retrieveKerberos() {
      let kerberos;
      try {
        kerberos = requireOptional("kerberos");
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          throw new Error("The `kerberos` module was not found. Please install it and try again.");
        }
        throw err;
      }
      return kerberos;
    }
    var noEJSONError = function() {
      throw new Error("The `mongodb-extjson` module was not found. Please install it and try again.");
    };
    function retrieveEJSON() {
      let EJSON = requireOptional("mongodb-extjson");
      if (!EJSON) {
        EJSON = {
          parse: noEJSONError,
          deserialize: noEJSONError,
          serialize: noEJSONError,
          stringify: noEJSONError,
          setBSONModule: noEJSONError,
          BSON: noEJSONError
        };
      }
      return EJSON;
    }
    function maxWireVersion(topologyOrServer) {
      if (topologyOrServer) {
        if (topologyOrServer.ismaster) {
          return topologyOrServer.ismaster.maxWireVersion;
        }
        if (typeof topologyOrServer.lastIsMaster === "function") {
          const lastIsMaster = topologyOrServer.lastIsMaster();
          if (lastIsMaster) {
            return lastIsMaster.maxWireVersion;
          }
        }
        if (topologyOrServer.description) {
          return topologyOrServer.description.maxWireVersion;
        }
      }
      return 0;
    }
    function collationNotSupported(server, cmd) {
      return cmd && cmd.collation && maxWireVersion(server) < 5;
    }
    function isPromiseLike(maybePromise) {
      return maybePromise && typeof maybePromise.then === "function";
    }
    function eachAsync(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = 0;
      for (idx = 0; idx < arr.length; ++idx) {
        awaiting++;
        eachFn(arr[idx], eachCallback);
      }
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
        }
      }
    }
    function eachAsyncSeries(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = arr.length;
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        idx++;
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
          return;
        }
        eachFn(arr[idx], eachCallback);
      }
      eachFn(arr[idx], eachCallback);
    }
    function isUnifiedTopology(topology) {
      return topology.description != null;
    }
    function arrayStrictEqual(arr, arr2) {
      if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
      }
      return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
    }
    function tagsStrictEqual(tags, tags2) {
      const tagsKeys = Object.keys(tags);
      const tags2Keys = Object.keys(tags2);
      return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
    }
    function errorStrictEqual(lhs, rhs) {
      if (lhs === rhs) {
        return true;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
      }
      if (lhs.message !== rhs.message) {
        return false;
      }
      return true;
    }
    function makeStateMachine(stateTable) {
      return function stateTransition(target, newState) {
        const legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
          throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
        }
        target.emit("stateChanged", target.s.state, newState);
        target.s.state = newState;
      };
    }
    function makeClientMetadata(options2) {
      options2 = options2 || {};
      const metadata = {
        driver: {
          name: "nodejs",
          version: require_package().version
        },
        os: {
          type: os.type(),
          name: process.platform,
          architecture: process.arch,
          version: os.release()
        },
        platform: `'Node.js ${process.version}, ${os.endianness} (${options2.useUnifiedTopology ? "unified" : "legacy"})`
      };
      if (options2.driverInfo) {
        if (options2.driverInfo.name) {
          metadata.driver.name = `${metadata.driver.name}|${options2.driverInfo.name}`;
        }
        if (options2.driverInfo.version) {
          metadata.version = `${metadata.driver.version}|${options2.driverInfo.version}`;
        }
        if (options2.driverInfo.platform) {
          metadata.platform = `${metadata.platform}|${options2.driverInfo.platform}`;
        }
      }
      if (options2.appname) {
        const buffer = Buffer.from(options2.appname);
        metadata.application = {
          name: buffer.length > 128 ? buffer.slice(0, 128).toString("utf8") : options2.appname
        };
      }
      return metadata;
    }
    var noop3 = () => {
    };
    module2.exports = {
      uuidV4,
      relayEvents,
      collationNotSupported,
      retrieveEJSON,
      retrieveKerberos,
      maxWireVersion,
      isPromiseLike,
      eachAsync,
      eachAsyncSeries,
      isUnifiedTopology,
      arrayStrictEqual,
      tagsStrictEqual,
      errorStrictEqual,
      makeStateMachine,
      makeClientMetadata,
      noop: noop3
    };
  }
});

// node_modules/mongodb/lib/core/error.js
var require_error = __commonJS({
  "node_modules/mongodb/lib/core/error.js"(exports2, module2) {
    "use strict";
    var kErrorLabels = Symbol("errorLabels");
    var MongoError = class extends Error {
      constructor(message) {
        if (message instanceof Error) {
          super(message.message);
          this.stack = message.stack;
        } else {
          if (typeof message === "string") {
            super(message);
          } else {
            super(message.message || message.errmsg || message.$err || "n/a");
            if (message.errorLabels) {
              this[kErrorLabels] = new Set(message.errorLabels);
            }
            for (var name in message) {
              if (name === "errorLabels" || name === "errmsg") {
                continue;
              }
              this[name] = message[name];
            }
          }
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "MongoError";
      }
      get errmsg() {
        return this.message;
      }
      static create(options2) {
        return new MongoError(options2);
      }
      hasErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          return false;
        }
        return this[kErrorLabels].has(label);
      }
      addErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          this[kErrorLabels] = new Set();
        }
        this[kErrorLabels].add(label);
      }
      get errorLabels() {
        return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];
      }
    };
    var kBeforeHandshake = Symbol("beforeHandshake");
    function isNetworkErrorBeforeHandshake(err) {
      return err[kBeforeHandshake] === true;
    }
    var MongoNetworkError = class extends MongoError {
      constructor(message, options2) {
        super(message);
        this.name = "MongoNetworkError";
        if (options2 && typeof options2.beforeHandshake === "boolean") {
          this[kBeforeHandshake] = options2.beforeHandshake;
        }
      }
    };
    var MongoNetworkTimeoutError = class extends MongoNetworkError {
      constructor(message, options2) {
        super(message, options2);
        this.name = "MongoNetworkTimeoutError";
      }
    };
    var MongoParseError = class extends MongoError {
      constructor(message) {
        super(message);
        this.name = "MongoParseError";
      }
    };
    var MongoTimeoutError = class extends MongoError {
      constructor(message, reason) {
        if (reason && reason.error) {
          super(reason.error.message || reason.error);
        } else {
          super(message);
        }
        this.name = "MongoTimeoutError";
        if (reason) {
          this.reason = reason;
        }
      }
    };
    var MongoServerSelectionError = class extends MongoTimeoutError {
      constructor(message, reason) {
        super(message, reason);
        this.name = "MongoServerSelectionError";
      }
    };
    function makeWriteConcernResultObject(input) {
      const output = Object.assign({}, input);
      if (output.ok === 0) {
        output.ok = 1;
        delete output.errmsg;
        delete output.code;
        delete output.codeName;
      }
      return output;
    }
    var MongoWriteConcernError = class extends MongoError {
      constructor(message, result) {
        super(message);
        this.name = "MongoWriteConcernError";
        if (result && Array.isArray(result.errorLabels)) {
          this[kErrorLabels] = new Set(result.errorLabels);
        }
        if (result != null) {
          this.result = makeWriteConcernResultObject(result);
        }
      }
    };
    var RETRYABLE_ERROR_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436
    ]);
    var RETRYABLE_WRITE_ERROR_CODES = new Set([
      11600,
      11602,
      10107,
      13435,
      13436,
      189,
      91,
      7,
      6,
      89,
      9001,
      262
    ]);
    function isRetryableWriteError(error3) {
      if (error3 instanceof MongoWriteConcernError) {
        return RETRYABLE_WRITE_ERROR_CODES.has(error3.code) || RETRYABLE_WRITE_ERROR_CODES.has(error3.result.code);
      }
      return RETRYABLE_WRITE_ERROR_CODES.has(error3.code);
    }
    function isRetryableError(error3) {
      return RETRYABLE_ERROR_CODES.has(error3.code) || error3 instanceof MongoNetworkError || error3.message.match(/not master/) || error3.message.match(/node is recovering/);
    }
    var SDAM_RECOVERING_CODES = new Set([
      91,
      189,
      11600,
      11602,
      13436
    ]);
    var SDAM_NOTMASTER_CODES = new Set([
      10107,
      13435
    ]);
    var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
      11600,
      91
    ]);
    function isRecoveringError(err) {
      if (err.code && SDAM_RECOVERING_CODES.has(err.code)) {
        return true;
      }
      return err.message.match(/not master or secondary/) || err.message.match(/node is recovering/);
    }
    function isNotMasterError(err) {
      if (err.code && SDAM_NOTMASTER_CODES.has(err.code)) {
        return true;
      }
      if (isRecoveringError(err)) {
        return false;
      }
      return err.message.match(/not master/);
    }
    function isNodeShuttingDownError(err) {
      return err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code);
    }
    function isSDAMUnrecoverableError(error3) {
      if (error3 instanceof MongoParseError || error3 == null) {
        return true;
      }
      if (isRecoveringError(error3) || isNotMasterError(error3)) {
        return true;
      }
      return false;
    }
    module2.exports = {
      MongoError,
      MongoNetworkError,
      MongoNetworkTimeoutError,
      MongoParseError,
      MongoTimeoutError,
      MongoServerSelectionError,
      MongoWriteConcernError,
      isRetryableError,
      isSDAMUnrecoverableError,
      isNodeShuttingDownError,
      isRetryableWriteError,
      isNetworkErrorBeforeHandshake
    };
  }
});

// node_modules/mongodb/lib/core/connection/utils.js
var require_utils3 = __commonJS({
  "node_modules/mongodb/lib/core/connection/utils.js"(exports2, module2) {
    "use strict";
    var require_optional = require_optional_require()(require);
    function debugOptions(debugFields, options2) {
      const finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options2[n];
      });
      return finaloptions;
    }
    function retrieveBSON() {
      const BSON2 = require_bson2();
      BSON2.native = false;
      const optionalBSON = require_optional("bson-ext");
      if (optionalBSON) {
        optionalBSON.native = true;
        return optionalBSON;
      }
      return BSON2;
    }
    function noSnappyWarning() {
      throw new Error("Attempted to use Snappy compression, but Snappy is not installed. Install or disable Snappy compression and try again.");
    }
    function retrieveSnappy() {
      let snappy = require_optional("snappy");
      if (!snappy) {
        snappy = {
          compress: noSnappyWarning,
          uncompress: noSnappyWarning,
          compressSync: noSnappyWarning,
          uncompressSync: noSnappyWarning
        };
      }
      return snappy;
    }
    module2.exports = {
      debugOptions,
      retrieveBSON,
      retrieveSnappy
    };
  }
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS({
  "node_modules/mongodb/lib/write_concern.js"(exports2, module2) {
    "use strict";
    var kWriteConcernKeys = new Set(["w", "wtimeout", "j", "journal", "fsync"]);
    var utils2;
    var WriteConcern = class {
      constructor(w, wtimeout, j, fsync) {
        if (w != null) {
          this.w = w;
        }
        if (wtimeout != null) {
          this.wtimeout = wtimeout;
        }
        if (j != null) {
          this.j = j;
        }
        if (fsync != null) {
          this.fsync = fsync;
        }
      }
      static fromOptions(options2) {
        if (options2 == null || options2.writeConcern == null && options2.w == null && options2.wtimeout == null && options2.j == null && options2.journal == null && options2.fsync == null) {
          return;
        }
        if (options2.writeConcern) {
          if (typeof options2.writeConcern === "string") {
            return new WriteConcern(options2.writeConcern);
          }
          if (!Object.keys(options2.writeConcern).some((key) => kWriteConcernKeys.has(key))) {
            return;
          }
          return new WriteConcern(options2.writeConcern.w, options2.writeConcern.wtimeout, options2.writeConcern.j || options2.writeConcern.journal, options2.writeConcern.fsync);
        }
        if (!utils2)
          utils2 = require_utils4();
        utils2.emitWarningOnce(`Top-level use of w, wtimeout, j, and fsync is deprecated. Use writeConcern instead.`);
        return new WriteConcern(options2.w, options2.wtimeout, options2.j || options2.journal, options2.fsync);
      }
    };
    module2.exports = WriteConcern;
  }
});

// node_modules/mongodb/lib/async/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/mongodb/lib/async/async_iterator.js"(exports2) {
    "use strict";
    function asyncIterator() {
      const cursor = this;
      return {
        next: function() {
          return Promise.resolve().then(() => cursor.next()).then((value) => {
            if (!value) {
              return cursor.close().then(() => ({value, done: true}));
            }
            return {value, done: false};
          });
        }
      };
    }
    exports2.asyncIterator = asyncIterator;
  }
});

// node_modules/mongodb/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/mongodb/lib/utils.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var WriteConcern = require_write_concern();
    var shallowClone = function(obj) {
      var copy = {};
      for (var name in obj)
        copy[name] = obj[name];
      return copy;
    };
    var getSingleProperty = function(obj, name, value) {
      Object.defineProperty(obj, name, {
        enumerable: true,
        get: function() {
          return value;
        }
      });
    };
    var formatSortValue = exports2.formatSortValue = function(sortDirection) {
      var value = ("" + sortDirection).toLowerCase();
      switch (value) {
        case "ascending":
        case "asc":
        case "1":
          return 1;
        case "descending":
        case "desc":
        case "-1":
          return -1;
        default:
          throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
    };
    var formattedOrderClause = exports2.formattedOrderClause = function(sortValue) {
      var orderBy = new Map();
      if (sortValue == null)
        return null;
      if (Array.isArray(sortValue)) {
        if (sortValue.length === 0) {
          return null;
        }
        for (var i = 0; i < sortValue.length; i++) {
          if (sortValue[i].constructor === String) {
            orderBy.set(`${sortValue[i]}`, 1);
          } else {
            orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));
          }
        }
      } else if (sortValue != null && typeof sortValue === "object") {
        if (sortValue instanceof Map) {
          orderBy = sortValue;
        } else {
          var sortKeys = Object.keys(sortValue);
          for (var k of sortKeys) {
            orderBy.set(k, sortValue[k]);
          }
        }
      } else if (typeof sortValue === "string") {
        orderBy.set(`${sortValue}`, 1);
      } else {
        throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
      return orderBy;
    };
    var checkCollectionName = function checkCollectionName2(collectionName) {
      if (typeof collectionName !== "string") {
        throw new MongoError("collection name must be a String");
      }
      if (!collectionName || collectionName.indexOf("..") !== -1) {
        throw new MongoError("collection names cannot be empty");
      }
      if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
        throw new MongoError("collection names must not contain '$'");
      }
      if (collectionName.match(/^\.|\.$/) != null) {
        throw new MongoError("collection names must not start or end with '.'");
      }
      if (collectionName.indexOf("\0") !== -1) {
        throw new MongoError("collection names cannot contain a null character");
      }
    };
    var handleCallback = function(callback, err, value1, value2) {
      try {
        if (callback == null)
          return;
        if (callback) {
          return value2 ? callback(err, value1, value2) : callback(err, value1);
        }
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
        return false;
      }
      return true;
    };
    var toError = function(error3) {
      if (error3 instanceof Error)
        return error3;
      var msg = error3.err || error3.errmsg || error3.errMessage || error3;
      var e = MongoError.create({message: msg, driver: true});
      var keys = typeof error3 === "object" ? Object.keys(error3) : [];
      for (var i = 0; i < keys.length; i++) {
        try {
          e[keys[i]] = error3[keys[i]];
        } catch (err) {
        }
      }
      return e;
    };
    var normalizeHintField = function normalizeHintField2(hint) {
      var finalHint = null;
      if (typeof hint === "string") {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach(function(param) {
          finalHint[param] = 1;
        });
      } else if (hint != null && typeof hint === "object") {
        finalHint = {};
        for (var name in hint) {
          finalHint[name] = hint[name];
        }
      }
      return finalHint;
    };
    var parseIndexOptions = function(fieldOrSpec) {
      var fieldHash = {};
      var indexes = [];
      var keys;
      if (typeof fieldOrSpec === "string") {
        indexes.push(fieldOrSpec + "_" + 1);
        fieldHash[fieldOrSpec] = 1;
      } else if (Array.isArray(fieldOrSpec)) {
        fieldOrSpec.forEach(function(f) {
          if (typeof f === "string") {
            indexes.push(f + "_" + 1);
            fieldHash[f] = 1;
          } else if (Array.isArray(f)) {
            indexes.push(f[0] + "_" + (f[1] || 1));
            fieldHash[f[0]] = f[1] || 1;
          } else if (isObject(f)) {
            keys = Object.keys(f);
            keys.forEach(function(k) {
              indexes.push(k + "_" + f[k]);
              fieldHash[k] = f[k];
            });
          } else {
          }
        });
      } else if (isObject(fieldOrSpec)) {
        keys = Object.keys(fieldOrSpec);
        keys.forEach(function(key) {
          indexes.push(key + "_" + fieldOrSpec[key]);
          fieldHash[key] = fieldOrSpec[key];
        });
      }
      return {
        name: indexes.join("_"),
        keys,
        fieldHash
      };
    };
    var isObject = exports2.isObject = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Object]";
    };
    var debugOptions = function(debugFields, options2) {
      var finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options2[n];
      });
      return finaloptions;
    };
    var decorateCommand = function(command, options2, exclude) {
      for (var name in options2) {
        if (exclude.indexOf(name) === -1)
          command[name] = options2[name];
      }
      return command;
    };
    var mergeOptions = function(target, source) {
      for (var name in source) {
        target[name] = source[name];
      }
      return target;
    };
    var translateOptions = function(target, source) {
      var translations = {
        sslCA: "ca",
        sslCRL: "crl",
        sslValidate: "rejectUnauthorized",
        sslKey: "key",
        sslCert: "cert",
        sslPass: "passphrase",
        socketTimeoutMS: "socketTimeout",
        connectTimeoutMS: "connectionTimeout",
        replicaSet: "setName",
        rs_name: "setName",
        secondaryAcceptableLatencyMS: "acceptableLatency",
        connectWithNoPrimary: "secondaryOnlyConnectionAllowed",
        acceptableLatencyMS: "localThresholdMS"
      };
      for (var name in source) {
        if (translations[name]) {
          target[translations[name]] = source[name];
        } else {
          target[name] = source[name];
        }
      }
      return target;
    };
    var filterOptions = function(options2, names) {
      var filterOptions2 = {};
      for (var name in options2) {
        if (names.indexOf(name) !== -1)
          filterOptions2[name] = options2[name];
      }
      return filterOptions2;
    };
    var WRITE_CONCERN_KEYS = ["w", "j", "wtimeout", "fsync", "writeConcern"];
    function conditionallyMergeWriteConcern(target, source) {
      let found = false;
      for (const wcKey of WRITE_CONCERN_KEYS) {
        if (wcKey in target) {
          found = true;
          break;
        }
      }
      if (!found) {
        for (const wcKey of WRITE_CONCERN_KEYS) {
          if (source[wcKey]) {
            if (!("writeConcern" in target)) {
              target.writeConcern = {};
            }
            target.writeConcern[wcKey] = source[wcKey];
          }
        }
      }
      return target;
    }
    var executeLegacyOperation = (topology, operation, args, options2) => {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!Array.isArray(args)) {
        throw new TypeError("This method requires an array of arguments to apply");
      }
      options2 = options2 || {};
      const Promise2 = topology.s.promiseLibrary;
      let callback = args[args.length - 1];
      let session, opOptions, owner;
      if (!options2.skipSessions && topology.hasSessionSupport()) {
        opOptions = args[args.length - 2];
        if (opOptions == null || opOptions.session == null) {
          owner = Symbol();
          session = topology.startSession({owner});
          const optionsIndex = args.length - 2;
          args[optionsIndex] = Object.assign({}, args[optionsIndex], {session});
        } else if (opOptions.session && opOptions.session.hasEnded) {
          throw new MongoError("Use of expired sessions is not permitted");
        }
      }
      const makeExecuteCallback = (resolve2, reject) => function executeCallback(err, result) {
        if (session && session.owner === owner && !options2.returnsCursor) {
          session.endSession(() => {
            delete opOptions.session;
            if (err)
              return reject(err);
            resolve2(result);
          });
        } else {
          if (err)
            return reject(err);
          resolve2(result);
        }
      };
      if (typeof callback === "function") {
        callback = args.pop();
        const handler2 = makeExecuteCallback((result) => callback(null, result), (err) => callback(err, null));
        args.push(handler2);
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler2(e);
          throw e;
        }
      }
      if (args[args.length - 1] != null) {
        throw new TypeError("final argument to `executeLegacyOperation` must be a callback");
      }
      return new Promise2(function(resolve2, reject) {
        const handler2 = makeExecuteCallback(resolve2, reject);
        args[args.length - 1] = handler2;
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler2(e);
        }
      });
    };
    function applyRetryableWrites(target, db) {
      if (db && db.s.options.retryWrites) {
        target.retryWrites = true;
      }
      return target;
    }
    function applyWriteConcern(target, sources, options2) {
      options2 = options2 || {};
      const db = sources.db;
      const coll = sources.collection;
      if (options2.session && options2.session.inTransaction()) {
        if (target.writeConcern) {
          delete target.writeConcern;
        }
        return target;
      }
      const writeConcern = WriteConcern.fromOptions(options2);
      if (writeConcern) {
        return Object.assign(target, {writeConcern});
      }
      if (coll && coll.writeConcern) {
        return Object.assign(target, {writeConcern: Object.assign({}, coll.writeConcern)});
      }
      if (db && db.writeConcern) {
        return Object.assign(target, {writeConcern: Object.assign({}, db.writeConcern)});
      }
      return target;
    }
    function isPromiseLike(maybePromise2) {
      return maybePromise2 && typeof maybePromise2.then === "function";
    }
    function decorateWithCollation(command, target, options2) {
      const topology = target.s && target.s.topology || target.topology;
      if (!topology) {
        throw new TypeError('parameter "target" is missing a topology');
      }
      const capabilities = topology.capabilities();
      if (options2.collation && typeof options2.collation === "object") {
        if (capabilities && capabilities.commandsTakeCollation) {
          command.collation = options2.collation;
        } else {
          throw new MongoError(`Current topology does not support collation`);
        }
      }
    }
    function decorateWithReadConcern(command, coll, options2) {
      if (options2 && options2.session && options2.session.inTransaction()) {
        return;
      }
      let readConcern = Object.assign({}, command.readConcern || {});
      if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
      }
      if (Object.keys(readConcern).length > 0) {
        Object.assign(command, {readConcern});
      }
    }
    function decorateWithExplain(command, explain) {
      if (command.explain) {
        return command;
      }
      return {explain: command, verbosity: explain.verbosity};
    }
    var nodejsMajorVersion = +process.version.split(".")[0].substring(1);
    var emitProcessWarning = (msg) => nodejsMajorVersion <= 6 ? process.emitWarning(msg, "DeprecationWarning", MONGODB_WARNING_CODE) : process.emitWarning(msg, {type: "DeprecationWarning", code: MONGODB_WARNING_CODE});
    var emitConsoleWarning = (msg) => console.error(msg);
    var emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;
    function defaultMsgHandler(name, option) {
      return `${name} option [${option}] is deprecated and will be removed in a later version.`;
    }
    function deprecateOptions(config, fn) {
      if (process.noDeprecation === true) {
        return fn;
      }
      const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
      const optionsWarned = new Set();
      function deprecated() {
        const options2 = arguments[config.optionsIndex];
        if (!isObject(options2) || Object.keys(options2).length === 0) {
          return fn.apply(this, arguments);
        }
        config.deprecatedOptions.forEach((deprecatedOption) => {
          if (Object.prototype.hasOwnProperty.call(options2, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {
            optionsWarned.add(deprecatedOption);
            const msg = msgHandler(config.name, deprecatedOption);
            emitDeprecationWarning(msg);
            if (this && this.getLogger) {
              const logger = this.getLogger();
              if (logger) {
                logger.warn(msg);
              }
            }
          }
        });
        return fn.apply(this, arguments);
      }
      Object.setPrototypeOf(deprecated, fn);
      if (fn.prototype) {
        deprecated.prototype = fn.prototype;
      }
      return deprecated;
    }
    var SUPPORTS = {};
    try {
      require_async_iterator();
      SUPPORTS.ASYNC_ITERATOR = true;
    } catch (e) {
      SUPPORTS.ASYNC_ITERATOR = false;
    }
    var MongoDBNamespace = class {
      constructor(db, collection) {
        this.db = db;
        this.collection = collection;
      }
      toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
      }
      withCollection(collection) {
        return new MongoDBNamespace(this.db, collection);
      }
      static fromString(namespace) {
        if (!namespace) {
          throw new Error(`Cannot parse namespace from "${namespace}"`);
        }
        const index2 = namespace.indexOf(".");
        return new MongoDBNamespace(namespace.substring(0, index2), namespace.substring(index2 + 1));
      }
    };
    function* makeCounter(seed) {
      let count = seed || 0;
      while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
      }
    }
    function maybePromise(parent, callback, fn) {
      const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;
      let result;
      if (typeof callback !== "function") {
        result = new PromiseLibrary((resolve2, reject) => {
          callback = (err, res) => {
            if (err)
              return reject(err);
            resolve2(res);
          };
        });
      }
      fn(function(err, res) {
        if (err != null) {
          try {
            callback(err);
          } catch (error3) {
            return process.nextTick(() => {
              throw error3;
            });
          }
          return;
        }
        callback(err, res);
      });
      return result;
    }
    function now() {
      const hrtime = process.hrtime();
      return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
    }
    function calculateDurationInMs(started) {
      if (typeof started !== "number") {
        throw TypeError("numeric value required to calculate duration");
      }
      const elapsed = now() - started;
      return elapsed < 0 ? 0 : elapsed;
    }
    function makeInterruptableAsyncInterval(fn, options2) {
      let timerId;
      let lastCallTime;
      let lastWakeTime;
      let stopped = false;
      options2 = options2 || {};
      const interval = options2.interval || 1e3;
      const minInterval = options2.minInterval || 500;
      const immediate = typeof options2.immediate === "boolean" ? options2.immediate : false;
      const clock = typeof options2.clock === "function" ? options2.clock : now;
      function wake() {
        const currentTime = clock();
        const timeSinceLastWake = currentTime - lastWakeTime;
        const timeSinceLastCall = currentTime - lastCallTime;
        const timeUntilNextCall = interval - timeSinceLastCall;
        lastWakeTime = currentTime;
        if (timeSinceLastWake < minInterval) {
          return;
        }
        if (timeUntilNextCall > minInterval) {
          reschedule(minInterval);
        }
        if (timeUntilNextCall < 0) {
          executeAndReschedule();
        }
      }
      function stop() {
        stopped = true;
        if (timerId) {
          clearTimeout(timerId);
          timerId = null;
        }
        lastCallTime = 0;
        lastWakeTime = 0;
      }
      function reschedule(ms) {
        if (stopped)
          return;
        clearTimeout(timerId);
        timerId = setTimeout(executeAndReschedule, ms || interval);
      }
      function executeAndReschedule() {
        lastWakeTime = 0;
        lastCallTime = clock();
        fn((err) => {
          if (err)
            throw err;
          reschedule(interval);
        });
      }
      if (immediate) {
        executeAndReschedule();
      } else {
        lastCallTime = clock();
        reschedule();
      }
      return {wake, stop};
    }
    function hasAtomicOperators(doc) {
      if (Array.isArray(doc)) {
        return doc.reduce((err, u) => err || hasAtomicOperators(u), null);
      }
      return Object.keys(typeof doc.toBSON !== "function" ? doc : doc.toBSON()).map((k) => k[0]).indexOf("$") >= 0;
    }
    var MONGODB_WARNING_CODE = "MONGODB DRIVER";
    function emitWarning(message) {
      if (process.emitWarning) {
        return nodejsMajorVersion <= 6 ? process.emitWarning(message, void 0, MONGODB_WARNING_CODE) : process.emitWarning(message, {code: MONGODB_WARNING_CODE});
      } else {
        return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);
      }
    }
    var emittedWarnings = new Set();
    function emitWarningOnce(message) {
      if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
      }
    }
    module2.exports = {
      filterOptions,
      mergeOptions,
      translateOptions,
      shallowClone,
      getSingleProperty,
      checkCollectionName,
      toError,
      formattedOrderClause,
      parseIndexOptions,
      normalizeHintField,
      handleCallback,
      decorateCommand,
      isObject,
      debugOptions,
      MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,
      conditionallyMergeWriteConcern,
      executeLegacyOperation,
      applyRetryableWrites,
      applyWriteConcern,
      isPromiseLike,
      decorateWithCollation,
      decorateWithReadConcern,
      decorateWithExplain,
      deprecateOptions,
      SUPPORTS,
      MongoDBNamespace,
      emitDeprecationWarning,
      makeCounter,
      maybePromise,
      now,
      calculateDurationInMs,
      makeInterruptableAsyncInterval,
      hasAtomicOperators,
      MONGODB_WARNING_CODE,
      emitWarning,
      emitWarningOnce
    };
  }
});

// node_modules/mongodb/lib/core/topologies/read_preference.js
var require_read_preference = __commonJS({
  "node_modules/mongodb/lib/core/topologies/read_preference.js"(exports2, module2) {
    "use strict";
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var ReadPreference = function(mode, tags, options2) {
      if (!ReadPreference.isValid(mode)) {
        throw new TypeError(`Invalid read preference mode ${mode}`);
      }
      if (tags && !Array.isArray(tags)) {
        emitWarningOnce("ReadPreference tags must be an array, this will change in the next major version");
        const tagsHasMaxStalenessSeconds = typeof tags.maxStalenessSeconds !== "undefined";
        const tagsHasHedge = typeof tags.hedge !== "undefined";
        const tagsHasOptions = tagsHasMaxStalenessSeconds || tagsHasHedge;
        if (tagsHasOptions) {
          options2 = tags;
          tags = void 0;
        } else {
          tags = [tags];
        }
      }
      this.mode = mode;
      this.tags = tags;
      this.hedge = options2 && options2.hedge;
      options2 = options2 || {};
      if (options2.maxStalenessSeconds != null) {
        if (options2.maxStalenessSeconds <= 0) {
          throw new TypeError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options2.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new TypeError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new TypeError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new TypeError("Primary read preference cannot be combined with hedge");
        }
      }
    };
    Object.defineProperty(ReadPreference.prototype, "preference", {
      enumerable: true,
      get: function() {
        return this.mode;
      }
    });
    ReadPreference.PRIMARY = "primary";
    ReadPreference.PRIMARY_PREFERRED = "primaryPreferred";
    ReadPreference.SECONDARY = "secondary";
    ReadPreference.SECONDARY_PREFERRED = "secondaryPreferred";
    ReadPreference.NEAREST = "nearest";
    var VALID_MODES = [
      ReadPreference.PRIMARY,
      ReadPreference.PRIMARY_PREFERRED,
      ReadPreference.SECONDARY,
      ReadPreference.SECONDARY_PREFERRED,
      ReadPreference.NEAREST,
      null
    ];
    ReadPreference.fromOptions = function(options2) {
      if (!options2)
        return null;
      const readPreference = options2.readPreference;
      if (!readPreference)
        return null;
      const readPreferenceTags = options2.readPreferenceTags;
      const maxStalenessSeconds = options2.maxStalenessSeconds;
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags);
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds || maxStalenessSeconds,
            hedge: readPreference.hedge
          });
        }
      }
      return readPreference;
    };
    ReadPreference.resolve = function(parent, options2) {
      options2 = options2 || {};
      const session = options2.session;
      const inheritedReadPreference = parent && parent.readPreference;
      let readPreference;
      if (options2.readPreference) {
        readPreference = ReadPreference.fromOptions(options2);
      } else if (session && session.inTransaction() && session.transaction.options.readPreference) {
        readPreference = session.transaction.options.readPreference;
      } else if (inheritedReadPreference != null) {
        readPreference = inheritedReadPreference;
      } else {
        readPreference = ReadPreference.primary;
      }
      return typeof readPreference === "string" ? new ReadPreference(readPreference) : readPreference;
    };
    ReadPreference.translate = function(options2) {
      if (options2.readPreference == null)
        return options2;
      const r = options2.readPreference;
      if (typeof r === "string") {
        options2.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
        const mode = r.mode || r.preference;
        if (mode && typeof mode === "string") {
          options2.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new TypeError("Invalid read preference: " + r);
      }
      return options2;
    };
    ReadPreference.isValid = function(mode) {
      return VALID_MODES.indexOf(mode) !== -1;
    };
    ReadPreference.prototype.isValid = function(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    };
    var needSlaveOk = ["primaryPreferred", "secondary", "secondaryPreferred", "nearest"];
    ReadPreference.prototype.slaveOk = function() {
      return needSlaveOk.indexOf(this.mode) !== -1;
    };
    ReadPreference.prototype.equals = function(readPreference) {
      return readPreference.mode === this.mode;
    };
    ReadPreference.prototype.toJSON = function() {
      const readPreference = {mode: this.mode};
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    };
    ReadPreference.primary = new ReadPreference("primary");
    ReadPreference.primaryPreferred = new ReadPreference("primaryPreferred");
    ReadPreference.secondary = new ReadPreference("secondary");
    ReadPreference.secondaryPreferred = new ReadPreference("secondaryPreferred");
    ReadPreference.nearest = new ReadPreference("nearest");
    module2.exports = ReadPreference;
  }
});

// node_modules/mongodb/lib/core/sdam/common.js
var require_common = __commonJS({
  "node_modules/mongodb/lib/core/sdam/common.js"(exports2, module2) {
    "use strict";
    var STATE_CLOSING = "closing";
    var STATE_CLOSED = "closed";
    var STATE_CONNECTING = "connecting";
    var STATE_CONNECTED = "connected";
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    function serverType(server) {
      let description = server.s.description || server.s.serverDescription;
      if (description.topologyType === TopologyType.Single)
        return description.servers[0].type;
      return description.type;
    }
    var TOPOLOGY_DEFAULTS = {
      useUnifiedTopology: true,
      localThresholdMS: 15,
      serverSelectionTimeoutMS: 3e4,
      heartbeatFrequencyMS: 1e4,
      minHeartbeatFrequencyMS: 500
    };
    function drainTimerQueue(queue) {
      queue.forEach(clearTimeout);
      queue.clear();
    }
    function clearAndRemoveTimerFrom(timer, timers) {
      clearTimeout(timer);
      return timers.delete(timer);
    }
    module2.exports = {
      STATE_CLOSING,
      STATE_CLOSED,
      STATE_CONNECTING,
      STATE_CONNECTED,
      TOPOLOGY_DEFAULTS,
      TopologyType,
      ServerType,
      serverType,
      drainTimerQueue,
      clearAndRemoveTimerFrom
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server_description.js
var require_server_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_description.js"(exports2, module2) {
    "use strict";
    var arrayStrictEqual = require_utils2().arrayStrictEqual;
    var tagsStrictEqual = require_utils2().tagsStrictEqual;
    var errorStrictEqual = require_utils2().errorStrictEqual;
    var ServerType = require_common().ServerType;
    var now = require_utils4().now;
    var WRITABLE_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.Standalone,
      ServerType.Mongos
    ]);
    var DATA_BEARING_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.RSSecondary,
      ServerType.Mongos,
      ServerType.Standalone
    ]);
    var ISMASTER_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "compression",
      "me",
      "hosts",
      "passives",
      "arbiters",
      "tags",
      "setName",
      "setVersion",
      "electionId",
      "primary",
      "logicalSessionTimeoutMinutes",
      "saslSupportedMechs",
      "__nodejs_mock_server__",
      "$clusterTime"
    ];
    var ServerDescription = class {
      constructor(address, ismaster, options2) {
        options2 = options2 || {};
        ismaster = Object.assign({
          minWireVersion: 0,
          maxWireVersion: 0,
          hosts: [],
          passives: [],
          arbiters: [],
          tags: []
        }, ismaster);
        this.address = address;
        this.error = options2.error;
        this.roundTripTime = options2.roundTripTime || -1;
        this.lastUpdateTime = now();
        this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;
        this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;
        this.type = parseServerType(ismaster);
        this.topologyVersion = options2.topologyVersion || ismaster.topologyVersion;
        ISMASTER_FIELDS.forEach((field) => {
          if (typeof ismaster[field] !== "undefined")
            this[field] = ismaster[field];
        });
        if (this.me)
          this.me = this.me.toLowerCase();
        this.hosts = this.hosts.map((host) => host.toLowerCase());
        this.passives = this.passives.map((host) => host.toLowerCase());
        this.arbiters = this.arbiters.map((host) => host.toLowerCase());
      }
      get allHosts() {
        return this.hosts.concat(this.arbiters).concat(this.passives);
      }
      get isReadable() {
        return this.type === ServerType.RSSecondary || this.isWritable;
      }
      get isDataBearing() {
        return DATA_BEARING_SERVER_TYPES.has(this.type);
      }
      get isWritable() {
        return WRITABLE_SERVER_TYPES.has(this.type);
      }
      get host() {
        const chopLength = `:${this.port}`.length;
        return this.address.slice(0, -chopLength);
      }
      get port() {
        const port = this.address.split(":").pop();
        return port ? Number.parseInt(port, 10) : port;
      }
      equals(other) {
        const topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;
        return other != null && errorStrictEqual(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && this.me === other.me && arrayStrictEqual(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && (this.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId) && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
      }
    };
    function parseServerType(ismaster) {
      if (!ismaster || !ismaster.ok) {
        return ServerType.Unknown;
      }
      if (ismaster.isreplicaset) {
        return ServerType.RSGhost;
      }
      if (ismaster.msg && ismaster.msg === "isdbgrid") {
        return ServerType.Mongos;
      }
      if (ismaster.setName) {
        if (ismaster.hidden) {
          return ServerType.RSOther;
        } else if (ismaster.ismaster) {
          return ServerType.RSPrimary;
        } else if (ismaster.secondary) {
          return ServerType.RSSecondary;
        } else if (ismaster.arbiterOnly) {
          return ServerType.RSArbiter;
        } else {
          return ServerType.RSOther;
        }
      }
      return ServerType.Standalone;
    }
    function compareTopologyVersion(lhs, rhs) {
      if (lhs == null || rhs == null) {
        return -1;
      }
      if (lhs.processId.equals(rhs.processId)) {
        if (lhs.counter === rhs.counter) {
          return 0;
        } else if (lhs.counter < rhs.counter) {
          return -1;
        }
        return 1;
      }
      return -1;
    }
    module2.exports = {
      ServerDescription,
      parseServerType,
      compareTopologyVersion
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/constants.js
var require_constants = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/constants.js"(exports2, module2) {
    "use strict";
    var MIN_SUPPORTED_SERVER_VERSION = "2.6";
    var MAX_SUPPORTED_SERVER_VERSION = "4.4";
    var MIN_SUPPORTED_WIRE_VERSION = 2;
    var MAX_SUPPORTED_WIRE_VERSION = 9;
    module2.exports = {
      MIN_SUPPORTED_SERVER_VERSION,
      MAX_SUPPORTED_SERVER_VERSION,
      MIN_SUPPORTED_WIRE_VERSION,
      MAX_SUPPORTED_WIRE_VERSION
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology_description.js
var require_topology_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology_description.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var ServerDescription = require_server_description().ServerDescription;
    var WIRE_CONSTANTS = require_constants();
    var TopologyType = require_common().TopologyType;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var TopologyDescription = class {
      constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options2) {
        options2 = options2 || {};
        this.type = topologyType || TopologyType.Unknown;
        this.setName = setName || null;
        this.maxSetVersion = maxSetVersion || null;
        this.maxElectionId = maxElectionId || null;
        this.servers = serverDescriptions || new Map();
        this.stale = false;
        this.compatible = true;
        this.compatibilityError = null;
        this.logicalSessionTimeoutMinutes = null;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 0;
        this.localThresholdMS = options2.localThresholdMS || 0;
        this.commonWireVersion = commonWireVersion || null;
        Object.defineProperty(this, "options", {value: options2, enumberable: false});
        for (const serverDescription of this.servers.values()) {
          if (serverDescription.type === ServerType.Unknown)
            continue;
          if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
          }
          if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
            break;
          }
        }
        this.logicalSessionTimeoutMinutes = null;
        for (const addressServerTuple of this.servers) {
          const server = addressServerTuple[1];
          if (server.isReadable) {
            if (server.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = null;
              break;
            }
            if (this.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
              continue;
            }
            this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
          }
        }
      }
      updateFromSrvPollingEvent(ev) {
        const newAddresses = ev.addresses();
        const serverDescriptions = new Map(this.servers);
        for (const server of this.servers) {
          if (newAddresses.has(server[0])) {
            newAddresses.delete(server[0]);
          } else {
            serverDescriptions.delete(server[0]);
          }
        }
        if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {
          return this;
        }
        for (const address of newAddresses) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);
      }
      update(serverDescription) {
        const address = serverDescription.address;
        let topologyType = this.type;
        let setName = this.setName;
        let maxSetVersion = this.maxSetVersion;
        let maxElectionId = this.maxElectionId;
        let commonWireVersion = this.commonWireVersion;
        if (serverDescription.setName && setName && serverDescription.setName !== setName) {
          serverDescription = new ServerDescription(address, null);
        }
        const serverType = serverDescription.type;
        let serverDescriptions = new Map(this.servers);
        if (serverDescription.maxWireVersion !== 0) {
          if (commonWireVersion == null) {
            commonWireVersion = serverDescription.maxWireVersion;
          } else {
            commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
          }
        }
        serverDescriptions.set(address, serverDescription);
        if (topologyType === TopologyType.Single) {
          return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
        }
        if (topologyType === TopologyType.Unknown) {
          if (serverType === ServerType.Standalone && this.servers.size !== 1) {
            serverDescriptions.delete(address);
          } else {
            topologyType = topologyTypeForServerType(serverType);
          }
        }
        if (topologyType === TopologyType.Sharded) {
          if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {
            serverDescriptions.delete(address);
          }
        }
        if (topologyType === TopologyType.ReplicaSetNoPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
          }
          if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);
            topologyType = result[0], setName = result[1];
          }
        }
        if (topologyType === TopologyType.ReplicaSetWithPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
            topologyType = checkHasPrimary(serverDescriptions);
          } else if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);
          } else {
            topologyType = checkHasPrimary(serverDescriptions);
          }
        }
        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
      }
      get error() {
        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
        if (descriptionsWithError.length > 0) {
          return descriptionsWithError[0].error;
        }
        return void 0;
      }
      get hasKnownServers() {
        return Array.from(this.servers.values()).some((sd) => sd.type !== ServerType.Unknown);
      }
      get hasDataBearingServers() {
        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
      }
      hasServer(address) {
        return this.servers.has(address);
      }
    };
    function topologyTypeForServerType(serverType) {
      if (serverType === ServerType.Standalone) {
        return TopologyType.Single;
      }
      if (serverType === ServerType.Mongos) {
        return TopologyType.Sharded;
      }
      if (serverType === ServerType.RSPrimary) {
        return TopologyType.ReplicaSetWithPrimary;
      }
      if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function compareObjectId(oid1, oid2) {
      if (oid1 == null) {
        return -1;
      }
      if (oid2 == null) {
        return 1;
      }
      if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {
        const oid1Buffer = oid1.id;
        const oid2Buffer = oid2.id;
        return oid1Buffer.compare(oid2Buffer);
      }
      const oid1String = oid1.toString();
      const oid2String = oid2.toString();
      return oid1String.localeCompare(oid2String);
    }
    function updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {
            serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
      for (const address of serverDescriptions.keys()) {
        const server = serverDescriptions.get(address);
        if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {
          serverDescriptions.set(address, new ServerDescription(server.address));
          break;
        }
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      const currentAddresses = Array.from(serverDescriptions.keys());
      const responseAddresses = serverDescription.allHosts;
      currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
        serverDescriptions.delete(address);
      });
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    function updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      if (setName == null) {
        throw new TypeError("setName is required");
      }
      if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return checkHasPrimary(serverDescriptions);
    }
    function updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      let topologyType = TopologyType.ReplicaSetNoPrimary;
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [topologyType, setName];
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return [topologyType, setName];
    }
    function checkHasPrimary(serverDescriptions) {
      for (const addr of serverDescriptions.keys()) {
        if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {
          return TopologyType.ReplicaSetWithPrimary;
        }
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    module2.exports = {
      TopologyDescription
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/shared.js
var require_shared = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/shared.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var MESSAGE_HEADER_SIZE = 16;
    var COMPRESSION_DETAILS_SIZE = 9;
    var opcodes = {
      OP_REPLY: 1,
      OP_UPDATE: 2001,
      OP_INSERT: 2002,
      OP_QUERY: 2004,
      OP_GETMORE: 2005,
      OP_DELETE: 2006,
      OP_KILL_CURSORS: 2007,
      OP_COMPRESSED: 2012,
      OP_MSG: 2013
    };
    var getReadPreference = function(cmd, options2) {
      var readPreference = cmd.readPreference || new ReadPreference("primary");
      if (options2.readPreference) {
        readPreference = options2.readPreference;
      }
      if (typeof readPreference === "string") {
        readPreference = new ReadPreference(readPreference);
      }
      if (!(readPreference instanceof ReadPreference)) {
        throw new MongoError("read preference must be a ReadPreference instance");
      }
      return readPreference;
    };
    var parseHeader = function(message) {
      return {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
    };
    function applyCommonQueryOptions(queryOptions, options2) {
      Object.assign(queryOptions, {
        raw: typeof options2.raw === "boolean" ? options2.raw : false,
        promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
        promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
        promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false,
        monitoring: typeof options2.monitoring === "boolean" ? options2.monitoring : false,
        fullResult: typeof options2.fullResult === "boolean" ? options2.fullResult : false
      });
      if (typeof options2.socketTimeout === "number") {
        queryOptions.socketTimeout = options2.socketTimeout;
      }
      if (options2.session) {
        queryOptions.session = options2.session;
      }
      if (typeof options2.documentsReturnedIn === "string") {
        queryOptions.documentsReturnedIn = options2.documentsReturnedIn;
      }
      return queryOptions;
    }
    function isSharded(topologyOrServer) {
      if (topologyOrServer.type === "mongos")
        return true;
      if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {
        return true;
      }
      if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {
        const servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some((server) => server.type === ServerType.Mongos);
      }
      return false;
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    module2.exports = {
      getReadPreference,
      MESSAGE_HEADER_SIZE,
      COMPRESSION_DETAILS_SIZE,
      opcodes,
      parseHeader,
      applyCommonQueryOptions,
      isSharded,
      databaseNamespace,
      collectionNamespace
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/compression.js
var require_compression = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/compression.js"(exports2, module2) {
    "use strict";
    var Snappy = require_utils3().retrieveSnappy();
    var zlib2 = require("zlib");
    var compressorIDs = {
      snappy: 1,
      zlib: 2
    };
    var uncompressibleCommands = new Set([
      "ismaster",
      "saslStart",
      "saslContinue",
      "getnonce",
      "authenticate",
      "createUser",
      "updateUser",
      "copydbSaslStart",
      "copydbgetnonce",
      "copydb"
    ]);
    function compress(self, dataToBeCompressed, callback) {
      switch (self.options.agreedCompressor) {
        case "snappy":
          Snappy.compress(dataToBeCompressed, callback);
          break;
        case "zlib":
          var zlibOptions = {};
          if (self.options.zlibCompressionLevel) {
            zlibOptions.level = self.options.zlibCompressionLevel;
          }
          zlib2.deflate(dataToBeCompressed, zlibOptions, callback);
          break;
        default:
          throw new Error('Attempt to compress message using unknown compressor "' + self.options.agreedCompressor + '".');
      }
    }
    function decompress(compressorID, compressedData, callback) {
      if (compressorID < 0 || compressorID > compressorIDs.length) {
        throw new Error("Server sent message compressed using an unsupported compressor. (Received compressor ID " + compressorID + ")");
      }
      switch (compressorID) {
        case compressorIDs.snappy:
          Snappy.uncompress(compressedData, callback);
          break;
        case compressorIDs.zlib:
          zlib2.inflate(compressedData, callback);
          break;
        default:
          callback(null, compressedData);
      }
    }
    module2.exports = {
      compressorIDs,
      uncompressibleCommands,
      compress,
      decompress
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/mongodb/lib/core/connection/commands.js
var require_commands = __commonJS({
  "node_modules/mongodb/lib/core/connection/commands.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var Buffer2 = require_safe_buffer().Buffer;
    var _requestId = 0;
    var opcodes = require_shared().opcodes;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SLAVE = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 1;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var Query = function(bson, ns, query, options2) {
      var self = this;
      if (ns == null)
        throw new Error("ns must be specified for query");
      if (query == null)
        throw new Error("query must be specified for query");
      if (ns.indexOf("\0") !== -1) {
        throw new Error("namespace cannot contain a null character");
      }
      this.bson = bson;
      this.ns = ns;
      this.query = query;
      this.numberToSkip = options2.numberToSkip || 0;
      this.numberToReturn = options2.numberToReturn || 0;
      this.returnFieldSelector = options2.returnFieldSelector || null;
      this.requestId = Query.getRequestId();
      this.pre32Limit = options2.pre32Limit;
      this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
      this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : true;
      this.batchSize = self.numberToReturn;
      this.tailable = false;
      this.slaveOk = typeof options2.slaveOk === "boolean" ? options2.slaveOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    };
    Query.prototype.incRequestId = function() {
      this.requestId = _requestId++;
    };
    Query.nextRequestId = function() {
      return _requestId + 1;
    };
    Query.prototype.toBin = function() {
      var self = this;
      var buffers = [];
      var projection = null;
      var flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.slaveOk) {
        flags |= OPTS_SLAVE;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (self.batchSize !== self.numberToReturn)
        self.numberToReturn = self.batchSize;
      var header = Buffer2.alloc(4 * 4 + 4 + Buffer2.byteLength(self.ns) + 1 + 4 + 4);
      buffers.push(header);
      var query = self.bson.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (self.returnFieldSelector && Object.keys(self.returnFieldSelector).length > 0) {
        projection = self.bson.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      var totalLength = header.length + query.length + (projection ? projection.length : 0);
      var index2 = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index2 + 3] = this.requestId >> 24 & 255;
      header[index2 + 2] = this.requestId >> 16 & 255;
      header[index2 + 1] = this.requestId >> 8 & 255;
      header[index2] = this.requestId & 255;
      index2 = index2 + 4;
      header[index2 + 3] = 0 >> 24 & 255;
      header[index2 + 2] = 0 >> 16 & 255;
      header[index2 + 1] = 0 >> 8 & 255;
      header[index2] = 0 & 255;
      index2 = index2 + 4;
      header[index2 + 3] = opcodes.OP_QUERY >> 24 & 255;
      header[index2 + 2] = opcodes.OP_QUERY >> 16 & 255;
      header[index2 + 1] = opcodes.OP_QUERY >> 8 & 255;
      header[index2] = opcodes.OP_QUERY & 255;
      index2 = index2 + 4;
      header[index2 + 3] = flags >> 24 & 255;
      header[index2 + 2] = flags >> 16 & 255;
      header[index2 + 1] = flags >> 8 & 255;
      header[index2] = flags & 255;
      index2 = index2 + 4;
      index2 = index2 + header.write(this.ns, index2, "utf8") + 1;
      header[index2 - 1] = 0;
      header[index2 + 3] = this.numberToSkip >> 24 & 255;
      header[index2 + 2] = this.numberToSkip >> 16 & 255;
      header[index2 + 1] = this.numberToSkip >> 8 & 255;
      header[index2] = this.numberToSkip & 255;
      index2 = index2 + 4;
      header[index2 + 3] = this.numberToReturn >> 24 & 255;
      header[index2 + 2] = this.numberToReturn >> 16 & 255;
      header[index2 + 1] = this.numberToReturn >> 8 & 255;
      header[index2] = this.numberToReturn & 255;
      index2 = index2 + 4;
      return buffers;
    };
    Query.getRequestId = function() {
      return ++_requestId;
    };
    var GetMore = function(bson, ns, cursorId, opts) {
      opts = opts || {};
      this.numberToReturn = opts.numberToReturn || 0;
      this.requestId = _requestId++;
      this.bson = bson;
      this.ns = ns;
      this.cursorId = cursorId;
    };
    GetMore.prototype.toBin = function() {
      var length = 4 + Buffer2.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4;
      var index2 = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index2 + 3] = length >> 24 & 255;
      _buffer[index2 + 2] = length >> 16 & 255;
      _buffer[index2 + 1] = length >> 8 & 255;
      _buffer[index2] = length & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.requestId >> 24 & 255;
      _buffer[index2 + 2] = this.requestId >> 16 & 255;
      _buffer[index2 + 1] = this.requestId >> 8 & 255;
      _buffer[index2] = this.requestId & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = opcodes.OP_GETMORE >> 24 & 255;
      _buffer[index2 + 2] = opcodes.OP_GETMORE >> 16 & 255;
      _buffer[index2 + 1] = opcodes.OP_GETMORE >> 8 & 255;
      _buffer[index2] = opcodes.OP_GETMORE & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      index2 = index2 + _buffer.write(this.ns, index2, "utf8") + 1;
      _buffer[index2 - 1] = 0;
      _buffer[index2 + 3] = this.numberToReturn >> 24 & 255;
      _buffer[index2 + 2] = this.numberToReturn >> 16 & 255;
      _buffer[index2 + 1] = this.numberToReturn >> 8 & 255;
      _buffer[index2] = this.numberToReturn & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorId.getLowBits() >> 24 & 255;
      _buffer[index2 + 2] = this.cursorId.getLowBits() >> 16 & 255;
      _buffer[index2 + 1] = this.cursorId.getLowBits() >> 8 & 255;
      _buffer[index2] = this.cursorId.getLowBits() & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorId.getHighBits() >> 24 & 255;
      _buffer[index2 + 2] = this.cursorId.getHighBits() >> 16 & 255;
      _buffer[index2 + 1] = this.cursorId.getHighBits() >> 8 & 255;
      _buffer[index2] = this.cursorId.getHighBits() & 255;
      index2 = index2 + 4;
      return _buffer;
    };
    var KillCursor = function(bson, ns, cursorIds) {
      this.ns = ns;
      this.requestId = _requestId++;
      this.cursorIds = cursorIds;
    };
    KillCursor.prototype.toBin = function() {
      var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8;
      var index2 = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index2 + 3] = length >> 24 & 255;
      _buffer[index2 + 2] = length >> 16 & 255;
      _buffer[index2 + 1] = length >> 8 & 255;
      _buffer[index2] = length & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.requestId >> 24 & 255;
      _buffer[index2 + 2] = this.requestId >> 16 & 255;
      _buffer[index2 + 1] = this.requestId >> 8 & 255;
      _buffer[index2] = this.requestId & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = opcodes.OP_KILL_CURSORS >> 24 & 255;
      _buffer[index2 + 2] = opcodes.OP_KILL_CURSORS >> 16 & 255;
      _buffer[index2 + 1] = opcodes.OP_KILL_CURSORS >> 8 & 255;
      _buffer[index2] = opcodes.OP_KILL_CURSORS & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorIds.length >> 24 & 255;
      _buffer[index2 + 2] = this.cursorIds.length >> 16 & 255;
      _buffer[index2 + 1] = this.cursorIds.length >> 8 & 255;
      _buffer[index2] = this.cursorIds.length & 255;
      index2 = index2 + 4;
      for (var i = 0; i < this.cursorIds.length; i++) {
        _buffer[index2 + 3] = this.cursorIds[i].getLowBits() >> 24 & 255;
        _buffer[index2 + 2] = this.cursorIds[i].getLowBits() >> 16 & 255;
        _buffer[index2 + 1] = this.cursorIds[i].getLowBits() >> 8 & 255;
        _buffer[index2] = this.cursorIds[i].getLowBits() & 255;
        index2 = index2 + 4;
        _buffer[index2 + 3] = this.cursorIds[i].getHighBits() >> 24 & 255;
        _buffer[index2 + 2] = this.cursorIds[i].getHighBits() >> 16 & 255;
        _buffer[index2 + 1] = this.cursorIds[i].getHighBits() >> 8 & 255;
        _buffer[index2] = this.cursorIds[i].getHighBits() & 255;
        index2 = index2 + 4;
      }
      return _buffer;
    };
    var Response3 = function(bson, message, msgHeader, msgBody, opts) {
      opts = opts || {promoteLongs: true, promoteValues: true, promoteBuffers: false};
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.bson = bson;
      this.opts = opts;
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.cursorId = new Long2(msgBody.readInt32LE(4), msgBody.readInt32LE(8));
      this.startingFrom = msgBody.readInt32LE(12);
      this.numberReturned = msgBody.readInt32LE(16);
      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
      this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
      this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
    };
    Response3.prototype.isParsed = function() {
      return this.parsed;
    };
    Response3.prototype.parse = function(options2) {
      if (this.parsed)
        return;
      options2 = options2 || {};
      var raw = options2.raw || false;
      var documentsReturnedIn = options2.documentsReturnedIn || null;
      var promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : this.opts.promoteLongs;
      var promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : this.opts.promoteValues;
      var promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : this.opts.promoteBuffers;
      var bsonSize, _options;
      _options = {
        promoteLongs,
        promoteValues,
        promoteBuffers
      };
      this.index = 20;
      for (var i = 0; i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        }
        this.index = this.index + bsonSize;
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc = this.bson.deserialize(this.documents[0], _options);
        this.documents = [doc];
      }
      this.parsed = true;
    };
    module2.exports = {
      Query,
      GetMore,
      Response: Response3,
      KillCursor
    };
  }
});

// node_modules/mongodb/lib/core/connection/msg.js
var require_msg = __commonJS({
  "node_modules/mongodb/lib/core/connection/msg.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var opcodes = require_shared().opcodes;
    var databaseNamespace = require_shared().databaseNamespace;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var _requestId = 0;
    var OPTS_CHECKSUM_PRESENT = 1;
    var OPTS_MORE_TO_COME = 2;
    var OPTS_EXHAUST_ALLOWED = 1 << 16;
    var Msg = class {
      constructor(bson, ns, command, options2) {
        if (command == null)
          throw new Error("query must be specified for query");
        this.bson = bson;
        this.ns = ns;
        this.command = command;
        this.command.$db = databaseNamespace(ns);
        if (options2.readPreference && options2.readPreference.mode !== ReadPreference.PRIMARY) {
          this.command.$readPreference = options2.readPreference.toJSON();
        }
        this.options = options2 || {};
        this.requestId = options2.requestId ? options2.requestId : Msg.getRequestId();
        this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
        this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
        this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
        this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
        this.checksumPresent = false;
        this.moreToCome = options2.moreToCome || false;
        this.exhaustAllowed = typeof options2.exhaustAllowed === "boolean" ? options2.exhaustAllowed : false;
      }
      toBin() {
        const buffers = [];
        let flags = 0;
        if (this.checksumPresent) {
          flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
          flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
          flags |= OPTS_EXHAUST_ALLOWED;
        }
        const header = Buffer2.alloc(4 * 4 + 4);
        buffers.push(header);
        let totalLength = header.length;
        const command = this.command;
        totalLength += this.makeDocumentSegment(buffers, command);
        header.writeInt32LE(totalLength, 0);
        header.writeInt32LE(this.requestId, 4);
        header.writeInt32LE(0, 8);
        header.writeInt32LE(opcodes.OP_MSG, 12);
        header.writeUInt32LE(flags, 16);
        return buffers;
      }
      makeDocumentSegment(buffers, document2) {
        const payloadTypeBuffer = Buffer2.alloc(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document2);
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        return payloadTypeBuffer.length + documentBuffer.length;
      }
      serializeBson(document2) {
        return this.bson.serialize(document2, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
      }
    };
    Msg.getRequestId = function() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    };
    var BinMsg = class {
      constructor(bson, message, msgHeader, msgBody, opts) {
        opts = opts || {promoteLongs: true, promoteValues: true, promoteBuffers: false};
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.bson = bson;
        this.opts = opts;
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
        this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
        this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
        this.documents = [];
      }
      isParsed() {
        return this.parsed;
      }
      parse(options2) {
        if (this.parsed)
          return;
        options2 = options2 || {};
        this.index = 4;
        const raw = options2.raw || false;
        const documentsReturnedIn = options2.documentsReturnedIn || null;
        const promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : this.opts.promoteLongs;
        const promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : this.opts.promoteValues;
        const promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : this.opts.promoteBuffers;
        const _options = {
          promoteLongs,
          promoteValues,
          promoteBuffers
        };
        while (this.index < this.data.length) {
          const payloadType = this.data.readUInt8(this.index++);
          if (payloadType === 1) {
            throw new MongoError("OP_MSG Payload Type 1 detected unsupported protocol");
          } else if (payloadType === 0) {
            const bsonSize = this.data.readUInt32LE(this.index);
            const bin = this.data.slice(this.index, this.index + bsonSize);
            this.documents.push(raw ? bin : this.bson.deserialize(bin, _options));
            this.index += bsonSize;
          }
        }
        if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
          const fieldsAsRaw = {};
          fieldsAsRaw[documentsReturnedIn] = true;
          _options.fieldsAsRaw = fieldsAsRaw;
          const doc = this.bson.deserialize(this.documents[0], _options);
          this.documents = [doc];
        }
        this.parsed = true;
      }
    };
    module2.exports = {Msg, BinMsg};
  }
});

// node_modules/mongodb/lib/core/connection/logger.js
var require_logger = __commonJS({
  "node_modules/mongodb/lib/core/connection/logger.js"(exports2, module2) {
    "use strict";
    var f = require("util").format;
    var MongoError = require_error().MongoError;
    var classFilters = {};
    var filteredClasses = {};
    var level = null;
    var pid = process.pid;
    var currentLogger = null;
    var Logger = function(className, options2) {
      if (!(this instanceof Logger))
        return new Logger(className, options2);
      options2 = options2 || {};
      this.className = className;
      if (options2.logger) {
        currentLogger = options2.logger;
      } else if (currentLogger == null) {
        currentLogger = console.log;
      }
      if (options2.loggerLevel) {
        level = options2.loggerLevel || "error";
      }
      if (filteredClasses[this.className] == null)
        classFilters[this.className] = true;
    };
    Logger.prototype.debug = function(message, object) {
      if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "DEBUG", this.className, pid, dateTime, message);
        var state = {
          type: "debug",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    };
    Logger.prototype.warn = function(message, object) {
      if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "WARN", this.className, pid, dateTime, message);
        var state = {
          type: "warn",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.info = function(message, object) {
      if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "INFO", this.className, pid, dateTime, message);
        var state = {
          type: "info",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.error = function(message, object) {
      if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "ERROR", this.className, pid, dateTime, message);
        var state = {
          type: "error",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.isInfo = function() {
      return level === "info" || level === "debug";
    }, Logger.prototype.isError = function() {
      return level === "error" || level === "info" || level === "debug";
    }, Logger.prototype.isWarn = function() {
      return level === "error" || level === "warn" || level === "info" || level === "debug";
    }, Logger.prototype.isDebug = function() {
      return level === "debug";
    };
    Logger.reset = function() {
      level = "error";
      filteredClasses = {};
    };
    Logger.currentLogger = function() {
      return currentLogger;
    };
    Logger.setCurrentLogger = function(logger) {
      if (typeof logger !== "function")
        throw new MongoError("current logger must be a function");
      currentLogger = logger;
    };
    Logger.filter = function(type, values) {
      if (type === "class" && Array.isArray(values)) {
        filteredClasses = {};
        values.forEach(function(x) {
          filteredClasses[x] = true;
        });
      }
    };
    Logger.setLevel = function(_level) {
      if (_level !== "info" && _level !== "error" && _level !== "debug" && _level !== "warn") {
        throw new Error(f("%s is an illegal logging level", _level));
      }
      level = _level;
    };
    module2.exports = Logger;
  }
});

// node_modules/mongodb/lib/core/connection/command_result.js
var require_command_result = __commonJS({
  "node_modules/mongodb/lib/core/connection/command_result.js"(exports2, module2) {
    "use strict";
    var CommandResult = function(result, connection, message) {
      this.result = result;
      this.connection = connection;
      this.message = message;
    };
    CommandResult.prototype.toJSON = function() {
      let result = Object.assign({}, this, this.result);
      delete result.message;
      return result;
    };
    CommandResult.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    module2.exports = CommandResult;
  }
});

// node_modules/mongodb/lib/core/connection/connection.js
var require_connection = __commonJS({
  "node_modules/mongodb/lib/core/connection/connection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var crypto = require("crypto");
    var debugOptions = require_utils3().debugOptions;
    var parseHeader = require_shared().parseHeader;
    var decompress = require_compression().decompress;
    var Response3 = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoError = require_error().MongoError;
    var Logger = require_logger();
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var Buffer2 = require_safe_buffer().Buffer;
    var Query = require_commands().Query;
    var CommandResult = require_command_result();
    var _id = 0;
    var DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;
    var DEBUG_FIELDS = [
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "checkServerIdentity"
    ];
    var connectionAccountingSpy = void 0;
    var connectionAccounting = false;
    var connections = {};
    var Connection = class extends EventEmitter {
      constructor(socket, options2) {
        super();
        options2 = options2 || {};
        if (!options2.bson) {
          throw new TypeError("must pass in valid bson parser");
        }
        this.id = _id++;
        this.options = options2;
        this.logger = Logger("Connection", options2);
        this.bson = options2.bson;
        this.tag = options2.tag;
        this.maxBsonMessageSize = options2.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;
        this.port = options2.port || 27017;
        this.host = options2.host || "localhost";
        this.socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        this.keepAlive = typeof options2.keepAlive === "boolean" ? options2.keepAlive : true;
        this.keepAliveInitialDelay = typeof options2.keepAliveInitialDelay === "number" ? options2.keepAliveInitialDelay : 12e4;
        this.connectionTimeout = typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : 3e4;
        if (this.keepAliveInitialDelay > this.socketTimeout) {
          this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);
        }
        if (this.logger.isDebug()) {
          this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options2))}]`);
        }
        this.responseOptions = {
          promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
          promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
          promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false
        };
        this.flushing = false;
        this.queue = [];
        this.writeStream = null;
        this.destroyed = false;
        this.timedOut = false;
        const hash2 = crypto.createHash("sha1");
        hash2.update(this.address);
        this.hashedName = hash2.digest("hex");
        this.workItems = [];
        this.socket = socket;
        this.socket.once("error", errorHandler(this));
        this.socket.once("timeout", timeoutHandler(this));
        this.socket.once("close", closeHandler(this));
        this.socket.on("data", dataHandler(this));
        if (connectionAccounting) {
          addConnection(this.id, this);
        }
      }
      setSocketTimeout(value) {
        if (this.socket) {
          this.socket.setTimeout(value);
        }
      }
      resetSocketTimeout() {
        if (this.socket) {
          this.socket.setTimeout(this.socketTimeout);
        }
      }
      static enableConnectionAccounting(spy) {
        if (spy) {
          connectionAccountingSpy = spy;
        }
        connectionAccounting = true;
        connections = {};
      }
      static disableConnectionAccounting() {
        connectionAccounting = false;
        connectionAccountingSpy = void 0;
      }
      static connections() {
        return connections;
      }
      get address() {
        return `${this.host}:${this.port}`;
      }
      unref() {
        if (this.socket == null) {
          this.once("connect", () => this.socket.unref());
          return;
        }
        this.socket.unref();
      }
      flush(err) {
        while (this.workItems.length > 0) {
          const workItem = this.workItems.shift();
          if (workItem.cb) {
            workItem.cb(err);
          }
        }
      }
      destroy(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = Object.assign({force: false}, options2);
        if (connectionAccounting) {
          deleteConnection(this.id);
        }
        if (this.socket == null) {
          this.destroyed = true;
          return;
        }
        if (options2.force || this.timedOut) {
          this.socket.destroy();
          this.destroyed = true;
          if (typeof callback === "function")
            callback(null, null);
          return;
        }
        this.socket.end((err) => {
          this.destroyed = true;
          if (typeof callback === "function")
            callback(err, null);
        });
      }
      write(buffer) {
        if (this.logger.isDebug()) {
          if (!Array.isArray(buffer)) {
            this.logger.debug(`writing buffer [${buffer.toString("hex")}] to ${this.address}`);
          } else {
            for (let i = 0; i < buffer.length; i++)
              this.logger.debug(`writing buffer [${buffer[i].toString("hex")}] to ${this.address}`);
          }
        }
        if (this.socket.destroyed === false) {
          if (!Array.isArray(buffer)) {
            this.socket.write(buffer, "binary");
            return true;
          }
          for (let i = 0; i < buffer.length; i++) {
            this.socket.write(buffer[i], "binary");
          }
          return true;
        }
        return false;
      }
      toString() {
        return "" + this.id;
      }
      toJSON() {
        return {id: this.id, host: this.host, port: this.port};
      }
      isConnected() {
        if (this.destroyed)
          return false;
        return !this.socket.destroyed && this.socket.writable;
      }
      command(ns, command, options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        const conn = this;
        const socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        const bson = conn.options.bson;
        const query = new Query(bson, ns, command, {
          numberToSkip: 0,
          numberToReturn: 1
        });
        const noop3 = () => {
        };
        function _callback(err, result) {
          callback(err, result);
          callback = noop3;
        }
        function errorHandler2(err) {
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          if (err == null) {
            err = new MongoError(`runCommand failed for connection to '${conn.address}'`);
          }
          conn.on("error", noop3);
          _callback(err);
        }
        function messageHandler(msg) {
          if (msg.responseTo !== query.requestId) {
            return;
          }
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          msg.parse({promoteValues: true});
          const response = msg.documents[0];
          if (response.ok === 0 || response.$err || response.errmsg || response.code) {
            _callback(new MongoError(response));
            return;
          }
          _callback(void 0, new CommandResult(response, this, msg));
        }
        conn.setSocketTimeout(socketTimeout);
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.once(eventName, errorHandler2));
        conn.on("message", messageHandler);
        conn.write(query.toBin());
      }
    };
    var CONNECTION_ERROR_EVENTS = ["error", "close", "timeout", "parseError"];
    function deleteConnection(id) {
      delete connections[id];
      if (connectionAccountingSpy) {
        connectionAccountingSpy.deleteConnection(id);
      }
    }
    function addConnection(id, connection) {
      connections[id] = connection;
      if (connectionAccountingSpy) {
        connectionAccountingSpy.addConnection(id, connection);
      }
    }
    function errorHandler(conn) {
      return function(err) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);
        }
        conn.emit("error", new MongoNetworkError(err), conn);
      };
    }
    function timeoutHandler(conn) {
      return function() {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);
        }
        conn.timedOut = true;
        conn.emit("timeout", new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {
          beforeHandshake: conn.ismaster == null
        }), conn);
      };
    }
    function closeHandler(conn) {
      return function(hadError) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);
        }
        if (!hadError) {
          conn.emit("close", new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);
        }
      };
    }
    function processMessage(conn, message) {
      const msgHeader = parseHeader(message);
      if (msgHeader.opCode !== OP_COMPRESSED) {
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response3;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);
        return;
      }
      msgHeader.fromCompressed = true;
      let index2 = MESSAGE_HEADER_SIZE;
      msgHeader.opCode = message.readInt32LE(index2);
      index2 += 4;
      msgHeader.length = message.readInt32LE(index2);
      index2 += 4;
      const compressorID = message[index2];
      index2++;
      decompress(compressorID, message.slice(index2), (err, decompressedMsgBody) => {
        if (err) {
          conn.emit("error", err);
          return;
        }
        if (decompressedMsgBody.length !== msgHeader.length) {
          conn.emit("error", new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response3;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);
      });
    }
    function dataHandler(conn) {
      return function(data) {
        while (data.length > 0) {
          if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {
            const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;
            if (remainingBytesToRead > data.length) {
              data.copy(conn.buffer, conn.bytesRead);
              conn.bytesRead = conn.bytesRead + data.length;
              data = Buffer2.alloc(0);
            } else {
              data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);
              data = data.slice(remainingBytesToRead);
              const emitBuffer = conn.buffer;
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
              processMessage(conn, emitBuffer);
            }
          } else {
            if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {
              if (conn.stubBuffer.length + data.length > 4) {
                const newData = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newData, 0);
                data.copy(newData, conn.stubBuffer.length);
                data = newData;
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
              } else {
                const newStubBuffer = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newStubBuffer, 0);
                data.copy(newStubBuffer, conn.stubBuffer.length);
                data = Buffer2.alloc(0);
              }
            } else {
              if (data.length > 4) {
                const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
                if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: "",
                    bin: conn.buffer,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: conn.bytesRead,
                      stubBuffer: conn.stubBuffer
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  return;
                }
                if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {
                  conn.buffer = Buffer2.alloc(sizeOfMessage);
                  data.copy(conn.buffer, 0);
                  conn.bytesRead = data.length;
                  conn.sizeOfMessage = sizeOfMessage;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {
                  const emitBuffer = data;
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                  processMessage(conn, emitBuffer);
                } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: null,
                    bin: data,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: 0,
                      buffer: null,
                      stubBuffer: null
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else {
                  const emitBuffer = data.slice(0, sizeOfMessage);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = data.slice(sizeOfMessage);
                  processMessage(conn, emitBuffer);
                }
              } else {
                conn.stubBuffer = Buffer2.alloc(data.length);
                data.copy(conn.stubBuffer, 0);
                data = Buffer2.alloc(0);
              }
            }
          }
        }
      };
    }
    module2.exports = Connection;
  }
});

// node_modules/mongodb/lib/core/connection/apm.js
var require_apm = __commonJS({
  "node_modules/mongodb/lib/core/connection/apm.js"(exports2, module2) {
    "use strict";
    var Msg = require_msg().Msg;
    var KillCursor = require_commands().KillCursor;
    var GetMore = require_commands().GetMore;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var SENSITIVE_COMMANDS = new Set([
      "authenticate",
      "saslStart",
      "saslContinue",
      "getnonce",
      "createUser",
      "updateUser",
      "copydbgetnonce",
      "copydbsaslstart",
      "copydb"
    ]);
    var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
    var namespace = (command) => command.ns;
    var databaseName = (command) => command.ns.split(".")[0];
    var collectionName = (command) => command.ns.split(".")[1];
    var generateConnectionId = (pool) => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;
    var maybeRedact = (commandName, result) => SENSITIVE_COMMANDS.has(commandName) ? {} : result;
    var isLegacyPool = (pool) => pool.s && pool.queue;
    var LEGACY_FIND_QUERY_MAP = {
      $query: "filter",
      $orderby: "sort",
      $hint: "hint",
      $comment: "comment",
      $maxScan: "maxScan",
      $max: "max",
      $min: "min",
      $returnKey: "returnKey",
      $showDiskLoc: "showRecordId",
      $maxTimeMS: "maxTimeMS",
      $snapshot: "snapshot"
    };
    var LEGACY_FIND_OPTIONS_MAP = {
      numberToSkip: "skip",
      numberToReturn: "batchSize",
      returnFieldsSelector: "projection"
    };
    var OP_QUERY_KEYS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "partial",
      "exhaust"
    ];
    var extractCommand = (command) => {
      if (command instanceof GetMore) {
        return {
          getMore: command.cursorId,
          collection: collectionName(command),
          batchSize: command.numberToReturn
        };
      }
      if (command instanceof KillCursor) {
        return {
          killCursors: collectionName(command),
          cursors: command.cursorIds
        };
      }
      if (command instanceof Msg) {
        return command.command;
      }
      if (command.query && command.query.$query) {
        let result;
        if (command.ns === "admin.$cmd") {
          result = Object.assign({}, command.query.$query);
        } else {
          result = {find: collectionName(command)};
          Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
            if (typeof command.query[key] !== "undefined")
              result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];
          });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
          if (typeof command[key] !== "undefined")
            result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];
        });
        OP_QUERY_KEYS.forEach((key) => {
          if (command[key])
            result[key] = command[key];
        });
        if (typeof command.pre32Limit !== "undefined") {
          result.limit = command.pre32Limit;
        }
        if (command.query.$explain) {
          return {explain: result};
        }
        return result;
      }
      return command.query ? command.query : command;
    };
    var extractReply = (command, reply) => {
      if (command instanceof GetMore) {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            nextBatch: reply.message.documents
          }
        };
      }
      if (command instanceof KillCursor) {
        return {
          ok: 1,
          cursorsUnknown: command.cursorIds
        };
      }
      if (command.query && typeof command.query.$query !== "undefined") {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            firstBatch: reply.message.documents
          }
        };
      }
      return reply && reply.result ? reply.result : reply;
    };
    var extractConnectionDetails = (pool) => {
      if (isLegacyPool(pool)) {
        return {
          connectionId: generateConnectionId(pool)
        };
      }
      const connection = pool;
      return {
        address: connection.address,
        connectionId: connection.id
      };
    };
    var CommandStartedEvent = class {
      constructor(pool, command) {
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const connectionDetails = extractConnectionDetails(pool);
        if (SENSITIVE_COMMANDS.has(commandName)) {
          this.commandObj = {};
          this.commandObj[commandName] = true;
        }
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          databaseName: databaseName(command),
          commandName,
          command: cmd
        });
      }
    };
    var CommandSucceededEvent = class {
      constructor(pool, command, reply, started) {
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          reply: maybeRedact(commandName, extractReply(command, reply))
        });
      }
    };
    var CommandFailedEvent = class {
      constructor(pool, command, error3, started) {
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          failure: maybeRedact(commandName, error3)
        });
      }
    };
    module2.exports = {
      CommandStartedEvent,
      CommandSucceededEvent,
      CommandFailedEvent
    };
  }
});

// node_modules/mongodb/lib/core/auth/auth_provider.js
var require_auth_provider = __commonJS({
  "node_modules/mongodb/lib/core/auth/auth_provider.js"(exports2, module2) {
    "use strict";
    var AuthContext = class {
      constructor(connection, credentials, options2) {
        this.connection = connection;
        this.credentials = credentials;
        this.options = options2;
      }
    };
    var AuthProvider = class {
      constructor(bson) {
        this.bson = bson;
      }
      prepare(handshakeDoc, context, callback) {
        callback(void 0, handshakeDoc);
      }
      auth(context, callback) {
        callback(new TypeError("`auth` method must be overridden by subclass"));
      }
    };
    module2.exports = {AuthContext, AuthProvider};
  }
});

// node_modules/mongodb/lib/core/auth/mongocr.js
var require_mongocr = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongocr.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCR = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const source = credentials.source;
        connection.command(`${source}.$cmd`, {getnonce: 1}, (err, result) => {
          let nonce = null;
          let key = null;
          if (err == null) {
            const r = result.result;
            nonce = r.nonce;
            let md5 = crypto.createHash("md5");
            md5.update(username + ":mongo:" + password, "utf8");
            const hash_password = md5.digest("hex");
            md5 = crypto.createHash("md5");
            md5.update(nonce + username + hash_password, "utf8");
            key = md5.digest("hex");
          }
          const authenticateCommand = {
            authenticate: 1,
            user: username,
            nonce,
            key
          };
          connection.command(`${source}.$cmd`, authenticateCommand, callback);
        });
      }
    };
    module2.exports = MongoCR;
  }
});

// node_modules/mongodb/lib/core/auth/x509.js
var require_x509 = __commonJS({
  "node_modules/mongodb/lib/core/auth/x509.js"(exports2, module2) {
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var X509 = class extends AuthProvider {
      prepare(handshakeDoc, authContext, callback) {
        const credentials = authContext.credentials;
        Object.assign(handshakeDoc, {
          speculativeAuthenticate: x509AuthenticateCommand(credentials)
        });
        callback(void 0, handshakeDoc);
      }
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const response = authContext.response;
        if (response.speculativeAuthenticate) {
          return callback();
        }
        connection.command("$external.$cmd", x509AuthenticateCommand(credentials), callback);
      }
    };
    function x509AuthenticateCommand(credentials) {
      const command = {authenticate: 1, mechanism: "MONGODB-X509"};
      if (credentials.username) {
        Object.assign(command, {user: credentials.username});
      }
      return command;
    }
    module2.exports = X509;
  }
});

// node_modules/mongodb/lib/core/auth/plain.js
var require_plain = __commonJS({
  "node_modules/mongodb/lib/core/auth/plain.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var AuthProvider = require_auth_provider().AuthProvider;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var Plain = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const payload = new Binary2(`\0${username}\0${password}`);
        const command = {
          saslStart: 1,
          mechanism: "PLAIN",
          payload,
          autoAuthorize: 1
        };
        connection.command("$external.$cmd", command, callback);
      }
    };
    module2.exports = Plain;
  }
});

// node_modules/mongodb/lib/core/auth/gssapi.js
var require_gssapi = __commonJS({
  "node_modules/mongodb/lib/core/auth/gssapi.js"(exports2, module2) {
    "use strict";
    var dns = require("dns");
    var AuthProvider = require_auth_provider().AuthProvider;
    var retrieveKerberos = require_utils2().retrieveKerberos;
    var MongoError = require_error().MongoError;
    var kerberos;
    var GSSAPI = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (credentials == null)
          return callback(new MongoError("credentials required"));
        const username = credentials.username;
        function externalCommand(command, cb) {
          return connection.command("$external.$cmd", command, cb);
        }
        makeKerberosClient(authContext, (err, client) => {
          if (err)
            return callback(err);
          if (client == null)
            return callback(new MongoError("gssapi client missing"));
          client.step("", (err2, payload) => {
            if (err2)
              return callback(err2);
            externalCommand(saslStart(payload), (err3, response) => {
              if (err3)
                return callback(err3);
              const result = response.result;
              negotiate(client, 10, result.payload, (err4, payload2) => {
                if (err4)
                  return callback(err4);
                externalCommand(saslContinue(payload2, result.conversationId), (err5, response2) => {
                  if (err5)
                    return callback(err5);
                  const result2 = response2.result;
                  finalize(client, username, result2.payload, (err6, payload3) => {
                    if (err6)
                      return callback(err6);
                    externalCommand({
                      saslContinue: 1,
                      conversationId: result2.conversationId,
                      payload: payload3
                    }, (err7, result3) => {
                      if (err7)
                        return callback(err7);
                      callback(void 0, result3);
                    });
                  });
                });
              });
            });
          });
        });
      }
    };
    module2.exports = GSSAPI;
    function makeKerberosClient(authContext, callback) {
      const host = authContext.options.host;
      const port = authContext.options.port;
      const credentials = authContext.credentials;
      if (!host || !port || !credentials) {
        return callback(new MongoError(`Connection must specify: ${host ? "host" : ""}, ${port ? "port" : ""}, ${credentials ? "host" : "credentials"}.`));
      }
      if (kerberos == null) {
        try {
          kerberos = retrieveKerberos();
        } catch (e) {
          return callback(e);
        }
      }
      const username = credentials.username;
      const password = credentials.password;
      const mechanismProperties = credentials.mechanismProperties;
      const serviceName = mechanismProperties["gssapiservicename"] || mechanismProperties["gssapiServiceName"] || "mongodb";
      performGssapiCanonicalizeHostName(host, mechanismProperties, (err, host2) => {
        if (err)
          return callback(err);
        const initOptions = {};
        if (password != null) {
          Object.assign(initOptions, {user: username, password});
        }
        kerberos.initializeClient(`${serviceName}${process.platform === "win32" ? "/" : "@"}${host2}`, initOptions, (err2, client) => {
          if (err2)
            return callback(new MongoError(err2));
          callback(null, client);
        });
      });
    }
    function saslStart(payload) {
      return {
        saslStart: 1,
        mechanism: "GSSAPI",
        payload,
        autoAuthorize: 1
      };
    }
    function saslContinue(payload, conversationId) {
      return {
        saslContinue: 1,
        conversationId,
        payload
      };
    }
    function negotiate(client, retries, payload, callback) {
      client.step(payload, (err, response) => {
        if (err && retries === 0)
          return callback(err);
        if (err)
          return negotiate(client, retries - 1, payload, callback);
        callback(void 0, response || "");
      });
    }
    function finalize(client, user, payload, callback) {
      client.unwrap(payload, (err, response) => {
        if (err)
          return callback(err);
        client.wrap(response || "", {user}, (err2, wrapped) => {
          if (err2)
            return callback(err2);
          callback(void 0, wrapped);
        });
      });
    }
    function performGssapiCanonicalizeHostName(host, mechanismProperties, callback) {
      const canonicalizeHostName = typeof mechanismProperties.gssapiCanonicalizeHostName === "boolean" ? mechanismProperties.gssapiCanonicalizeHostName : false;
      if (!canonicalizeHostName)
        return callback(void 0, host);
      dns.resolveCname(host, (err, r) => {
        if (err)
          return callback(err);
        if (Array.isArray(r) && r.length > 0) {
          return callback(void 0, r[0]);
        }
        callback(void 0, host);
      });
    }
  }
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "node_modules/memory-pager/index.js"(exports2, module2) {
    module2.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager))
        return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page) {
      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
        page.deduplicate++;
        if (page.deduplicate === this.deduplicate.length) {
          page.deduplicate = 0;
          if (page.buffer.equals && page.buffer.equals(this.deduplicate))
            page.buffer = this.deduplicate;
          break;
        }
      }
      if (page.updated || !this.updates)
        return;
      page.updated = true;
      this.updates.push(page);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length)
        return null;
      var page = this.updates.pop();
      page.updated = false;
      return page;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate)
          return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate)
            return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page = arr && arr[first];
      if (!page && !noAllocate) {
        page = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length)
          this.length = i + 1;
      }
      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page.buffer = copy(page.buffer);
        page.deduplicate = 0;
      }
      return page;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length)
        this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page)
        page.buffer = b;
      else
        arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list = new Array(this.length);
      var empty2 = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list.length; i++) {
          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty2;
        }
      }
      return Buffer.concat(list);
    };
    function grow(pager, index2) {
      while (pager.maxPages < index2) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len)
        return buf;
      if (buf.length > len)
        return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc)
        return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "node_modules/sparse-bitfield/index.js"(exports2, module2) {
    var pager = require_memory_pager();
    module2.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield))
        return new Bitfield(opts);
      if (!opts)
        opts = {};
      if (Buffer.isBuffer(opts))
        opts = {buffer: opts};
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize))
        throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, true);
      return page ? page.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next)
          next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, false);
      o += this.pageOffset;
      if (page.buffer[o] === b)
        return false;
      page.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates)
        this.pages.updated(page);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc)
        return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// node_modules/saslprep/lib/memory-code-points.js
var require_memory_code_points = __commonJS({
  "node_modules/saslprep/lib/memory-code-points.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var bitfield = require_sparse_bitfield();
    var memory = fs.readFileSync(path.resolve(__dirname, "../code-points.mem"));
    var offset = 0;
    function read2() {
      const size = memory.readUInt32BE(offset);
      offset += 4;
      const codepoints = memory.slice(offset, offset + size);
      offset += size;
      return bitfield({buffer: codepoints});
    }
    var unassigned_code_points = read2();
    var commonly_mapped_to_nothing = read2();
    var non_ASCII_space_characters = read2();
    var prohibited_characters = read2();
    var bidirectional_r_al = read2();
    var bidirectional_l = read2();
    module2.exports = {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    };
  }
});

// node_modules/saslprep/index.js
var require_saslprep = __commonJS({
  "node_modules/saslprep/index.js"(exports2, module2) {
    "use strict";
    var {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    } = require_memory_code_points();
    module2.exports = saslprep;
    var mapping2space = non_ASCII_space_characters;
    var mapping2nothing = commonly_mapped_to_nothing;
    var getCodePoint = (character) => character.codePointAt(0);
    var first = (x) => x[0];
    var last = (x) => x[x.length - 1];
    function toCodePoints(input) {
      const codepoints = [];
      const size = input.length;
      for (let i = 0; i < size; i += 1) {
        const before = input.charCodeAt(i);
        if (before >= 55296 && before <= 56319 && size > i + 1) {
          const next = input.charCodeAt(i + 1);
          if (next >= 56320 && next <= 57343) {
            codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
            i += 1;
            continue;
          }
        }
        codepoints.push(before);
      }
      return codepoints;
    }
    function saslprep(input, opts = {}) {
      if (typeof input !== "string") {
        throw new TypeError("Expected string.");
      }
      if (input.length === 0) {
        return "";
      }
      const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
      const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
      const normalized_map = toCodePoints(normalized_input);
      const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
      if (hasProhibited) {
        throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
      }
      if (opts.allowUnassigned !== true) {
        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
        if (hasUnassigned) {
          throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
        }
      }
      const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
      const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
      if (hasBidiRAL && hasBidiL) {
        throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
      const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
      if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      return normalized_input;
    }
  }
});

// node_modules/mongodb/lib/core/auth/scram.js
var require_scram = __commonJS({
  "node_modules/mongodb/lib/core/auth/scram.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var AuthProvider = require_auth_provider().AuthProvider;
    var emitWarningOnce = require_utils4().emitWarning;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var saslprep;
    try {
      saslprep = require_saslprep();
    } catch (e) {
    }
    var ScramSHA = class extends AuthProvider {
      constructor(bson, cryptoMethod) {
        super(bson);
        this.cryptoMethod = cryptoMethod || "sha1";
      }
      prepare(handshakeDoc, authContext, callback) {
        const cryptoMethod = this.cryptoMethod;
        if (cryptoMethod === "sha256" && saslprep == null) {
          emitWarningOnce("Warning: no saslprep library specified. Passwords will not be sanitized");
        }
        crypto.randomBytes(24, (err, nonce) => {
          if (err) {
            return callback(err);
          }
          Object.assign(authContext, {nonce});
          const credentials = authContext.credentials;
          const request = Object.assign({}, handshakeDoc, {
            speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
              db: credentials.source
            })
          });
          callback(void 0, request);
        });
      }
      auth(authContext, callback) {
        const response = authContext.response;
        if (response && response.speculativeAuthenticate) {
          continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
          return;
        }
        executeScram(this.cryptoMethod, authContext, callback);
      }
    };
    function cleanUsername(username) {
      return username.replace("=", "=3D").replace(",", "=2C");
    }
    function clientFirstMessageBare(username, nonce) {
      return Buffer2.concat([
        Buffer2.from("n=", "utf8"),
        Buffer2.from(username, "utf8"),
        Buffer2.from(",r=", "utf8"),
        Buffer2.from(nonce.toString("base64"), "utf8")
      ]);
    }
    function makeFirstMessage(cryptoMethod, credentials, nonce) {
      const username = cleanUsername(credentials.username);
      const mechanism = cryptoMethod === "sha1" ? "SCRAM-SHA-1" : "SCRAM-SHA-256";
      return {
        saslStart: 1,
        mechanism,
        payload: new Binary2(Buffer2.concat([Buffer2.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
        autoAuthorize: 1,
        options: {skipEmptyExchange: true}
      };
    }
    function executeScram(cryptoMethod, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
      connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        continueScramConversation(cryptoMethod, result.result, authContext, callback);
      });
    }
    function continueScramConversation(cryptoMethod, response, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const username = cleanUsername(credentials.username);
      const password = credentials.password;
      let processedPassword;
      if (cryptoMethod === "sha256") {
        processedPassword = saslprep ? saslprep(password) : password;
      } else {
        try {
          processedPassword = passwordDigest(username, password);
        } catch (e) {
          return callback(e);
        }
      }
      const payload = Buffer2.isBuffer(response.payload) ? new Binary2(response.payload) : response.payload;
      const dict = parsePayload(payload.value());
      const iterations = parseInt(dict.i, 10);
      if (iterations && iterations < 4096) {
        callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);
        return;
      }
      const salt = dict.s;
      const rnonce = dict.r;
      if (rnonce.startsWith("nonce")) {
        callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);
        return;
      }
      const withoutProof = `c=biws,r=${rnonce}`;
      const saltedPassword = HI(processedPassword, Buffer2.from(salt, "base64"), iterations, cryptoMethod);
      const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
      const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
      const storedKey = H(cryptoMethod, clientKey);
      const authMessage = [
        clientFirstMessageBare(username, nonce),
        payload.value().toString("base64"),
        withoutProof
      ].join(",");
      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
      const clientProof = `p=${xor(clientKey, clientSignature)}`;
      const clientFinal = [withoutProof, clientProof].join(",");
      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
      const saslContinueCmd = {
        saslContinue: 1,
        conversationId: response.conversationId,
        payload: new Binary2(Buffer2.from(clientFinal))
      };
      connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        const r = result.result;
        const parsedResponse = parsePayload(r.payload.value());
        if (!compareDigest(Buffer2.from(parsedResponse.v, "base64"), serverSignature)) {
          callback(new MongoError("Server returned an invalid signature"));
          return;
        }
        if (!r || r.done !== false) {
          return callback(err, r);
        }
        const retrySaslContinueCmd = {
          saslContinue: 1,
          conversationId: r.conversationId,
          payload: Buffer2.alloc(0)
        };
        connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);
      });
    }
    function parsePayload(payload) {
      const dict = {};
      const parts = payload.split(",");
      for (let i = 0; i < parts.length; i++) {
        const valueParts = parts[i].split("=");
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    }
    function passwordDigest(username, password) {
      if (typeof username !== "string") {
        throw new MongoError("username must be a string");
      }
      if (typeof password !== "string") {
        throw new MongoError("password must be a string");
      }
      if (password.length === 0) {
        throw new MongoError("password cannot be empty");
      }
      const md5 = crypto.createHash("md5");
      md5.update(`${username}:mongo:${password}`, "utf8");
      return md5.digest("hex");
    }
    function xor(a, b) {
      if (!Buffer2.isBuffer(a)) {
        a = Buffer2.from(a);
      }
      if (!Buffer2.isBuffer(b)) {
        b = Buffer2.from(b);
      }
      const length = Math.max(a.length, b.length);
      const res = [];
      for (let i = 0; i < length; i += 1) {
        res.push(a[i] ^ b[i]);
      }
      return Buffer2.from(res).toString("base64");
    }
    function H(method, text) {
      return crypto.createHash(method).update(text).digest();
    }
    function HMAC(method, key, text) {
      return crypto.createHmac(method, key).update(text).digest();
    }
    var _hiCache = {};
    var _hiCacheCount = 0;
    function _hiCachePurge() {
      _hiCache = {};
      _hiCacheCount = 0;
    }
    var hiLengthMap = {
      sha256: 32,
      sha1: 20
    };
    function HI(data, salt, iterations, cryptoMethod) {
      const key = [data, salt.toString("base64"), iterations].join("_");
      if (_hiCache[key] !== void 0) {
        return _hiCache[key];
      }
      const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
      if (_hiCacheCount >= 200) {
        _hiCachePurge();
      }
      _hiCache[key] = saltedData;
      _hiCacheCount += 1;
      return saltedData;
    }
    function compareDigest(lhs, rhs) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      if (typeof crypto.timingSafeEqual === "function") {
        return crypto.timingSafeEqual(lhs, rhs);
      }
      let result = 0;
      for (let i = 0; i < lhs.length; i++) {
        result |= lhs[i] ^ rhs[i];
      }
      return result === 0;
    }
    function resolveError(err, result) {
      if (err)
        return err;
      const r = result.result;
      if (r.$err || r.errmsg)
        return new MongoError(r);
    }
    var ScramSHA1 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha1");
      }
    };
    var ScramSHA256 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha256");
      }
    };
    module2.exports = {ScramSHA1, ScramSHA256};
  }
});

// node_modules/mongodb/lib/core/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongo_credentials.js"(exports2, module2) {
    "use strict";
    function getDefaultAuthMechanism(ismaster) {
      if (ismaster) {
        if (Array.isArray(ismaster.saslSupportedMechs)) {
          return ismaster.saslSupportedMechs.indexOf("SCRAM-SHA-256") >= 0 ? "scram-sha-256" : "scram-sha-1";
        }
        if (ismaster.maxWireVersion >= 3) {
          return "scram-sha-1";
        }
      }
      return "mongocr";
    }
    var MongoCredentials = class {
      constructor(options2) {
        options2 = options2 || {};
        this.username = options2.username;
        this.password = options2.password;
        this.source = options2.source || options2.db;
        this.mechanism = options2.mechanism || "default";
        this.mechanismProperties = options2.mechanismProperties || {};
        if (/MONGODB-AWS/i.test(this.mechanism)) {
          if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
            this.username = process.env.AWS_ACCESS_KEY_ID;
          }
          if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
            this.password = process.env.AWS_SECRET_ACCESS_KEY;
          }
          if (!this.mechanismProperties.AWS_SESSION_TOKEN && process.env.AWS_SESSION_TOKEN) {
            this.mechanismProperties.AWS_SESSION_TOKEN = process.env.AWS_SESSION_TOKEN;
          }
        }
        Object.freeze(this.mechanismProperties);
        Object.freeze(this);
      }
      equals(other) {
        return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
      }
      resolveAuthMechanism(ismaster) {
        if (/DEFAULT/i.test(this.mechanism)) {
          return new MongoCredentials({
            username: this.username,
            password: this.password,
            source: this.source,
            mechanism: getDefaultAuthMechanism(ismaster),
            mechanismProperties: this.mechanismProperties
          });
        }
        return this;
      }
    };
    module2.exports = {MongoCredentials};
  }
});

// ../../../../node_modules/aws4/lru.js
var require_lru = __commonJS({
  "../../../../node_modules/aws4/lru.js"(exports2, module2) {
    module2.exports = function(size) {
      return new LruCache(size);
    };
    function LruCache(size) {
      this.capacity = size | 0;
      this.map = Object.create(null);
      this.list = new DoublyLinkedList();
    }
    LruCache.prototype.get = function(key) {
      var node = this.map[key];
      if (node == null)
        return void 0;
      this.used(node);
      return node.val;
    };
    LruCache.prototype.set = function(key, val) {
      var node = this.map[key];
      if (node != null) {
        node.val = val;
      } else {
        if (!this.capacity)
          this.prune();
        if (!this.capacity)
          return false;
        node = new DoublyLinkedNode(key, val);
        this.map[key] = node;
        this.capacity--;
      }
      this.used(node);
      return true;
    };
    LruCache.prototype.used = function(node) {
      this.list.moveToFront(node);
    };
    LruCache.prototype.prune = function() {
      var node = this.list.pop();
      if (node != null) {
        delete this.map[node.key];
        this.capacity++;
      }
    };
    function DoublyLinkedList() {
      this.firstNode = null;
      this.lastNode = null;
    }
    DoublyLinkedList.prototype.moveToFront = function(node) {
      if (this.firstNode == node)
        return;
      this.remove(node);
      if (this.firstNode == null) {
        this.firstNode = node;
        this.lastNode = node;
        node.prev = null;
        node.next = null;
      } else {
        node.prev = null;
        node.next = this.firstNode;
        node.next.prev = node;
        this.firstNode = node;
      }
    };
    DoublyLinkedList.prototype.pop = function() {
      var lastNode = this.lastNode;
      if (lastNode != null) {
        this.remove(lastNode);
      }
      return lastNode;
    };
    DoublyLinkedList.prototype.remove = function(node) {
      if (this.firstNode == node) {
        this.firstNode = node.next;
      } else if (node.prev != null) {
        node.prev.next = node.next;
      }
      if (this.lastNode == node) {
        this.lastNode = node.prev;
      } else if (node.next != null) {
        node.next.prev = node.prev;
      }
    };
    function DoublyLinkedNode(key, val) {
      this.key = key;
      this.val = val;
      this.prev = null;
      this.next = null;
    }
  }
});

// ../../../../node_modules/aws4/aws4.js
var require_aws4 = __commonJS({
  "../../../../node_modules/aws4/aws4.js"(exports2) {
    var aws4 = exports2;
    var url = require("url");
    var querystring = require("querystring");
    var crypto = require("crypto");
    var lru = require_lru();
    var credentialsCache = lru(1e3);
    function hmac(key, string, encoding) {
      return crypto.createHmac("sha256", key).update(string, "utf8").digest(encoding);
    }
    function hash2(string, encoding) {
      return crypto.createHash("sha256").update(string, "utf8").digest(encoding);
    }
    function encodeRfc3986(urlEncodedString) {
      return urlEncodedString.replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeRfc3986Full(str) {
      return encodeRfc3986(encodeURIComponent(str));
    }
    function RequestSigner(request, credentials) {
      if (typeof request === "string")
        request = url.parse(request);
      var headers = request.headers = request.headers || {}, hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host);
      this.request = request;
      this.credentials = credentials || this.defaultCredentials();
      this.service = request.service || hostParts[0] || "";
      this.region = request.region || hostParts[1] || "us-east-1";
      if (this.service === "email")
        this.service = "ses";
      if (!request.method && request.body)
        request.method = "POST";
      if (!headers.Host && !headers.host) {
        headers.Host = request.hostname || request.host || this.createHost();
        if (request.port)
          headers.Host += ":" + request.port;
      }
      if (!request.hostname && !request.host)
        request.hostname = headers.Host || headers.host;
      this.isCodeCommitGit = this.service === "codecommit" && request.method === "GIT";
    }
    RequestSigner.prototype.matchHost = function(host) {
      var match = (host || "").match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com(\.cn)?$/);
      var hostParts = (match || []).slice(1, 3);
      if (hostParts[1] === "es")
        hostParts = hostParts.reverse();
      if (hostParts[1] == "s3") {
        hostParts[0] = "s3";
        hostParts[1] = "us-east-1";
      } else {
        for (var i = 0; i < 2; i++) {
          if (/^s3-/.test(hostParts[i])) {
            hostParts[1] = hostParts[i].slice(3);
            hostParts[0] = "s3";
            break;
          }
        }
      }
      return hostParts;
    };
    RequestSigner.prototype.isSingleRegion = function() {
      if (["s3", "sdb"].indexOf(this.service) >= 0 && this.region === "us-east-1")
        return true;
      return ["cloudfront", "ls", "route53", "iam", "importexport", "sts"].indexOf(this.service) >= 0;
    };
    RequestSigner.prototype.createHost = function() {
      var region = this.isSingleRegion() ? "" : "." + this.region, subdomain = this.service === "ses" ? "email" : this.service;
      return subdomain + region + ".amazonaws.com";
    };
    RequestSigner.prototype.prepareRequest = function() {
      this.parsePath();
      var request = this.request, headers = request.headers, query;
      if (request.signQuery) {
        this.parsedPath.query = query = this.parsedPath.query || {};
        if (this.credentials.sessionToken)
          query["X-Amz-Security-Token"] = this.credentials.sessionToken;
        if (this.service === "s3" && !query["X-Amz-Expires"])
          query["X-Amz-Expires"] = 86400;
        if (query["X-Amz-Date"])
          this.datetime = query["X-Amz-Date"];
        else
          query["X-Amz-Date"] = this.getDateTime();
        query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
        query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString();
        query["X-Amz-SignedHeaders"] = this.signedHeaders();
      } else {
        if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
          if (request.body && !headers["Content-Type"] && !headers["content-type"])
            headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
          if (request.body && !headers["Content-Length"] && !headers["content-length"])
            headers["Content-Length"] = Buffer.byteLength(request.body);
          if (this.credentials.sessionToken && !headers["X-Amz-Security-Token"] && !headers["x-amz-security-token"])
            headers["X-Amz-Security-Token"] = this.credentials.sessionToken;
          if (this.service === "s3" && !headers["X-Amz-Content-Sha256"] && !headers["x-amz-content-sha256"])
            headers["X-Amz-Content-Sha256"] = hash2(this.request.body || "", "hex");
          if (headers["X-Amz-Date"] || headers["x-amz-date"])
            this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"];
          else
            headers["X-Amz-Date"] = this.getDateTime();
        }
        delete headers.Authorization;
        delete headers.authorization;
      }
    };
    RequestSigner.prototype.sign = function() {
      if (!this.parsedPath)
        this.prepareRequest();
      if (this.request.signQuery) {
        this.parsedPath.query["X-Amz-Signature"] = this.signature();
      } else {
        this.request.headers.Authorization = this.authHeader();
      }
      this.request.path = this.formatPath();
      return this.request;
    };
    RequestSigner.prototype.getDateTime = function() {
      if (!this.datetime) {
        var headers = this.request.headers, date = new Date(headers.Date || headers.date || new Date());
        this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, "");
        if (this.isCodeCommitGit)
          this.datetime = this.datetime.slice(0, -1);
      }
      return this.datetime;
    };
    RequestSigner.prototype.getDate = function() {
      return this.getDateTime().substr(0, 8);
    };
    RequestSigner.prototype.authHeader = function() {
      return [
        "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(),
        "SignedHeaders=" + this.signedHeaders(),
        "Signature=" + this.signature()
      ].join(", ");
    };
    RequestSigner.prototype.signature = function() {
      var date = this.getDate(), cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(), kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
      if (!kCredentials) {
        kDate = hmac("AWS4" + this.credentials.secretAccessKey, date);
        kRegion = hmac(kDate, this.region);
        kService = hmac(kRegion, this.service);
        kCredentials = hmac(kService, "aws4_request");
        credentialsCache.set(cacheKey, kCredentials);
      }
      return hmac(kCredentials, this.stringToSign(), "hex");
    };
    RequestSigner.prototype.stringToSign = function() {
      return [
        "AWS4-HMAC-SHA256",
        this.getDateTime(),
        this.credentialString(),
        hash2(this.canonicalString(), "hex")
      ].join("\n");
    };
    RequestSigner.prototype.canonicalString = function() {
      if (!this.parsedPath)
        this.prepareRequest();
      var pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = this.service !== "s3", decodePath = this.service === "s3" || this.request.doNotEncodePath, decodeSlashesInPath = this.service === "s3", firstValOnly = this.service === "s3", bodyHash;
      if (this.service === "s3" && this.request.signQuery) {
        bodyHash = "UNSIGNED-PAYLOAD";
      } else if (this.isCodeCommitGit) {
        bodyHash = "";
      } else {
        bodyHash = headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash2(this.request.body || "", "hex");
      }
      if (query) {
        var reducedQuery = Object.keys(query).reduce(function(obj, key) {
          if (!key)
            return obj;
          obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] : firstValOnly ? query[key][0] : query[key];
          return obj;
        }, {});
        var encodedQueryPieces = [];
        Object.keys(reducedQuery).sort().forEach(function(key) {
          if (!Array.isArray(reducedQuery[key])) {
            encodedQueryPieces.push(key + "=" + encodeRfc3986Full(reducedQuery[key]));
          } else {
            reducedQuery[key].map(encodeRfc3986Full).sort().forEach(function(val) {
              encodedQueryPieces.push(key + "=" + val);
            });
          }
        });
        queryStr = encodedQueryPieces.join("&");
      }
      if (pathStr !== "/") {
        if (normalizePath)
          pathStr = pathStr.replace(/\/{2,}/g, "/");
        pathStr = pathStr.split("/").reduce(function(path, piece) {
          if (normalizePath && piece === "..") {
            path.pop();
          } else if (!normalizePath || piece !== ".") {
            if (decodePath)
              piece = decodeURIComponent(piece).replace(/\+/g, " ");
            path.push(encodeRfc3986Full(piece));
          }
          return path;
        }, []).join("/");
        if (pathStr[0] !== "/")
          pathStr = "/" + pathStr;
        if (decodeSlashesInPath)
          pathStr = pathStr.replace(/%2F/g, "/");
      }
      return [
        this.request.method || "GET",
        pathStr,
        queryStr,
        this.canonicalHeaders() + "\n",
        this.signedHeaders(),
        bodyHash
      ].join("\n");
    };
    RequestSigner.prototype.canonicalHeaders = function() {
      var headers = this.request.headers;
      function trimAll(header) {
        return header.toString().trim().replace(/\s+/g, " ");
      }
      return Object.keys(headers).sort(function(a, b) {
        return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
      }).map(function(key) {
        return key.toLowerCase() + ":" + trimAll(headers[key]);
      }).join("\n");
    };
    RequestSigner.prototype.signedHeaders = function() {
      return Object.keys(this.request.headers).map(function(key) {
        return key.toLowerCase();
      }).sort().join(";");
    };
    RequestSigner.prototype.credentialString = function() {
      return [
        this.getDate(),
        this.region,
        this.service,
        "aws4_request"
      ].join("/");
    };
    RequestSigner.prototype.defaultCredentials = function() {
      var env = process.env;
      return {
        accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
        secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
        sessionToken: env.AWS_SESSION_TOKEN
      };
    };
    RequestSigner.prototype.parsePath = function() {
      var path = this.request.path || "/";
      if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path)) {
        path = encodeURI(decodeURI(path));
      }
      var queryIx = path.indexOf("?"), query = null;
      if (queryIx >= 0) {
        query = querystring.parse(path.slice(queryIx + 1));
        path = path.slice(0, queryIx);
      }
      this.parsedPath = {
        path,
        query
      };
    };
    RequestSigner.prototype.formatPath = function() {
      var path = this.parsedPath.path, query = this.parsedPath.query;
      if (!query)
        return path;
      if (query[""] != null)
        delete query[""];
      return path + "?" + encodeRfc3986(querystring.stringify(query));
    };
    aws4.RequestSigner = RequestSigner;
    aws4.sign = function(request, credentials) {
      return new RequestSigner(request, credentials).sign();
    };
  }
});

// node_modules/mongodb/lib/core/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongodb_aws.js"(exports2, module2) {
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCredentials = require_mongo_credentials().MongoCredentials;
    var MongoError = require_error().MongoError;
    var crypto = require("crypto");
    var http2 = require("http");
    var maxWireVersion = require_utils2().maxWireVersion;
    var url = require("url");
    var aws4;
    try {
      aws4 = require_aws4();
    } catch (e) {
    }
    var ASCII_N = 110;
    var AWS_RELATIVE_URI = "http://169.254.170.2";
    var AWS_EC2_URI = "http://169.254.169.254";
    var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
    var MongoDBAWS = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (maxWireVersion(connection) < 9) {
          callback(new MongoError("MONGODB-AWS authentication requires MongoDB version 4.4 or later"));
          return;
        }
        if (aws4 == null) {
          callback(new MongoError("MONGODB-AWS authentication requires the `aws4` module, please install it as a dependency of your project"));
          return;
        }
        if (credentials.username == null) {
          makeTempCredentials(credentials, (err, tempCredentials) => {
            if (err)
              return callback(err);
            authContext.credentials = tempCredentials;
            this.auth(authContext, callback);
          });
          return;
        }
        const username = credentials.username;
        const password = credentials.password;
        const db = credentials.source;
        const token = credentials.mechanismProperties.AWS_SESSION_TOKEN;
        const bson = this.bson;
        crypto.randomBytes(32, (err, nonce) => {
          if (err) {
            callback(err);
            return;
          }
          const saslStart = {
            saslStart: 1,
            mechanism: "MONGODB-AWS",
            payload: bson.serialize({r: nonce, p: ASCII_N})
          };
          connection.command(`${db}.$cmd`, saslStart, (err2, result) => {
            if (err2)
              return callback(err2);
            const res = result.result;
            const serverResponse = bson.deserialize(res.payload.buffer);
            const host = serverResponse.h;
            const serverNonce = serverResponse.s.buffer;
            if (serverNonce.length !== 64) {
              callback(new MongoError(`Invalid server nonce length ${serverNonce.length}, expected 64`));
              return;
            }
            if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
              callback(new MongoError("Server nonce does not begin with client nonce"));
              return;
            }
            if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
              callback(new MongoError(`Server returned an invalid host: "${host}"`));
              return;
            }
            const body = "Action=GetCallerIdentity&Version=2011-06-15";
            const options2 = aws4.sign({
              method: "POST",
              host,
              region: deriveRegion(serverResponse.h),
              service: "sts",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Content-Length": body.length,
                "X-MongoDB-Server-Nonce": serverNonce.toString("base64"),
                "X-MongoDB-GS2-CB-Flag": "n"
              },
              path: "/",
              body
            }, {
              accessKeyId: username,
              secretAccessKey: password,
              token
            });
            const authorization = options2.headers.Authorization;
            const date = options2.headers["X-Amz-Date"];
            const payload = {a: authorization, d: date};
            if (token) {
              payload.t = token;
            }
            const saslContinue = {
              saslContinue: 1,
              conversationId: 1,
              payload: bson.serialize(payload)
            };
            connection.command(`${db}.$cmd`, saslContinue, (err3) => {
              if (err3)
                return callback(err3);
              callback();
            });
          });
        });
      }
    };
    function makeTempCredentials(credentials, callback) {
      function done(creds) {
        if (creds.AccessKeyId == null || creds.SecretAccessKey == null || creds.Token == null) {
          callback(new MongoError("Could not obtain temporary MONGODB-AWS credentials"));
          return;
        }
        callback(void 0, new MongoCredentials({
          username: creds.AccessKeyId,
          password: creds.SecretAccessKey,
          source: credentials.source,
          mechanism: "MONGODB-AWS",
          mechanismProperties: {
            AWS_SESSION_TOKEN: creds.Token
          }
        }));
      }
      if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, (err, res) => {
          if (err)
            return callback(err);
          done(res);
        });
        return;
      }
      request(`${AWS_EC2_URI}/latest/api/token`, {method: "PUT", json: false, headers: {"X-aws-ec2-metadata-token-ttl-seconds": 30}}, (err, token) => {
        if (err)
          return callback(err);
        request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {json: false, headers: {"X-aws-ec2-metadata-token": token}}, (err2, roleName) => {
          if (err2)
            return callback(err2);
          request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {headers: {"X-aws-ec2-metadata-token": token}}, (err3, creds) => {
            if (err3)
              return callback(err3);
            done(creds);
          });
        });
      });
    }
    function deriveRegion(host) {
      const parts = host.split(".");
      if (parts.length === 1 || parts[1] === "amazonaws") {
        return "us-east-1";
      }
      return parts[1];
    }
    function request(uri, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = Object.assign({
        method: "GET",
        timeout: 1e4,
        json: true
      }, url.parse(uri), options2);
      const req = http2.request(options2, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d) => data += d);
        res.on("end", () => {
          if (options2.json === false) {
            callback(void 0, data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            callback(void 0, parsed);
          } catch (err) {
            callback(new MongoError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.on("error", (err) => callback(err));
      req.end();
    }
    module2.exports = MongoDBAWS;
  }
});

// node_modules/mongodb/lib/core/auth/defaultAuthProviders.js
var require_defaultAuthProviders = __commonJS({
  "node_modules/mongodb/lib/core/auth/defaultAuthProviders.js"(exports2, module2) {
    "use strict";
    var MongoCR = require_mongocr();
    var X509 = require_x509();
    var Plain = require_plain();
    var GSSAPI = require_gssapi();
    var ScramSHA1 = require_scram().ScramSHA1;
    var ScramSHA256 = require_scram().ScramSHA256;
    var MongoDBAWS = require_mongodb_aws();
    function defaultAuthProviders(bson) {
      return {
        "mongodb-aws": new MongoDBAWS(bson),
        mongocr: new MongoCR(bson),
        x509: new X509(bson),
        plain: new Plain(bson),
        gssapi: new GSSAPI(bson),
        "scram-sha-1": new ScramSHA1(bson),
        "scram-sha-256": new ScramSHA256(bson)
      };
    }
    module2.exports = {defaultAuthProviders};
  }
});

// node_modules/mongodb/lib/core/connection/connect.js
var require_connect = __commonJS({
  "node_modules/mongodb/lib/core/connection/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var Connection = require_connection();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var defaultAuthProviders = require_defaultAuthProviders().defaultAuthProviders;
    var AuthContext = require_auth_provider().AuthContext;
    var WIRE_CONSTANTS = require_constants();
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var AUTH_PROVIDERS;
    function connect(options2, cancellationToken, callback) {
      if (typeof cancellationToken === "function") {
        callback = cancellationToken;
        cancellationToken = void 0;
      }
      const ConnectionType = options2 && options2.connectionType ? options2.connectionType : Connection;
      if (AUTH_PROVIDERS == null) {
        AUTH_PROVIDERS = defaultAuthProviders(options2.bson);
      }
      const family = options2.family !== void 0 ? options2.family : 0;
      makeConnection(family, options2, cancellationToken, (err, socket) => {
        if (err) {
          callback(err, socket);
          return;
        }
        performInitialHandshake(new ConnectionType(socket, options2), options2, callback);
      });
    }
    function isModernConnectionType(conn) {
      return !(conn instanceof Connection);
    }
    function checkSupportedServer(ismaster, options2) {
      const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === "number" && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;
      const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === "number" && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;
      if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
          return null;
        }
        const message2 = `Server at ${options2.host}:${options2.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        return new MongoError(message2);
      }
      const message = `Server at ${options2.host}:${options2.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;
      return new MongoError(message);
    }
    function performInitialHandshake(conn, options2, _callback) {
      const callback = function(err, ret) {
        if (err && conn) {
          conn.destroy();
        }
        _callback(err, ret);
      };
      const credentials = options2.credentials;
      if (credentials) {
        if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {
          callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));
          return;
        }
      }
      const authContext = new AuthContext(conn, credentials, options2);
      prepareHandshakeDocument(authContext, (err, handshakeDoc) => {
        if (err) {
          return callback(err);
        }
        const handshakeOptions = Object.assign({}, options2);
        if (options2.connectTimeoutMS || options2.connectionTimeout) {
          handshakeOptions.socketTimeout = options2.connectTimeoutMS || options2.connectionTimeout;
        }
        const start = new Date().getTime();
        conn.command("admin.$cmd", handshakeDoc, handshakeOptions, (err2, result) => {
          if (err2) {
            callback(err2);
            return;
          }
          const response = result.result;
          if (response.ok === 0) {
            callback(new MongoError(response));
            return;
          }
          const supportedServerErr = checkSupportedServer(response, options2);
          if (supportedServerErr) {
            callback(supportedServerErr);
            return;
          }
          if (!isModernConnectionType(conn)) {
            if (response.compression) {
              const agreedCompressors = handshakeDoc.compression.filter((compressor) => response.compression.indexOf(compressor) !== -1);
              if (agreedCompressors.length) {
                conn.agreedCompressor = agreedCompressors[0];
              }
              if (options2.compression && options2.compression.zlibCompressionLevel) {
                conn.zlibCompressionLevel = options2.compression.zlibCompressionLevel;
              }
            }
          }
          conn.ismaster = response;
          conn.lastIsMasterMS = new Date().getTime() - start;
          if (!response.arbiterOnly && credentials) {
            Object.assign(authContext, {response});
            const resolvedCredentials = credentials.resolveAuthMechanism(response);
            const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];
            authProvider.auth(authContext, (err3) => {
              if (err3)
                return callback(err3);
              callback(void 0, conn);
            });
            return;
          }
          callback(void 0, conn);
        });
      });
    }
    function prepareHandshakeDocument(authContext, callback) {
      const options2 = authContext.options;
      const compressors = options2.compression && options2.compression.compressors ? options2.compression.compressors : [];
      const handshakeDoc = {
        ismaster: true,
        client: options2.metadata || makeClientMetadata(options2),
        compression: compressors
      };
      const credentials = authContext.credentials;
      if (credentials) {
        if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {
          Object.assign(handshakeDoc, {
            saslSupportedMechs: `${credentials.source}.${credentials.username}`
          });
          AUTH_PROVIDERS["scram-sha-256"].prepare(handshakeDoc, authContext, callback);
          return;
        }
        const authProvider = AUTH_PROVIDERS[credentials.mechanism];
        authProvider.prepare(handshakeDoc, authContext, callback);
        return;
      }
      callback(void 0, handshakeDoc);
    }
    var LEGAL_SSL_SOCKET_OPTIONS = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "NPNProtocols",
      "ALPNProtocols",
      "servername",
      "ecdhCurve",
      "secureProtocol",
      "secureContext",
      "session",
      "minDHSize",
      "crl",
      "rejectUnauthorized"
    ];
    function parseConnectOptions(family, options2) {
      const host = typeof options2.host === "string" ? options2.host : "localhost";
      if (host.indexOf("/") !== -1) {
        return {path: host};
      }
      const result = {
        family,
        host,
        port: typeof options2.port === "number" ? options2.port : 27017,
        rejectUnauthorized: false
      };
      return result;
    }
    function parseSslOptions(family, options2) {
      const result = parseConnectOptions(family, options2);
      for (const name in options2) {
        if (options2[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {
          result[name] = options2[name];
        }
      }
      if (options2.checkServerIdentity === false) {
        result.checkServerIdentity = function() {
          return void 0;
        };
      } else if (typeof options2.checkServerIdentity === "function") {
        result.checkServerIdentity = options2.checkServerIdentity;
      }
      if (result.servername == null && !net.isIP(result.host)) {
        result.servername = result.host;
      }
      return result;
    }
    var SOCKET_ERROR_EVENTS = new Set(["error", "close", "timeout", "parseError"]);
    function makeConnection(family, options2, cancellationToken, _callback) {
      const useSsl = typeof options2.ssl === "boolean" ? options2.ssl : false;
      const keepAlive = typeof options2.keepAlive === "boolean" ? options2.keepAlive : true;
      let keepAliveInitialDelay = typeof options2.keepAliveInitialDelay === "number" ? options2.keepAliveInitialDelay : 12e4;
      const noDelay = typeof options2.noDelay === "boolean" ? options2.noDelay : true;
      const connectionTimeout = typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : typeof options2.connectTimeoutMS === "number" ? options2.connectTimeoutMS : 3e4;
      const socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
      const rejectUnauthorized = typeof options2.rejectUnauthorized === "boolean" ? options2.rejectUnauthorized : true;
      if (keepAliveInitialDelay > socketTimeout) {
        keepAliveInitialDelay = Math.round(socketTimeout / 2);
      }
      let socket;
      const callback = function(err, ret) {
        if (err && socket) {
          socket.destroy();
        }
        _callback(err, ret);
      };
      try {
        if (useSsl) {
          socket = tls.connect(parseSslOptions(family, options2));
          if (typeof socket.disableRenegotiation === "function") {
            socket.disableRenegotiation();
          }
        } else {
          socket = net.createConnection(parseConnectOptions(family, options2));
        }
      } catch (err) {
        return callback(err);
      }
      socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
      socket.setTimeout(connectionTimeout);
      socket.setNoDelay(noDelay);
      const connectEvent = useSsl ? "secureConnect" : "connect";
      let cancellationHandler;
      function errorHandler(eventName) {
        return (err) => {
          SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
          if (cancellationHandler) {
            cancellationToken.removeListener("cancel", cancellationHandler);
          }
          socket.removeListener(connectEvent, connectHandler);
          callback(connectionFailureError(eventName, err));
        };
      }
      function connectHandler() {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler) {
          cancellationToken.removeListener("cancel", cancellationHandler);
        }
        if (socket.authorizationError && rejectUnauthorized) {
          return callback(socket.authorizationError);
        }
        socket.setTimeout(socketTimeout);
        callback(null, socket);
      }
      SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
      if (cancellationToken) {
        cancellationHandler = errorHandler("cancel");
        cancellationToken.once("cancel", cancellationHandler);
      }
      socket.once(connectEvent, connectHandler);
    }
    function connectionFailureError(type, err) {
      switch (type) {
        case "error":
          return new MongoNetworkError(err);
        case "timeout":
          return new MongoNetworkTimeoutError(`connection timed out`);
        case "close":
          return new MongoNetworkError(`connection closed`);
        case "cancel":
          return new MongoNetworkError(`connection establishment was cancelled`);
        default:
          return new MongoNetworkError(`unknown network error`);
      }
    }
    module2.exports = connect;
  }
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS({
  "node_modules/mongodb/lib/read_concern.js"(exports2, module2) {
    "use strict";
    var ReadConcern = class {
      constructor(level) {
        if (level != null) {
          this.level = level;
        }
      }
      static fromOptions(options2) {
        if (options2 == null) {
          return;
        }
        if (options2.readConcern) {
          if (options2.readConcern instanceof ReadConcern) {
            return options2.readConcern;
          }
          return new ReadConcern(options2.readConcern.level);
        }
        if (options2.level) {
          return new ReadConcern(options2.level);
        }
      }
      static get MAJORITY() {
        return "majority";
      }
      static get AVAILABLE() {
        return "available";
      }
      static get LINEARIZABLE() {
        return "linearizable";
      }
      static get SNAPSHOT() {
        return "snapshot";
      }
    };
    module2.exports = ReadConcern;
  }
});

// node_modules/mongodb/lib/core/transactions.js
var require_transactions = __commonJS({
  "node_modules/mongodb/lib/core/transactions.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var ReadPreference = require_read_preference();
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var TxnState;
    var stateMachine;
    (() => {
      const NO_TRANSACTION = "NO_TRANSACTION";
      const STARTING_TRANSACTION = "STARTING_TRANSACTION";
      const TRANSACTION_IN_PROGRESS = "TRANSACTION_IN_PROGRESS";
      const TRANSACTION_COMMITTED = "TRANSACTION_COMMITTED";
      const TRANSACTION_COMMITTED_EMPTY = "TRANSACTION_COMMITTED_EMPTY";
      const TRANSACTION_ABORTED = "TRANSACTION_ABORTED";
      TxnState = {
        NO_TRANSACTION,
        STARTING_TRANSACTION,
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        TRANSACTION_ABORTED
      };
      stateMachine = {
        [NO_TRANSACTION]: [NO_TRANSACTION, STARTING_TRANSACTION],
        [STARTING_TRANSACTION]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_IN_PROGRESS]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_COMMITTED]: [
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          STARTING_TRANSACTION,
          NO_TRANSACTION
        ],
        [TRANSACTION_ABORTED]: [STARTING_TRANSACTION, NO_TRANSACTION],
        [TRANSACTION_COMMITTED_EMPTY]: [TRANSACTION_COMMITTED_EMPTY, NO_TRANSACTION]
      };
    })();
    var Transaction = class {
      constructor(options2) {
        options2 = options2 || {};
        this.state = TxnState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = WriteConcern.fromOptions(options2);
        if (writeConcern) {
          if (writeConcern.w <= 0) {
            throw new MongoError("Transactions do not support unacknowledged write concern");
          }
          this.options.writeConcern = writeConcern;
        }
        if (options2.readConcern) {
          this.options.readConcern = ReadConcern.fromOptions(options2);
        }
        if (options2.readPreference) {
          this.options.readPreference = ReadPreference.fromOptions(options2);
        }
        if (options2.maxCommitTimeMS) {
          this.options.maxTimeMS = options2.maxCommitTimeMS;
        }
        this._pinnedServer = void 0;
        this._recoveryToken = void 0;
      }
      get server() {
        return this._pinnedServer;
      }
      get recoveryToken() {
        return this._recoveryToken;
      }
      get isPinned() {
        return !!this.server;
      }
      get isActive() {
        return [TxnState.STARTING_TRANSACTION, TxnState.TRANSACTION_IN_PROGRESS].indexOf(this.state) !== -1;
      }
      transition(nextState) {
        const nextStates = stateMachine[this.state];
        if (nextStates && nextStates.indexOf(nextState) !== -1) {
          this.state = nextState;
          if (this.state === TxnState.NO_TRANSACTION || this.state === TxnState.STARTING_TRANSACTION) {
            this.unpinServer();
          }
          return;
        }
        throw new MongoError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
      }
      pinServer(server) {
        if (this.isActive) {
          this._pinnedServer = server;
        }
      }
      unpinServer() {
        this._pinnedServer = void 0;
      }
    };
    function isTransactionCommand(command) {
      return !!(command.commitTransaction || command.abortTransaction);
    }
    module2.exports = {TxnState, Transaction, isTransactionCommand};
  }
});

// node_modules/mongodb/lib/core/topologies/shared.js
var require_shared2 = __commonJS({
  "node_modules/mongodb/lib/core/topologies/shared.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_read_preference();
    var TopologyType = require_common().TopologyType;
    var MongoError = require_error().MongoError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MMAPv1_RETRY_WRITES_ERROR_CODE = 20;
    function emitSDAMEvent(self, event, description) {
      if (self.listeners(event).length > 0) {
        self.emit(event, description);
      }
    }
    function createCompressionInfo(options2) {
      if (!options2.compression || !options2.compression.compressors) {
        return [];
      }
      options2.compression.compressors.forEach(function(compressor) {
        if (compressor !== "snappy" && compressor !== "zlib") {
          throw new Error("compressors must be at least one of snappy or zlib");
        }
      });
      return options2.compression.compressors;
    }
    function clone2(object) {
      return JSON.parse(JSON.stringify(object));
    }
    var getPreviousDescription = function(self) {
      if (!self.s.serverDescription) {
        self.s.serverDescription = {
          address: self.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: "Unknown"
        };
      }
      return self.s.serverDescription;
    };
    var emitServerDescriptionChanged = function(self, description) {
      if (self.listeners("serverDescriptionChanged").length > 0) {
        self.emit("serverDescriptionChanged", {
          topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,
          address: self.name,
          previousDescription: getPreviousDescription(self),
          newDescription: description
        });
        self.s.serverDescription = description;
      }
    };
    var getPreviousTopologyDescription = function(self) {
      if (!self.s.topologyDescription) {
        self.s.topologyDescription = {
          topologyType: "Unknown",
          servers: [
            {
              address: self.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            }
          ]
        };
      }
      return self.s.topologyDescription;
    };
    var emitTopologyDescriptionChanged = function(self, description) {
      if (self.listeners("topologyDescriptionChanged").length > 0) {
        self.emit("topologyDescriptionChanged", {
          topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,
          address: self.name,
          previousDescription: getPreviousTopologyDescription(self),
          newDescription: description
        });
        self.s.serverDescription = description;
      }
    };
    var changedIsMaster = function(self, currentIsmaster, ismaster) {
      var currentType = getTopologyType(self, currentIsmaster);
      var newType = getTopologyType(self, ismaster);
      if (newType !== currentType)
        return true;
      return false;
    };
    var getTopologyType = function(self, ismaster) {
      if (!ismaster) {
        ismaster = self.ismaster;
      }
      if (!ismaster)
        return "Unknown";
      if (ismaster.ismaster && ismaster.msg === "isdbgrid")
        return "Mongos";
      if (ismaster.ismaster && !ismaster.hosts)
        return "Standalone";
      if (ismaster.ismaster)
        return "RSPrimary";
      if (ismaster.secondary)
        return "RSSecondary";
      if (ismaster.arbiterOnly)
        return "RSArbiter";
      return "Unknown";
    };
    var inquireServerState = function(self) {
      return function(callback) {
        if (self.s.state === "destroyed")
          return;
        var start = new Date().getTime();
        emitSDAMEvent(self, "serverHeartbeatStarted", {connectionId: self.name});
        self.command("admin.$cmd", {ismaster: true}, {monitoring: true}, function(err, r) {
          if (!err) {
            self.emit("ismaster", r, self);
            var latencyMS = new Date().getTime() - start;
            emitSDAMEvent(self, "serverHeartbeatSucceeded", {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: self.name
            });
            if (changedIsMaster(self, self.s.ismaster, r.result)) {
              emitServerDescriptionChanged(self, {
                address: self.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: !self.s.inTopology ? "Standalone" : getTopologyType(self)
              });
            }
            self.s.ismaster = r.result;
            self.s.isMasterLatencyMS = latencyMS;
          } else {
            emitSDAMEvent(self, "serverHeartbeatFailed", {
              durationMS: latencyMS,
              failure: err,
              connectionId: self.name
            });
          }
          if (typeof callback === "function") {
            return callback(err, r);
          }
          self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);
        });
      };
    };
    var cloneOptions = function(options2) {
      var opts = {};
      for (var name in options2) {
        opts[name] = options2[name];
      }
      return opts;
    };
    function Interval(fn, time) {
      var timer = false;
      this.start = function() {
        if (!this.isRunning()) {
          timer = setInterval(fn, time);
        }
        return this;
      };
      this.stop = function() {
        clearInterval(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function Timeout(fn, time) {
      var timer = false;
      var func = () => {
        if (timer) {
          clearTimeout(timer);
          timer = false;
          fn();
        }
      };
      this.start = function() {
        if (!this.isRunning()) {
          timer = setTimeout(func, time);
        }
        return this;
      };
      this.stop = function() {
        clearTimeout(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function diff(previous, current) {
      var diff2 = {
        servers: []
      };
      if (!previous) {
        previous = {servers: []};
      }
      for (var i = 0; i < previous.servers.length; i++) {
        var found = false;
        for (var j = 0; j < current.servers.length; j++) {
          if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: previous.servers[i].address,
            from: previous.servers[i].type,
            to: "Unknown"
          });
        }
      }
      for (j = 0; j < current.servers.length; j++) {
        found = false;
        for (i = 0; i < previous.servers.length; i++) {
          if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: current.servers[j].address,
            from: "Unknown",
            to: current.servers[j].type
          });
        }
      }
      for (i = 0; i < previous.servers.length; i++) {
        var prevServer = previous.servers[i];
        for (j = 0; j < current.servers.length; j++) {
          var currServer = current.servers[j];
          if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {
            if (prevServer.type !== currServer.type) {
              diff2.servers.push({
                address: prevServer.address,
                from: prevServer.type,
                to: currServer.type
              });
            }
          }
        }
      }
      return diff2;
    }
    function resolveClusterTime(topology, $clusterTime) {
      if (topology.clusterTime == null) {
        topology.clusterTime = $clusterTime;
      } else {
        if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {
          topology.clusterTime = $clusterTime;
        }
      }
    }
    var SessionMixins = {
      endSessions: function(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", {endSessions: sessions}, {readPreference: ReadPreference.primaryPreferred}, () => {
          if (typeof callback === "function")
            callback();
        });
      }
    };
    function topologyType(topology) {
      if (topology.description) {
        return topology.description.type;
      }
      if (topology.type === "mongos") {
        return TopologyType.Sharded;
      } else if (topology.type === "replset") {
        return TopologyType.ReplicaSetWithPrimary;
      }
      return TopologyType.Single;
    }
    var RETRYABLE_WIRE_VERSION = 6;
    var isRetryableWritesSupported = function(topology) {
      const maxWireVersion2 = topology.lastIsMaster().maxWireVersion;
      if (maxWireVersion2 < RETRYABLE_WIRE_VERSION) {
        return false;
      }
      if (!topology.logicalSessionTimeoutMinutes) {
        return false;
      }
      if (topologyType(topology) === TopologyType.Single) {
        return false;
      }
      return true;
    };
    var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
    function getMMAPError(err) {
      if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes("Transaction numbers")) {
        return err;
      }
      const newErr = new MongoError({
        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        originalError: err
      });
      return newErr;
    }
    function legacyIsRetryableWriteError(err, topology) {
      if (!(err instanceof MongoError)) {
        return false;
      }
      if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {
        err.addErrorLabel("RetryableWriteError");
      }
      return err.hasErrorLabel("RetryableWriteError");
    }
    module2.exports = {
      SessionMixins,
      resolveClusterTime,
      inquireServerState,
      getTopologyType,
      emitServerDescriptionChanged,
      emitTopologyDescriptionChanged,
      cloneOptions,
      createCompressionInfo,
      clone: clone2,
      diff,
      Interval,
      Timeout,
      isRetryableWritesSupported,
      getMMAPError,
      topologyType,
      legacyIsRetryableWriteError
    };
  }
});

// node_modules/mongodb/lib/core/sessions.js
var require_sessions = __commonJS({
  "node_modules/mongodb/lib/core/sessions.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var EventEmitter = require("events");
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var uuidV4 = require_utils2().uuidV4;
    var MongoError = require_error().MongoError;
    var isRetryableError = require_error().isRetryableError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Transaction = require_transactions().Transaction;
    var TxnState = require_transactions().TxnState;
    var isPromiseLike = require_utils2().isPromiseLike;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils4().maybePromise;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils2().maxWireVersion;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var minWireVersionForShardedTransactions = 8;
    function assertAlive(session, callback) {
      if (session.serverSession == null) {
        const error3 = new MongoError("Cannot use a session that has ended");
        if (typeof callback === "function") {
          callback(error3, null);
          return false;
        }
        throw error3;
      }
      return true;
    }
    var kServerSession = Symbol("serverSession");
    var ClientSession = class extends EventEmitter {
      constructor(topology, sessionPool, options2, clientOptions) {
        super();
        if (topology == null) {
          throw new Error("ClientSession requires a topology");
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
          throw new Error("ClientSession requires a ServerSessionPool");
        }
        options2 = options2 || {};
        clientOptions = clientOptions || {};
        this.topology = topology;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this[kServerSession] = void 0;
        this.supports = {
          causalConsistency: typeof options2.causalConsistency !== "undefined" ? options2.causalConsistency : true
        };
        this.clusterTime = options2.initialClusterTime;
        this.operationTime = null;
        this.explicit = !!options2.explicit;
        this.owner = options2.owner;
        this.defaultTransactionOptions = Object.assign({}, options2.defaultTransactionOptions);
        this.transaction = new Transaction();
      }
      get id() {
        return this.serverSession.id;
      }
      get serverSession() {
        if (this[kServerSession] == null) {
          this[kServerSession] = this.sessionPool.acquire();
        }
        return this[kServerSession];
      }
      endSession(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        const session = this;
        return maybePromise(this, callback, (done) => {
          if (session.hasEnded) {
            return done();
          }
          function completeEndSession() {
            session.sessionPool.release(session.serverSession);
            session[kServerSession] = void 0;
            session.hasEnded = true;
            session.emit("ended", session);
            done();
          }
          if (session.serverSession && session.inTransaction()) {
            session.abortTransaction((err) => {
              if (err)
                return done(err);
              completeEndSession();
            });
            return;
          }
          completeEndSession();
        });
      }
      advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
          this.operationTime = operationTime;
          return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
          this.operationTime = operationTime;
        }
      }
      equals(session) {
        if (!(session instanceof ClientSession)) {
          return false;
        }
        return this.id.id.buffer.equals(session.id.id.buffer);
      }
      incrementTransactionNumber() {
        this.serverSession.txnNumber++;
      }
      inTransaction() {
        return this.transaction.isActive;
      }
      startTransaction(options2) {
        assertAlive(this);
        if (this.inTransaction()) {
          throw new MongoError("Transaction already in progress");
        }
        const topologyMaxWireVersion = maxWireVersion(this.topology);
        if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
          throw new MongoError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
        }
        this.incrementTransactionNumber();
        this.transaction = new Transaction(Object.assign({}, this.clientOptions, options2 || this.defaultTransactionOptions));
        this.transaction.transition(TxnState.STARTING_TRANSACTION);
      }
      commitTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "commitTransaction", done));
      }
      abortTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "abortTransaction", done));
      }
      toBSON() {
        throw new Error("ClientSession cannot be serialized to BSON.");
      }
      withTransaction(fn, options2) {
        const startTime = now();
        return attemptTransaction(this, startTime, fn, options2);
      }
    };
    var MAX_WITH_TRANSACTION_TIMEOUT = 12e4;
    var UNSATISFIABLE_WRITE_CONCERN_CODE = 100;
    var UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;
    var MAX_TIME_MS_EXPIRED_CODE = 50;
    var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
      "CannotSatisfyWriteConcern",
      "UnknownReplWriteConcern",
      "UnsatisfiableWriteConcern"
    ]);
    function hasNotTimedOut(startTime, max) {
      return calculateDurationInMs(startTime) < max;
    }
    function isUnknownTransactionCommitResult(err) {
      return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;
    }
    function isMaxTimeMSExpiredError(err) {
      if (err == null)
        return false;
      return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;
    }
    function attemptTransactionCommit(session, startTime, fn, options2) {
      return session.commitTransaction().catch((err) => {
        if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
          if (err.hasErrorLabel("UnknownTransactionCommitResult")) {
            return attemptTransactionCommit(session, startTime, fn, options2);
          }
          if (err.hasErrorLabel("TransientTransactionError")) {
            return attemptTransaction(session, startTime, fn, options2);
          }
        }
        throw err;
      });
    }
    var USER_EXPLICIT_TXN_END_STATES = new Set([
      TxnState.NO_TRANSACTION,
      TxnState.TRANSACTION_COMMITTED,
      TxnState.TRANSACTION_ABORTED
    ]);
    function userExplicitlyEndedTransaction(session) {
      return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
    }
    function attemptTransaction(session, startTime, fn, options2) {
      session.startTransaction(options2);
      let promise;
      try {
        promise = fn(session);
      } catch (err) {
        promise = Promise.reject(err);
      }
      if (!isPromiseLike(promise)) {
        session.abortTransaction();
        throw new TypeError("Function provided to `withTransaction` must return a Promise");
      }
      return promise.then(() => {
        if (userExplicitlyEndedTransaction(session)) {
          return;
        }
        return attemptTransactionCommit(session, startTime, fn, options2);
      }).catch((err) => {
        function maybeRetryOrThrow(err2) {
          if (err2 instanceof MongoError && err2.hasErrorLabel("TransientTransactionError") && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
            return attemptTransaction(session, startTime, fn, options2);
          }
          if (isMaxTimeMSExpiredError(err2)) {
            err2.addErrorLabel("UnknownTransactionCommitResult");
          }
          throw err2;
        }
        if (session.transaction.isActive) {
          return session.abortTransaction().then(() => maybeRetryOrThrow(err));
        }
        return maybeRetryOrThrow(err);
      });
    }
    function endTransaction(session, commandName, callback) {
      if (!assertAlive(session, callback)) {
        return;
      }
      let txnState = session.transaction.state;
      if (txnState === TxnState.NO_TRANSACTION) {
        callback(new MongoError("No transaction started"));
        return;
      }
      if (commandName === "commitTransaction") {
        if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call commitTransaction after calling abortTransaction"));
          return;
        }
      } else {
        if (txnState === TxnState.STARTING_TRANSACTION) {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call abortTransaction twice"));
          return;
        }
        if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          callback(new MongoError("Cannot call abortTransaction after calling commitTransaction"));
          return;
        }
      }
      const command = {[commandName]: 1};
      let writeConcern;
      if (session.transaction.options.writeConcern) {
        writeConcern = Object.assign({}, session.transaction.options.writeConcern);
      } else if (session.clientOptions && session.clientOptions.w) {
        writeConcern = {w: session.clientOptions.w};
      }
      if (txnState === TxnState.TRANSACTION_COMMITTED) {
        writeConcern = Object.assign({wtimeout: 1e4}, writeConcern, {w: "majority"});
      }
      if (writeConcern) {
        Object.assign(command, {writeConcern});
      }
      if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
        Object.assign(command, {maxTimeMS: session.transaction.options.maxTimeMS});
      }
      function commandHandler(e, r) {
        if (commandName === "commitTransaction") {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED);
          if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {
            if (isUnknownTransactionCommitResult(e)) {
              e.addErrorLabel("UnknownTransactionCommitResult");
              session.transaction.unpinServer();
            }
          }
        } else {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
        }
        callback(e, r);
      }
      function transactionError(err) {
        return commandName === "commitTransaction" ? err : null;
      }
      if (session.transaction.recoveryToken && supportsRecoveryToken(session)) {
        command.recoveryToken = session.transaction.recoveryToken;
      }
      session.topology.command("admin.$cmd", command, {session}, (err, reply) => {
        if (err && isRetryableError(err)) {
          if (command.commitTransaction) {
            session.transaction.unpinServer();
            command.writeConcern = Object.assign({wtimeout: 1e4}, command.writeConcern, {
              w: "majority"
            });
          }
          return session.topology.command("admin.$cmd", command, {session}, (_err, _reply) => commandHandler(transactionError(_err), _reply));
        }
        commandHandler(transactionError(err), reply);
      });
    }
    function supportsRecoveryToken(session) {
      const topology = session.topology;
      return !!topology.s.options.useRecoveryToken;
    }
    var ServerSession = class {
      constructor() {
        this.id = {id: new Binary2(uuidV4(), Binary2.SUBTYPE_UUID)};
        this.lastUse = now();
        this.txnNumber = 0;
        this.isDirty = false;
      }
      hasTimedOut(sessionTimeoutMinutes) {
        const idleTimeMinutes = Math.round(calculateDurationInMs(this.lastUse) % 864e5 % 36e5 / 6e4);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
      }
    };
    var ServerSessionPool = class {
      constructor(topology) {
        if (topology == null) {
          throw new Error("ServerSessionPool requires a topology");
        }
        this.topology = topology;
        this.sessions = [];
      }
      endAllPooledSessions(callback) {
        if (this.sessions.length) {
          this.topology.endSessions(this.sessions.map((session) => session.id), () => {
            this.sessions = [];
            if (typeof callback === "function") {
              callback();
            }
          });
          return;
        }
        if (typeof callback === "function") {
          callback();
        }
      }
      acquire() {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const session = this.sessions.shift();
          if (!session.hasTimedOut(sessionTimeoutMinutes)) {
            return session;
          }
        }
        return new ServerSession();
      }
      release(session) {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const pooledSession = this.sessions[this.sessions.length - 1];
          if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
            this.sessions.pop();
          } else {
            break;
          }
        }
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          if (session.isDirty) {
            return;
          }
          this.sessions.unshift(session);
        }
      }
    };
    function commandSupportsReadConcern(command, options2) {
      if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {
        return true;
      }
      if (command.mapReduce && options2 && options2.out && (options2.out.inline === 1 || options2.out === "inline")) {
        return true;
      }
      return false;
    }
    function applySession(session, command, options2) {
      if (session.hasEnded) {
        return new MongoError("Cannot use a session that has ended");
      }
      if (options2 && options2.writeConcern && options2.writeConcern.w === 0) {
        return;
      }
      const serverSession = session.serverSession;
      serverSession.lastUse = now();
      command.lsid = serverSession.id;
      const inTransaction = session.inTransaction() || isTransactionCommand(command);
      const isRetryableWrite = options2.willRetryWrite;
      const shouldApplyReadConcern = commandSupportsReadConcern(command, options2);
      if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {
        command.txnNumber = BSON2.Long.fromNumber(serverSession.txnNumber);
      }
      if (!inTransaction) {
        if (session.transaction.state !== TxnState.NO_TRANSACTION) {
          session.transaction.transition(TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, {afterClusterTime: session.operationTime});
        }
        return;
      }
      if (options2.readPreference && !options2.readPreference.equals(ReadPreference.primary)) {
        return new MongoError(`Read preference in a transaction must be primary, not: ${options2.readPreference.mode}`);
      }
      command.autocommit = false;
      if (session.transaction.state === TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;
        if (readConcern) {
          command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, {afterClusterTime: session.operationTime});
        }
      }
    }
    function updateSessionFromResponse(session, document2) {
      if (document2.$clusterTime) {
        resolveClusterTime(session, document2.$clusterTime);
      }
      if (document2.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document2.operationTime);
      }
      if (document2.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document2.recoveryToken;
      }
    }
    module2.exports = {
      ClientSession,
      ServerSession,
      ServerSessionPool,
      TxnState,
      applySession,
      updateSessionFromResponse,
      commandSupportsReadConcern
    };
  }
});

// node_modules/mongodb/lib/core/connection/pool.js
var require_pool = __commonJS({
  "node_modules/mongodb/lib/core/connection/pool.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var EventEmitter = require("events").EventEmitter;
    var MongoError = require_error().MongoError;
    var MongoTimeoutError = require_error().MongoTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Logger = require_logger();
    var f = require("util").format;
    var Msg = require_msg().Msg;
    var CommandResult = require_command_result();
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var apm = require_apm();
    var Buffer2 = require_safe_buffer().Buffer;
    var connect = require_connect();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var eachAsync = require_utils2().eachAsync;
    var makeStateMachine = require_utils2().makeStateMachine;
    var now = require_utils4().now;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var DRAINING = "draining";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    var stateTransition = makeStateMachine({
      [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],
      [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],
      [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],
      [DRAINING]: [DRAINING, DESTROYING, DESTROYED],
      [DESTROYING]: [DESTROYING, DESTROYED],
      [DESTROYED]: [DESTROYED]
    });
    var CONNECTION_EVENTS = new Set([
      "error",
      "close",
      "timeout",
      "parseError",
      "connect",
      "message"
    ]);
    var _id = 0;
    var Pool = function(topology, options2) {
      EventEmitter.call(this);
      this.topology = topology;
      this.s = {
        state: DISCONNECTED,
        cancellationToken: new EventEmitter()
      };
      this.s.cancellationToken.setMaxListeners(Infinity);
      this.options = Object.assign({
        host: "localhost",
        port: 27017,
        size: 5,
        minSize: 0,
        connectionTimeout: 3e4,
        socketTimeout: 0,
        keepAlive: true,
        keepAliveInitialDelay: 12e4,
        noDelay: true,
        ssl: false,
        checkServerIdentity: true,
        ca: null,
        crl: null,
        cert: null,
        key: null,
        passphrase: null,
        rejectUnauthorized: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        reconnect: true,
        reconnectInterval: 1e3,
        reconnectTries: 30,
        domainsEnabled: false,
        legacyCompatMode: true
      }, options2);
      this.id = _id++;
      this.retriesLeft = this.options.reconnectTries;
      this.reconnectId = null;
      this.reconnectError = null;
      if (!options2.bson || options2.bson && (typeof options2.bson.serialize !== "function" || typeof options2.bson.deserialize !== "function")) {
        throw new Error("must pass in valid bson parser");
      }
      this.logger = Logger("Pool", options2);
      this.availableConnections = [];
      this.inUseConnections = [];
      this.connectingConnections = 0;
      this.executing = false;
      this.queue = [];
      this.numberOfConsecutiveTimeouts = 0;
      this.connectionIndex = 0;
      const pool = this;
      this._messageHandler = messageHandler(this);
      this._connectionCloseHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "close", err, connection);
      };
      this._connectionErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "error", err, connection);
      };
      this._connectionTimeoutHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "timeout", err, connection);
      };
      this._connectionParseErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "parseError", err, connection);
      };
    };
    inherits(Pool, EventEmitter);
    Object.defineProperty(Pool.prototype, "size", {
      enumerable: true,
      get: function() {
        return this.options.size;
      }
    });
    Object.defineProperty(Pool.prototype, "minSize", {
      enumerable: true,
      get: function() {
        return this.options.minSize;
      }
    });
    Object.defineProperty(Pool.prototype, "connectionTimeout", {
      enumerable: true,
      get: function() {
        return this.options.connectionTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "socketTimeout", {
      enumerable: true,
      get: function() {
        return this.options.socketTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "state", {
      enumerable: true,
      get: function() {
        return this.s.state;
      }
    });
    function resetPoolState(pool) {
      pool.inUseConnections = [];
      pool.availableConnections = [];
      pool.connectingConnections = 0;
      pool.executing = false;
      pool.numberOfConsecutiveTimeouts = 0;
      pool.connectionIndex = 0;
      pool.retriesLeft = pool.options.reconnectTries;
      pool.reconnectId = null;
    }
    function connectionFailureHandler(pool, event, err, conn) {
      if (conn) {
        if (conn._connectionFailHandled) {
          return;
        }
        conn._connectionFailHandled = true;
        conn.destroy();
        removeConnection(pool, conn);
        conn.flush(err);
      }
      if (event === "timeout") {
        pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;
        if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {
          pool.numberOfConsecutiveTimeouts = 0;
          pool.destroy(true);
          return pool.emit("close", pool);
        }
      }
      if (pool.socketCount() === 0) {
        if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {
          if (pool.options.reconnect) {
            stateTransition(pool, DISCONNECTED);
          }
        }
        event = event === "error" ? "close" : event;
        pool.emit(event, err);
      }
      if (!pool.reconnectId && pool.options.reconnect) {
        pool.reconnectError = err;
        pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);
      }
      const totalConnections = totalConnectionCount(pool);
      if (totalConnections < pool.minSize) {
        createConnection(pool);
      }
    }
    function attemptReconnect(pool, callback) {
      return function() {
        pool.emit("attemptReconnect", pool);
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Cannot create connection when pool is destroyed"));
          }
          return;
        }
        pool.retriesLeft = pool.retriesLeft - 1;
        if (pool.retriesLeft <= 0) {
          pool.destroy();
          const error3 = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);
          pool.emit("reconnectFailed", error3);
          if (typeof callback === "function") {
            callback(error3);
          }
          return;
        }
        pool.reconnectId = null;
        createConnection(pool, (err, conn) => {
          if (err == null) {
            pool.reconnectId = null;
            pool.retriesLeft = pool.options.reconnectTries;
            pool.emit("reconnect", pool);
          }
          if (typeof callback === "function") {
            callback(err, conn);
          }
        });
      };
    }
    function moveConnectionBetween(connection, from, to) {
      var index2 = from.indexOf(connection);
      if (index2 !== -1) {
        from.splice(index2, 1);
        to.push(connection);
      }
    }
    function messageHandler(self) {
      return function(message, connection) {
        var workItem = null;
        for (var i = 0; i < connection.workItems.length; i++) {
          if (connection.workItems[i].requestId === message.responseTo) {
            workItem = connection.workItems[i];
            connection.workItems.splice(i, 1);
          }
        }
        if (workItem && workItem.monitoring) {
          moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);
        }
        self.numberOfConsecutiveTimeouts = 0;
        if (workItem && workItem.socketTimeout) {
          connection.resetSocketTimeout();
        }
        if (self.logger.isDebug()) {
          self.logger.debug(f("message [%s] received from %s:%s", message.raw.toString("hex"), self.options.host, self.options.port));
        }
        function handleOperationCallback(self2, cb, err, result) {
          if (!self2.options.domainsEnabled) {
            return process.nextTick(function() {
              return cb(err, result);
            });
          }
          cb(err, result);
        }
        if (!self.executing) {
          process.nextTick(function() {
            _execute(self)();
          });
        }
        if (workItem && !workItem.immediateRelease) {
          try {
            message.parse(workItem);
          } catch (err) {
            return handleOperationCallback(self, workItem.cb, new MongoError(err));
          }
          if (message.documents[0]) {
            const document2 = message.documents[0];
            const session = workItem.session;
            if (session) {
              updateSessionFromResponse(session, document2);
            }
            if (self.topology && document2.$clusterTime) {
              self.topology.clusterTime = document2.$clusterTime;
            }
          }
          if (workItem.command && message.documents[0]) {
            const responseDoc = message.documents[0];
            if (responseDoc.writeConcernError) {
              const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);
              return handleOperationCallback(self, workItem.cb, err);
            }
            if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {
              return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));
            }
          }
          message.hashedName = connection.hashedName;
          handleOperationCallback(self, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));
        }
      };
    }
    Pool.prototype.socketCount = function() {
      return this.availableConnections.length + this.inUseConnections.length;
    };
    function totalConnectionCount(pool) {
      return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;
    }
    Pool.prototype.allConnections = function() {
      return this.availableConnections.concat(this.inUseConnections);
    };
    Pool.prototype.get = function() {
      return this.allConnections()[0];
    };
    Pool.prototype.isConnected = function() {
      if (this.state === DESTROYED || this.state === DESTROYING) {
        return false;
      }
      var connections = this.availableConnections.concat(this.inUseConnections);
      for (var i = 0; i < connections.length; i++) {
        if (connections[i].isConnected())
          return true;
      }
      return false;
    };
    Pool.prototype.isDestroyed = function() {
      return this.state === DESTROYED || this.state === DESTROYING;
    };
    Pool.prototype.isDisconnected = function() {
      return this.state === DISCONNECTED;
    };
    Pool.prototype.connect = function(callback) {
      if (this.state !== DISCONNECTED) {
        throw new MongoError("connection in unlawful state " + this.state);
      }
      stateTransition(this, CONNECTING);
      createConnection(this, (err, conn) => {
        if (err) {
          if (typeof callback === "function") {
            this.destroy();
            callback(err);
            return;
          }
          if (this.state === CONNECTING) {
            this.emit("error", err);
          }
          this.destroy();
          return;
        }
        stateTransition(this, CONNECTED);
        if (this.minSize) {
          for (let i = 0; i < this.minSize; i++) {
            createConnection(this);
          }
        }
        if (typeof callback === "function") {
          callback(null, conn);
        } else {
          this.emit("connect", this, conn);
        }
      });
    };
    Pool.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.logout = function(dbName, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.unref = function() {
      var connections = this.availableConnections.concat(this.inUseConnections);
      connections.forEach(function(c) {
        c.unref();
      });
    };
    function destroy(self, connections, options2, callback) {
      stateTransition(self, DESTROYING);
      self.s.cancellationToken.emit("cancel");
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.on("error", () => {
        });
        conn.destroy(options2, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function")
            callback(err, null);
          return;
        }
        resetPoolState(self);
        self.queue = [];
        stateTransition(self, DESTROYED);
        if (typeof callback === "function")
          callback(null, null);
      });
    }
    Pool.prototype.destroy = function(force, callback) {
      var self = this;
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      if (this.state === DESTROYED || self.state === DESTROYING) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DRAINING);
      if (force) {
        var connections = self.availableConnections.concat(self.inUseConnections);
        while (self.queue.length > 0) {
          var workItem = self.queue.shift();
          if (typeof workItem.cb === "function") {
            workItem.cb(new MongoError("Pool was force destroyed"));
          }
        }
        return destroy(self, connections, {force: true}, callback);
      }
      if (this.reconnectId) {
        clearTimeout(this.reconnectId);
      }
      function checkStatus() {
        if (self.state === DESTROYED || self.state === DESTROYING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        flushMonitoringOperations(self.queue);
        if (self.queue.length === 0) {
          var connections2 = self.availableConnections.concat(self.inUseConnections);
          for (var i = 0; i < connections2.length; i++) {
            if (connections2[i].workItems.length > 0) {
              return setTimeout(checkStatus, 1);
            }
          }
          destroy(self, connections2, {force: false}, callback);
        } else {
          _execute(self)();
          setTimeout(checkStatus, 1);
        }
      }
      checkStatus();
    };
    Pool.prototype.reset = function(callback) {
      if (this.s.state !== CONNECTED) {
        if (typeof callback === "function") {
          callback(new MongoError("pool is not connected, reset aborted"));
        }
        return;
      }
      this.s.cancellationToken.emit("cancel");
      const connections = this.availableConnections.concat(this.inUseConnections);
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.destroy({force: true}, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function") {
            callback(err, null);
            return;
          }
        }
        resetPoolState(this);
        createConnection(this, () => {
          if (typeof callback === "function") {
            callback(null, null);
          }
        });
      });
    };
    function serializeCommand(self, command, callback) {
      const originalCommandBuffer = command.toBin();
      const shouldCompress = !!self.options.agreedCompressor;
      if (!shouldCompress || !canCompress(command)) {
        return callback(null, originalCommandBuffer);
      }
      const concatenatedOriginalCommandBuffer = Buffer2.concat(originalCommandBuffer);
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      compress(self, messageToBeCompressed, function(err, compressedMessage) {
        if (err)
          return callback(err, null);
        const msgHeader = Buffer2.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
        const compressionDetails = Buffer2.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8);
        return callback(null, [msgHeader, compressionDetails, compressedMessage]);
      });
    }
    Pool.prototype.write = function(command, options2, cb) {
      var self = this;
      if (typeof options2 === "function") {
        cb = options2;
      }
      options2 = options2 || {};
      if (!(typeof cb === "function") && !options2.noResponse) {
        throw new MongoError("write method must provide a callback");
      }
      if (this.state === DESTROYED || this.state === DESTROYING) {
        cb(new MongoError("pool destroyed"));
        return;
      }
      if (this.state === DRAINING) {
        cb(new MongoError("pool is draining, new operations prohibited"));
        return;
      }
      if (this.options.domainsEnabled && process.domain && typeof cb === "function") {
        var oldCb = cb;
        cb = process.domain.bind(function() {
          var args = new Array(arguments.length);
          for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          process.nextTick(function() {
            oldCb.apply(null, args);
          });
        });
      }
      var operation = {
        cb,
        raw: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        fullResult: false
      };
      operation.promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true;
      operation.promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : true;
      operation.promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false;
      operation.raw = typeof options2.raw === "boolean" ? options2.raw : false;
      operation.immediateRelease = typeof options2.immediateRelease === "boolean" ? options2.immediateRelease : false;
      operation.documentsReturnedIn = options2.documentsReturnedIn;
      operation.command = typeof options2.command === "boolean" ? options2.command : false;
      operation.fullResult = typeof options2.fullResult === "boolean" ? options2.fullResult : false;
      operation.noResponse = typeof options2.noResponse === "boolean" ? options2.noResponse : false;
      operation.session = options2.session || null;
      operation.socketTimeout = options2.socketTimeout;
      operation.monitoring = options2.monitoring;
      operation.requestId = command.requestId;
      if (self.options.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operation.started = now();
        operation.cb = (err, reply) => {
          if (err) {
            self.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operation.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              self.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operation.started));
            } else {
              self.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operation.started));
            }
          }
          if (typeof cb === "function")
            cb(err, reply);
        };
      }
      serializeCommand(self, command, (err, serializedBuffers) => {
        if (err)
          throw err;
        operation.buffer = serializedBuffers;
        if (options2.monitoring) {
          self.queue.unshift(operation);
        } else {
          self.queue.push(operation);
        }
        if (!self.executing) {
          process.nextTick(function() {
            _execute(self)();
          });
        }
      });
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function remove(connection, connections) {
      for (var i = 0; i < connections.length; i++) {
        if (connections[i] === connection) {
          connections.splice(i, 1);
          return true;
        }
      }
    }
    function removeConnection(self, connection) {
      if (remove(connection, self.availableConnections))
        return;
      if (remove(connection, self.inUseConnections))
        return;
    }
    function createConnection(pool, callback) {
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Cannot create connection when pool is destroyed"));
        }
        return;
      }
      pool.connectingConnections++;
      connect(pool.options, pool.s.cancellationToken, (err, connection) => {
        pool.connectingConnections--;
        if (err) {
          if (pool.logger.isDebug()) {
            pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          }
          if (!pool.reconnectId && pool.options.reconnect) {
            if (pool.state === CONNECTING && pool.options.legacyCompatMode) {
              callback(err);
              return;
            }
            pool.reconnectError = err;
            pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);
            return;
          }
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Pool was destroyed after connection creation"));
          }
          connection.destroy();
          return;
        }
        connection.on("error", pool._connectionErrorHandler);
        connection.on("close", pool._connectionCloseHandler);
        connection.on("timeout", pool._connectionTimeoutHandler);
        connection.on("parseError", pool._connectionParseErrorHandler);
        connection.on("message", pool._messageHandler);
        pool.availableConnections.push(connection);
        if (typeof callback === "function") {
          callback(null, connection);
        }
        _execute(pool)();
      });
    }
    function flushMonitoringOperations(queue) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].monitoring) {
          var workItem = queue[i];
          queue.splice(i, 1);
          workItem.cb(new MongoError({message: "no connection available for monitoring", driver: true}));
        }
      }
    }
    function _execute(self) {
      return function() {
        if (self.state === DESTROYED)
          return;
        if (self.executing)
          return;
        self.executing = true;
        if (self.connectingConnections > 0) {
          self.executing = false;
          return;
        }
        while (true) {
          const totalConnections = totalConnectionCount(self);
          if (self.availableConnections.length === 0) {
            flushMonitoringOperations(self.queue);
            if (totalConnections < self.options.size && self.queue.length > 0) {
              createConnection(self);
            }
            break;
          }
          if (self.queue.length === 0) {
            break;
          }
          var connection = null;
          const connections = self.availableConnections.filter((conn) => conn.workItems.length === 0);
          if (connections.length === 0) {
            connection = self.availableConnections[self.connectionIndex++ % self.availableConnections.length];
          } else {
            connection = connections[self.connectionIndex++ % connections.length];
          }
          if (!connection.isConnected()) {
            removeConnection(self, connection);
            flushMonitoringOperations(self.queue);
            break;
          }
          var workItem = self.queue.shift();
          if (workItem.monitoring) {
            var foundValidConnection = false;
            for (let i = 0; i < self.availableConnections.length; i++) {
              if (self.availableConnections[i].isConnected() && self.availableConnections[i].workItems.length === 0) {
                foundValidConnection = true;
                connection = self.availableConnections[i];
                break;
              }
            }
            if (!foundValidConnection) {
              self.queue.unshift(workItem);
              if (totalConnections < self.options.size && self.queue.length > 0) {
                createConnection(self);
              }
              setTimeout(() => _execute(self)(), 10);
              break;
            }
          }
          if (totalConnections < self.options.size) {
            if (connection.workItems.length > 0) {
              self.queue.unshift(workItem);
              createConnection(self);
              break;
            }
          }
          var buffer = workItem.buffer;
          if (workItem.monitoring) {
            moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);
          }
          if (!workItem.noResponse) {
            connection.workItems.push(workItem);
          }
          if (!workItem.immediateRelease && typeof workItem.socketTimeout === "number") {
            connection.setSocketTimeout(workItem.socketTimeout);
          }
          var writeSuccessful = true;
          if (Array.isArray(buffer)) {
            for (let i = 0; i < buffer.length; i++) {
              writeSuccessful = connection.write(buffer[i]);
            }
          } else {
            writeSuccessful = connection.write(buffer);
          }
          if (workItem.noResponse && typeof workItem.cb === "function") {
            workItem.cb(null, null);
          }
          if (writeSuccessful === false) {
            self.queue.unshift(workItem);
            removeConnection(self, connection);
            flushMonitoringOperations(self.queue);
            break;
          }
        }
        self.executing = false;
      };
    }
    Pool._execute = _execute;
    module2.exports = Pool;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/command.js
var require_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/command.js"(exports2, module2) {
    "use strict";
    var Query = require_commands().Query;
    var Msg = require_msg().Msg;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var isSharded = require_shared().isSharded;
    var databaseNamespace = require_shared().databaseNamespace;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var applySession = require_sessions().applySession;
    var MongoNetworkError = require_error().MongoNetworkError;
    var maxWireVersion = require_utils2().maxWireVersion;
    function isClientEncryptionEnabled(server) {
      const wireVersion = maxWireVersion(server);
      return wireVersion && server.autoEncrypter;
    }
    function command(server, ns, cmd, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (!isClientEncryptionEnabled(server)) {
        _command(server, ns, cmd, options2, callback);
        return;
      }
      const wireVersion = maxWireVersion(server);
      if (typeof wireVersion !== "number" || wireVersion < 8) {
        callback(new MongoError("Auto-encryption requires a minimum MongoDB version of 4.2"));
        return;
      }
      _cryptCommand(server, ns, cmd, options2, callback);
    }
    function _command(server, ns, cmd, options2, callback) {
      const bson = server.s.bson;
      const pool = server.s.pool;
      const readPreference = getReadPreference(cmd, options2);
      const shouldUseOpMsg = supportsOpMsg(server);
      const session = options2.session;
      const serverClusterTime = server.clusterTime;
      let clusterTime = serverClusterTime;
      let finalCmd = Object.assign({}, cmd);
      if (hasSessionSupport(server) && session) {
        const sessionClusterTime = session.clusterTime;
        if (serverClusterTime && serverClusterTime.clusterTime && sessionClusterTime && sessionClusterTime.clusterTime && sessionClusterTime.clusterTime.greaterThan(serverClusterTime.clusterTime)) {
          clusterTime = sessionClusterTime;
        }
        const err = applySession(session, finalCmd, options2);
        if (err) {
          return callback(err);
        }
      }
      if (clusterTime) {
        finalCmd.$clusterTime = clusterTime;
      }
      if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
        finalCmd = {
          $query: finalCmd,
          $readPreference: readPreference.toJSON()
        };
      }
      const commandOptions = Object.assign({
        command: true,
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false
      }, options2);
      commandOptions.slaveOk = readPreference.slaveOk();
      const cmdNs = `${databaseNamespace(ns)}.$cmd`;
      const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);
      const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));
      const commandResponseHandler = inTransaction ? function(err) {
        if (err && err instanceof MongoNetworkError && !err.hasErrorLabel("TransientTransactionError")) {
          err.addErrorLabel("TransientTransactionError");
        }
        if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel("TransientTransactionError")) {
          session.transaction.unpinServer();
        }
        return callback.apply(null, arguments);
      } : callback;
      try {
        pool.write(message, commandOptions, commandResponseHandler);
      } catch (err) {
        commandResponseHandler(err);
      }
    }
    function hasSessionSupport(topology) {
      if (topology == null)
        return false;
      if (topology.description) {
        return topology.description.maxWireVersion >= 6;
      }
      return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;
    }
    function supportsOpMsg(topologyOrServer) {
      const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;
      if (description == null) {
        return false;
      }
      return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;
    }
    function _cryptCommand(server, ns, cmd, options2, callback) {
      const autoEncrypter = server.autoEncrypter;
      function commandResponseHandler(err, response) {
        if (err || response == null) {
          callback(err, response);
          return;
        }
        autoEncrypter.decrypt(response.result, options2, (err2, decrypted) => {
          if (err2) {
            callback(err2, null);
            return;
          }
          response.result = decrypted;
          response.message.documents = [decrypted];
          callback(null, response);
        });
      }
      autoEncrypter.encrypt(ns, cmd, options2, (err, encrypted) => {
        if (err) {
          callback(err, null);
          return;
        }
        _command(server, ns, encrypted, options2, commandResponseHandler);
      });
    }
    module2.exports = command;
  }
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS({
  "node_modules/mongodb/lib/explain.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var ExplainVerbosity = {
      queryPlanner: "queryPlanner",
      queryPlannerExtended: "queryPlannerExtended",
      executionStats: "executionStats",
      allPlansExecution: "allPlansExecution"
    };
    var Explain = class {
      constructor(verbosity) {
        if (typeof verbosity === "boolean") {
          this.verbosity = verbosity ? "allPlansExecution" : "queryPlanner";
        } else {
          this.verbosity = verbosity;
        }
      }
      static fromOptions(options2) {
        if (options2 == null || options2.explain === void 0) {
          return;
        }
        const explain = options2.explain;
        if (typeof explain === "boolean" || explain in ExplainVerbosity) {
          return new Explain(options2.explain);
        }
        throw new MongoError(`explain must be one of ${Object.keys(ExplainVerbosity)} or a boolean`);
      }
    };
    module2.exports = {Explain};
  }
});

// node_modules/mongodb/lib/core/wireprotocol/write_command.js
var require_write_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/write_command.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var collectionNamespace = require_shared().collectionNamespace;
    var command = require_command();
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var Explain = require_explain().Explain;
    function writeCommand(server, type, opsField, ns, ops, options2, callback) {
      if (ops.length === 0)
        throw new MongoError(`${type} must contain at least one document`);
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      const ordered = typeof options2.ordered === "boolean" ? options2.ordered : true;
      const writeConcern = options2.writeConcern;
      let writeCommand2 = {};
      writeCommand2[type] = collectionNamespace(ns);
      writeCommand2[opsField] = ops;
      writeCommand2.ordered = ordered;
      if (writeConcern && Object.keys(writeConcern).length > 0) {
        writeCommand2.writeConcern = writeConcern;
      }
      if (options2.collation) {
        for (let i = 0; i < writeCommand2[opsField].length; i++) {
          if (!writeCommand2[opsField][i].collation) {
            writeCommand2[opsField][i].collation = options2.collation;
          }
        }
      }
      if (options2.bypassDocumentValidation === true) {
        writeCommand2.bypassDocumentValidation = options2.bypassDocumentValidation;
      }
      const explain = Explain.fromOptions(options2);
      if (explain) {
        writeCommand2 = decorateWithExplain(writeCommand2, explain);
      }
      const commandOptions = Object.assign({
        checkKeys: type === "insert",
        numberToReturn: 1
      }, options2);
      command(server, ns, writeCommand2, commandOptions, callback);
    }
    module2.exports = writeCommand;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js
var require_kill_cursors = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js"(exports2, module2) {
    "use strict";
    var KillCursor = require_commands().KillCursor;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils2().maxWireVersion;
    var emitWarning = require_utils2().emitWarning;
    var command = require_command();
    function killCursors(server, ns, cursorState, callback) {
      callback = typeof callback === "function" ? callback : () => {
      };
      const cursorId = cursorState.cursorId;
      if (maxWireVersion(server) < 4) {
        const bson = server.s.bson;
        const pool = server.s.pool;
        const killCursor = new KillCursor(bson, ns, [cursorId]);
        const options3 = {
          immediateRelease: true,
          noResponse: true
        };
        if (typeof cursorState.session === "object") {
          options3.session = cursorState.session;
        }
        if (pool && pool.isConnected()) {
          try {
            pool.write(killCursor, options3, callback);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err, null);
            } else {
              emitWarning(err);
            }
          }
        }
        return;
      }
      const killCursorCmd = {
        killCursors: collectionNamespace(ns),
        cursors: [cursorId]
      };
      const options2 = {};
      if (typeof cursorState.session === "object")
        options2.session = cursorState.session;
      command(server, ns, killCursorCmd, options2, (err, result) => {
        if (err) {
          return callback(err);
        }
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (!Array.isArray(response.documents) || response.documents.length === 0) {
          return callback(new MongoError(`invalid killCursors result returned for cursor id ${cursorId}`));
        }
        callback(null, response.documents[0]);
      });
    }
    module2.exports = killCursors;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/get_more.js
var require_get_more = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/get_more.js"(exports2, module2) {
    "use strict";
    var GetMore = require_commands().GetMore;
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils2().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    function getMore(server, ns, cursorState, batchSize, options2, callback) {
      options2 = options2 || {};
      const wireVersion = maxWireVersion(server);
      function queryCallback(err, result) {
        if (err)
          return callback(err);
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (wireVersion < 4) {
          const cursorId3 = typeof response.cursorId === "number" ? Long2.fromNumber(response.cursorId) : response.cursorId;
          cursorState.documents = response.documents;
          cursorState.cursorId = cursorId3;
          callback(null, null, response.connection);
          return;
        }
        if (response.documents[0].ok === 0) {
          return callback(new MongoError(response.documents[0]));
        }
        const cursorId2 = typeof response.documents[0].cursor.id === "number" ? Long2.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;
        cursorState.documents = response.documents[0].cursor.nextBatch;
        cursorState.cursorId = cursorId2;
        callback(null, response.documents[0], response.connection);
      }
      if (wireVersion < 4) {
        const bson = server.s.bson;
        const getMoreOp = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        server.s.pool.write(getMoreOp, queryOptions, queryCallback);
        return;
      }
      const cursorId = cursorState.cursorId instanceof Long2 ? cursorState.cursorId : Long2.fromNumber(cursorState.cursorId);
      const getMoreCmd = {
        getMore: cursorId,
        collection: collectionNamespace(ns),
        batchSize: Math.abs(batchSize)
      };
      if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
      }
      const commandOptions = Object.assign({
        returnFieldSelector: null,
        documentsReturnedIn: "nextBatch"
      }, options2);
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, getMoreCmd, commandOptions, queryCallback);
    }
    module2.exports = getMore;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/query.js
var require_query = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/query.js"(exports2, module2) {
    "use strict";
    var Query = require_commands().Query;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var collectionNamespace = require_shared().collectionNamespace;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils2().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var Explain = require_explain().Explain;
    function query(server, ns, cmd, cursorState, options2, callback) {
      options2 = options2 || {};
      if (cursorState.cursorId != null) {
        return callback();
      }
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (maxWireVersion(server) < 4) {
        const query2 = prepareLegacyFindQuery(server, ns, cmd, cursorState, options2);
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        if (typeof query2.documentsReturnedIn === "string") {
          queryOptions.documentsReturnedIn = query2.documentsReturnedIn;
        }
        server.s.pool.write(query2, queryOptions, callback);
        return;
      }
      const readPreference = getReadPreference(cmd, options2);
      let findCmd = prepareFindCommand(server, ns, cmd, cursorState, options2);
      const explain = Explain.fromOptions(options2);
      if (explain) {
        findCmd = decorateWithExplain(findCmd, explain);
      }
      cmd.virtual = false;
      const commandOptions = Object.assign({
        documentsReturnedIn: "firstBatch",
        numberToReturn: 1,
        slaveOk: readPreference.slaveOk()
      }, options2);
      if (cmd.readPreference) {
        commandOptions.readPreference = readPreference;
      }
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, findCmd, commandOptions, callback);
    }
    function prepareFindCommand(server, ns, cmd, cursorState) {
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      const findCmd = {
        find: collectionNamespace(ns)
      };
      if (cmd.query) {
        if (cmd.query["$query"]) {
          findCmd.filter = cmd.query["$query"];
        } else {
          findCmd.filter = cmd.query;
        }
      }
      let sortValue = cmd.sort;
      if (Array.isArray(sortValue)) {
        const sortObject = {};
        if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {
          let sortDirection = sortValue[1];
          if (sortDirection === "asc") {
            sortDirection = 1;
          } else if (sortDirection === "desc") {
            sortDirection = -1;
          }
          sortObject[sortValue[0]] = sortDirection;
        } else {
          for (let i = 0; i < sortValue.length; i++) {
            let sortDirection = sortValue[i][1];
            if (sortDirection === "asc") {
              sortDirection = 1;
            } else if (sortDirection === "desc") {
              sortDirection = -1;
            }
            sortObject[sortValue[i][0]] = sortDirection;
          }
        }
        sortValue = sortObject;
      }
      if (typeof cmd.allowDiskUse === "boolean") {
        findCmd.allowDiskUse = cmd.allowDiskUse;
      }
      if (cmd.sort)
        findCmd.sort = sortValue;
      if (cmd.fields)
        findCmd.projection = cmd.fields;
      if (cmd.hint)
        findCmd.hint = cmd.hint;
      if (cmd.skip)
        findCmd.skip = cmd.skip;
      if (cmd.limit)
        findCmd.limit = cmd.limit;
      if (cmd.limit < 0) {
        findCmd.limit = Math.abs(cmd.limit);
        findCmd.singleBatch = true;
      }
      if (typeof cmd.batchSize === "number") {
        if (cmd.batchSize < 0) {
          if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {
            findCmd.limit = Math.abs(cmd.batchSize);
          }
          findCmd.singleBatch = true;
        }
        findCmd.batchSize = Math.abs(cmd.batchSize);
      }
      if (cmd.comment)
        findCmd.comment = cmd.comment;
      if (cmd.maxScan)
        findCmd.maxScan = cmd.maxScan;
      if (cmd.maxTimeMS)
        findCmd.maxTimeMS = cmd.maxTimeMS;
      if (cmd.min)
        findCmd.min = cmd.min;
      if (cmd.max)
        findCmd.max = cmd.max;
      findCmd.returnKey = cmd.returnKey ? cmd.returnKey : false;
      findCmd.showRecordId = cmd.showDiskLoc ? cmd.showDiskLoc : false;
      if (cmd.snapshot)
        findCmd.snapshot = cmd.snapshot;
      if (cmd.tailable)
        findCmd.tailable = cmd.tailable;
      if (cmd.oplogReplay)
        findCmd.oplogReplay = cmd.oplogReplay;
      if (cmd.noCursorTimeout)
        findCmd.noCursorTimeout = cmd.noCursorTimeout;
      if (cmd.awaitData)
        findCmd.awaitData = cmd.awaitData;
      if (cmd.awaitdata)
        findCmd.awaitData = cmd.awaitdata;
      if (cmd.partial)
        findCmd.partial = cmd.partial;
      if (cmd.collation)
        findCmd.collation = cmd.collation;
      if (cmd.readConcern)
        findCmd.readConcern = cmd.readConcern;
      return findCmd;
    }
    function prepareLegacyFindQuery(server, ns, cmd, cursorState, options2) {
      options2 = options2 || {};
      const bson = server.s.bson;
      const readPreference = getReadPreference(cmd, options2);
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      let numberToReturn = 0;
      if (cursorState.limit < 0 || cursorState.limit !== 0 && cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize === 0) {
        numberToReturn = cursorState.limit;
      } else {
        numberToReturn = cursorState.batchSize;
      }
      const numberToSkip = cursorState.skip || 0;
      const findCmd = {};
      if (isSharded(server) && readPreference) {
        findCmd["$readPreference"] = readPreference.toJSON();
      }
      if (cmd.sort)
        findCmd["$orderby"] = cmd.sort;
      if (cmd.hint)
        findCmd["$hint"] = cmd.hint;
      if (cmd.snapshot)
        findCmd["$snapshot"] = cmd.snapshot;
      if (typeof cmd.returnKey !== "undefined")
        findCmd["$returnKey"] = cmd.returnKey;
      if (cmd.maxScan)
        findCmd["$maxScan"] = cmd.maxScan;
      if (cmd.min)
        findCmd["$min"] = cmd.min;
      if (cmd.max)
        findCmd["$max"] = cmd.max;
      if (typeof cmd.showDiskLoc !== "undefined")
        findCmd["$showDiskLoc"] = cmd.showDiskLoc;
      if (cmd.comment)
        findCmd["$comment"] = cmd.comment;
      if (cmd.maxTimeMS)
        findCmd["$maxTimeMS"] = cmd.maxTimeMS;
      if (options2.explain !== void 0) {
        numberToReturn = -Math.abs(cmd.limit || 0);
        findCmd["$explain"] = true;
      }
      findCmd["$query"] = cmd.query;
      if (cmd.readConcern && cmd.readConcern.level !== "local") {
        throw new MongoError(`server find command does not support a readConcern level of ${cmd.readConcern.level}`);
      }
      if (cmd.readConcern) {
        cmd = Object.assign({}, cmd);
        delete cmd["readConcern"];
      }
      const serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      const ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
      const query2 = new Query(bson, ns, findCmd, {
        numberToSkip,
        numberToReturn,
        pre32Limit: typeof cmd.limit !== "undefined" ? cmd.limit : void 0,
        checkKeys: false,
        returnFieldSelector: cmd.fields,
        serializeFunctions,
        ignoreUndefined
      });
      if (typeof cmd.tailable === "boolean")
        query2.tailable = cmd.tailable;
      if (typeof cmd.oplogReplay === "boolean")
        query2.oplogReplay = cmd.oplogReplay;
      if (typeof cmd.noCursorTimeout === "boolean")
        query2.noCursorTimeout = cmd.noCursorTimeout;
      if (typeof cmd.awaitData === "boolean")
        query2.awaitData = cmd.awaitData;
      if (typeof cmd.partial === "boolean")
        query2.partial = cmd.partial;
      query2.slaveOk = readPreference.slaveOk();
      return query2;
    }
    module2.exports = query;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/index.js
var require_wireprotocol = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/index.js"(exports2, module2) {
    "use strict";
    var writeCommand = require_write_command();
    module2.exports = {
      insert: function insert(server, ns, ops, options2, callback) {
        writeCommand(server, "insert", "documents", ns, ops, options2, callback);
      },
      update: function update(server, ns, ops, options2, callback) {
        writeCommand(server, "update", "updates", ns, ops, options2, callback);
      },
      remove: function remove(server, ns, ops, options2, callback) {
        writeCommand(server, "delete", "deletes", ns, ops, options2, callback);
      },
      killCursors: require_kill_cursors(),
      getMore: require_get_more(),
      query: require_query(),
      command: require_command()
    };
  }
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS({
  "node_modules/mongodb/lib/operations/operation.js"(exports2, module2) {
    "use strict";
    var Explain = require_explain().Explain;
    var MongoError = require_error().MongoError;
    var Aspect = {
      READ_OPERATION: Symbol("READ_OPERATION"),
      WRITE_OPERATION: Symbol("WRITE_OPERATION"),
      RETRYABLE: Symbol("RETRYABLE"),
      EXECUTE_WITH_SELECTION: Symbol("EXECUTE_WITH_SELECTION"),
      NO_INHERIT_OPTIONS: Symbol("NO_INHERIT_OPTIONS"),
      EXPLAINABLE: Symbol("EXPLAINABLE")
    };
    var OperationBase = class {
      constructor(options2) {
        this.options = Object.assign({}, options2);
        if (this.hasAspect(Aspect.EXPLAINABLE)) {
          this.explain = Explain.fromOptions(options2);
        } else if (this.options.explain !== void 0) {
          throw new MongoError(`explain is not supported on this command`);
        }
      }
      hasAspect(aspect) {
        if (this.constructor.aspects == null) {
          return false;
        }
        return this.constructor.aspects.has(aspect);
      }
      set session(session) {
        Object.assign(this.options, {session});
      }
      get session() {
        return this.options.session;
      }
      clearSession() {
        delete this.options.session;
      }
      get canRetryRead() {
        return true;
      }
      execute() {
        throw new TypeError("`execute` must be implemented for OperationBase subclasses");
      }
    };
    function defineAspects(operation, aspects) {
      if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
      }
      aspects = new Set(aspects);
      Object.defineProperty(operation, "aspects", {
        value: aspects,
        writable: false
      });
      return aspects;
    }
    module2.exports = {
      Aspect,
      defineAspects,
      OperationBase
    };
  }
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS({
  "node_modules/mongodb/lib/operations/execute_operation.js"(exports2, module2) {
    "use strict";
    var maybePromise = require_utils4().maybePromise;
    var MongoError = require_error().MongoError;
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_read_preference();
    var isRetryableError = require_error().isRetryableError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var isUnifiedTopology = require_utils2().isUnifiedTopology;
    function executeOperation(topology, operation, cb) {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!(operation instanceof OperationBase)) {
        throw new TypeError("This method requires a valid operation instance");
      }
      return maybePromise(topology, cb, (callback) => {
        if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {
          return selectServerForSessionSupport(topology, operation, callback);
        }
        let session, owner;
        if (topology.hasSessionSupport()) {
          if (operation.session == null) {
            owner = Symbol();
            session = topology.startSession({owner});
            operation.session = session;
          } else if (operation.session.hasEnded) {
            return callback(new MongoError("Use of expired sessions is not permitted"));
          }
        } else if (operation.session) {
          return callback(new MongoError("Current topology does not support sessions"));
        }
        function executeCallback(err, result) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(err, result);
        }
        try {
          if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {
            executeWithServerSelection(topology, operation, executeCallback);
          } else {
            operation.execute(executeCallback);
          }
        } catch (error3) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(error3);
        }
      });
    }
    function supportsRetryableReads(server) {
      return maxWireVersion(server) >= 6;
    }
    function executeWithServerSelection(topology, operation, callback) {
      const readPreference = operation.readPreference || ReadPreference.primary;
      const inTransaction = operation.session && operation.session.inTransaction();
      if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
        callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));
        return;
      }
      const serverSelectionOptions = {
        readPreference,
        session: operation.session
      };
      function callbackWithRetry(err, result) {
        if (err == null) {
          return callback(null, result);
        }
        if (!isRetryableError(err)) {
          return callback(err);
        }
        topology.selectServer(serverSelectionOptions, (err2, server) => {
          if (err2 || !supportsRetryableReads(server)) {
            callback(err2, null);
            return;
          }
          operation.execute(server, callback);
        });
      }
      topology.selectServer(serverSelectionOptions, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;
        if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {
          operation.execute(server, callbackWithRetry);
          return;
        }
        operation.execute(server, callback);
      });
    }
    function selectServerForSessionSupport(topology, operation, callback) {
      topology.selectServer(ReadPreference.primaryPreferred, (err) => {
        if (err) {
          return callback(err);
        }
        executeOperation(topology, operation, callback);
      });
    }
    module2.exports = executeOperation;
  }
});

// node_modules/mongodb/lib/core/cursor.js
var require_cursor = __commonJS({
  "node_modules/mongodb/lib/core/cursor.js"(exports2, module2) {
    "use strict";
    var Logger = require_logger();
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collationNotSupported = require_utils2().collationNotSupported;
    var ReadPreference = require_read_preference();
    var isUnifiedTopology = require_utils2().isUnifiedTopology;
    var executeOperation = require_execute_operation();
    var Readable2 = require("stream").Readable;
    var SUPPORTS = require_utils4().SUPPORTS;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var mergeOptions = require_utils4().mergeOptions;
    var OperationBase = require_operation().OperationBase;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var CursorState = {
      INIT: 0,
      OPEN: 1,
      CLOSED: 2,
      GET_MORE: 3
    };
    function handleCallback(callback, err, result) {
      try {
        callback(err, result);
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
      }
    }
    var CoreCursor = class extends Readable2 {
      constructor(topology, ns, cmd, options2) {
        super({objectMode: true});
        options2 = options2 || {};
        if (ns instanceof OperationBase) {
          this.operation = ns;
          ns = this.operation.ns.toString();
          options2 = this.operation.options;
          cmd = this.operation.cmd ? this.operation.cmd : {};
        }
        this.pool = null;
        this.server = null;
        this.disconnectHandler = options2.disconnectHandler;
        this.bson = topology.s.bson;
        this.ns = ns;
        this.namespace = MongoDBNamespace.fromString(ns);
        this.cmd = cmd;
        this.options = options2;
        this.topology = topology;
        this.cursorState = {
          cursorId: null,
          cmd,
          documents: options2.documents || [],
          cursorIndex: 0,
          dead: false,
          killed: false,
          init: false,
          notified: false,
          limit: options2.limit || cmd.limit || 0,
          skip: options2.skip || cmd.skip || 0,
          batchSize: options2.batchSize || cmd.batchSize || 1e3,
          currentLimit: 0,
          transforms: options2.transforms,
          raw: options2.raw || cmd && cmd.raw
        };
        if (typeof options2.session === "object") {
          this.cursorState.session = options2.session;
        }
        const topologyOptions = topology.s.options;
        if (typeof topologyOptions.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = topologyOptions.promoteLongs;
        } else if (typeof options2.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = options2.promoteLongs;
        }
        if (typeof topologyOptions.promoteValues === "boolean") {
          this.cursorState.promoteValues = topologyOptions.promoteValues;
        } else if (typeof options2.promoteValues === "boolean") {
          this.cursorState.promoteValues = options2.promoteValues;
        }
        if (typeof topologyOptions.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
        } else if (typeof options2.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = options2.promoteBuffers;
        }
        if (topologyOptions.reconnect) {
          this.cursorState.reconnect = topologyOptions.reconnect;
        }
        this.logger = Logger("Cursor", topologyOptions);
        if (typeof cmd === "number") {
          this.cursorState.cursorId = Long2.fromNumber(cmd);
          this.cursorState.lastCursorId = this.cursorState.cursorId;
        } else if (cmd instanceof Long2) {
          this.cursorState.cursorId = cmd;
          this.cursorState.lastCursorId = cmd;
        }
        if (this.operation) {
          this.operation.cursorState = this.cursorState;
        }
      }
      setCursorBatchSize(value) {
        this.cursorState.batchSize = value;
      }
      cursorBatchSize() {
        return this.cursorState.batchSize;
      }
      setCursorLimit(value) {
        this.cursorState.limit = value;
      }
      cursorLimit() {
        return this.cursorState.limit;
      }
      setCursorSkip(value) {
        this.cursorState.skip = value;
      }
      cursorSkip() {
        return this.cursorState.skip;
      }
      _next(callback) {
        nextFunction(this, callback);
      }
      clone() {
        const clonedOptions = mergeOptions({}, this.options);
        delete clonedOptions.session;
        return this.topology.cursor(this.ns, this.cmd, clonedOptions);
      }
      isDead() {
        return this.cursorState.dead === true;
      }
      isKilled() {
        return this.cursorState.killed === true;
      }
      isNotified() {
        return this.cursorState.notified === true;
      }
      bufferedCount() {
        return this.cursorState.documents.length - this.cursorState.cursorIndex;
      }
      readBufferedDocuments(number) {
        const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
        const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
        let elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
        if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === "function") {
          for (let i = 0; i < elements.length; i++) {
            elements[i] = this.cursorState.transforms.doc(elements[i]);
          }
        }
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {
          elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
          this.kill();
        }
        this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
        this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
        return elements;
      }
      kill(callback) {
        this.cursorState.dead = true;
        this.cursorState.killed = true;
        this.cursorState.documents = [];
        if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {
          if (callback)
            callback(null, null);
          return;
        }
        this.server.killCursors(this.ns, this.cursorState, callback);
      }
      rewind() {
        if (this.cursorState.init) {
          if (!this.cursorState.dead) {
            this.kill();
          }
          this.cursorState.currentLimit = 0;
          this.cursorState.init = false;
          this.cursorState.dead = false;
          this.cursorState.killed = false;
          this.cursorState.notified = false;
          this.cursorState.documents = [];
          this.cursorState.cursorId = null;
          this.cursorState.cursorIndex = 0;
        }
      }
      _read() {
        if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {
          return this.push(null);
        }
        this._next((err, result) => {
          if (err) {
            if (this.listeners("error") && this.listeners("error").length > 0) {
              this.emit("error", err);
            }
            if (!this.isDead())
              this.close();
            this.emit("end");
            return this.emit("finish");
          }
          if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === "function" && result != null) {
            return this.push(this.cursorState.streamOptions.transform(result));
          }
          this.push(result);
          if (result === null && this.isDead()) {
            this.once("end", () => {
              this.close();
              this.emit("finish");
            });
          }
        });
      }
      _endSession(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = options2 || {};
        const session = this.cursorState.session;
        if (session && (options2.force || session.owner === this)) {
          this.cursorState.session = void 0;
          if (this.operation) {
            this.operation.clearSession();
          }
          session.endSession(callback);
          return true;
        }
        if (callback) {
          callback();
        }
        return false;
      }
      _getMore(callback) {
        if (this.logger.isDebug()) {
          this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);
        }
        let batchSize = this.cursorState.batchSize;
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {
          batchSize = this.cursorState.limit - this.cursorState.currentLimit;
        }
        const cursorState = this.cursorState;
        this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            this._endSession();
          }
          callback(err, result, conn);
        });
      }
      _initializeCursor(callback) {
        const cursor = this;
        if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {
          cursor.topology.selectServer(ReadPreference.primaryPreferred, (err) => {
            if (err) {
              callback(err);
              return;
            }
            this._initializeCursor(callback);
          });
          return;
        }
        function done(err, result) {
          const cursorState = cursor.cursorState;
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            cursor._endSession();
          }
          if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {
            return setCursorNotified(cursor, callback);
          }
          callback(err, result);
        }
        const queryCallback = (err, r) => {
          if (err) {
            return done(err);
          }
          const result = r.message;
          if (Array.isArray(result.documents) && result.documents.length === 1) {
            const document2 = result.documents[0];
            if (result.queryFailure) {
              return done(new MongoError(document2), null);
            }
            if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {
              if (document2.$err || document2.errmsg) {
                return done(new MongoError(document2), null);
              }
              if (document2.cursor != null && typeof document2.cursor !== "string") {
                const id = document2.cursor.id;
                if (document2.cursor.ns) {
                  cursor.ns = document2.cursor.ns;
                }
                cursor.cursorState.cursorId = typeof id === "number" ? Long2.fromNumber(id) : id;
                cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;
                cursor.cursorState.operationTime = document2.operationTime;
                if (Array.isArray(document2.cursor.firstBatch)) {
                  cursor.cursorState.documents = document2.cursor.firstBatch;
                }
                return done(null, result);
              }
            }
          }
          const cursorId = result.cursorId || 0;
          cursor.cursorState.cursorId = cursorId instanceof Long2 ? cursorId : Long2.fromNumber(cursorId);
          cursor.cursorState.documents = result.documents;
          cursor.cursorState.lastCursorId = result.cursorId;
          if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === "function") {
            cursor.cursorState.documents = cursor.cursorState.transforms.query(result);
          }
          done(null, result);
        };
        if (cursor.operation) {
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          executeOperation(cursor.topology, cursor.operation, (err, result) => {
            if (err) {
              done(err);
              return;
            }
            cursor.server = cursor.operation.server;
            cursor.cursorState.init = true;
            if (cursor.cursorState.cursorId != null) {
              return done();
            }
            queryCallback(err, result);
          });
          return;
        }
        const serverSelectOptions = {};
        if (cursor.cursorState.session) {
          serverSelectOptions.session = cursor.cursorState.session;
        }
        if (cursor.operation) {
          serverSelectOptions.readPreference = cursor.operation.readPreference;
        } else if (cursor.options.readPreference) {
          serverSelectOptions.readPreference = cursor.options.readPreference;
        }
        return cursor.topology.selectServer(serverSelectOptions, (err, server) => {
          if (err) {
            const disconnectHandler = cursor.disconnectHandler;
            if (disconnectHandler != null) {
              return disconnectHandler.addObjectAndMethod("cursor", cursor, "next", [callback], callback);
            }
            return callback(err);
          }
          cursor.server = server;
          cursor.cursorState.init = true;
          if (collationNotSupported(cursor.server, cursor.cmd)) {
            return callback(new MongoError(`server ${cursor.server.name} does not support collation`));
          }
          if (cursor.cursorState.cursorId != null) {
            return done();
          }
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          if (cursor.cmd.find != null) {
            server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);
            return;
          }
          const commandOptions = Object.assign({session: cursor.cursorState.session}, cursor.options);
          server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);
        });
      }
    };
    if (SUPPORTS.ASYNC_ITERATOR) {
      CoreCursor.prototype[Symbol.asyncIterator] = require_async_iterator().asyncIterator;
    }
    function isConnectionDead(self, callback) {
      if (self.pool && self.pool.isDestroyed()) {
        self.cursorState.killed = true;
        const err = new MongoNetworkError(`connection to host ${self.pool.host}:${self.pool.port} was destroyed`);
        _setCursorNotifiedImpl(self, () => callback(err));
        return true;
      }
      return false;
    }
    function isCursorDeadButNotkilled(self, callback) {
      if (self.cursorState.dead && !self.cursorState.killed) {
        self.cursorState.killed = true;
        setCursorNotified(self, callback);
        return true;
      }
      return false;
    }
    function isCursorDeadAndKilled(self, callback) {
      if (self.cursorState.dead && self.cursorState.killed) {
        handleCallback(callback, new MongoError("cursor is dead"));
        return true;
      }
      return false;
    }
    function isCursorKilled(self, callback) {
      if (self.cursorState.killed) {
        setCursorNotified(self, callback);
        return true;
      }
      return false;
    }
    function setCursorDeadAndNotified(self, callback) {
      self.cursorState.dead = true;
      setCursorNotified(self, callback);
    }
    function setCursorNotified(self, callback) {
      _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));
    }
    function _setCursorNotifiedImpl(self, callback) {
      self.cursorState.notified = true;
      self.cursorState.documents = [];
      self.cursorState.cursorIndex = 0;
      if (self.cursorState.session) {
        self._endSession(callback);
        return;
      }
      return callback();
    }
    function nextFunction(self, callback) {
      if (self.cursorState.notified) {
        return callback(new Error("cursor is exhausted"));
      }
      if (isCursorKilled(self, callback))
        return;
      if (isCursorDeadButNotkilled(self, callback))
        return;
      if (isCursorDeadAndKilled(self, callback))
        return;
      if (!self.cursorState.init) {
        if (!self.topology.isConnected(self.options)) {
          if (self.topology._type === "server" && !self.topology.s.options.reconnect) {
            return callback(new MongoError("no connection available"));
          }
          if (self.disconnectHandler != null) {
            if (self.topology.isDestroyed()) {
              return callback(new MongoError("Topology was destroyed"));
            }
            self.disconnectHandler.addObjectAndMethod("cursor", self, "next", [callback], callback);
            return;
          }
        }
        self._initializeCursor((err, result) => {
          if (err || result === null) {
            callback(err, result);
            return;
          }
          nextFunction(self, callback);
        });
        return;
      }
      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
        self.kill(() => setCursorDeadAndNotified(self, callback));
      } else if (self.cursorState.cursorIndex === self.cursorState.documents.length && !Long2.ZERO.equals(self.cursorState.cursorId)) {
        self.cursorState.documents = [];
        self.cursorState.cursorIndex = 0;
        if (self.topology.isDestroyed())
          return callback(new MongoNetworkError("connection destroyed, not possible to instantiate cursor"));
        if (isConnectionDead(self, callback))
          return;
        self._getMore(function(err, doc, connection) {
          if (err) {
            return handleCallback(callback, err);
          }
          self.connection = connection;
          if (self.cursorState.documents.length === 0 && self.cmd.tailable && Long2.ZERO.equals(self.cursorState.cursorId)) {
            return handleCallback(callback, new MongoError({
              message: "No more documents in tailed cursor",
              tailable: self.cmd.tailable,
              awaitData: self.cmd.awaitData
            }));
          } else if (self.cursorState.documents.length === 0 && self.cmd.tailable && !Long2.ZERO.equals(self.cursorState.cursorId)) {
            return nextFunction(self, callback);
          }
          if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
            return setCursorDeadAndNotified(self, callback);
          }
          nextFunction(self, callback);
        });
      } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && self.cmd.tailable && Long2.ZERO.equals(self.cursorState.cursorId)) {
        return handleCallback(callback, new MongoError({
          message: "No more documents in tailed cursor",
          tailable: self.cmd.tailable,
          awaitData: self.cmd.awaitData
        }));
      } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && Long2.ZERO.equals(self.cursorState.cursorId)) {
        setCursorDeadAndNotified(self, callback);
      } else {
        if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
          self.kill(() => setCursorDeadAndNotified(self, callback));
          return;
        }
        self.cursorState.currentLimit += 1;
        let doc = self.cursorState.documents[self.cursorState.cursorIndex++];
        if (!doc || doc.$err) {
          self.kill(() => setCursorDeadAndNotified(self, function() {
            handleCallback(callback, new MongoError(doc ? doc.$err : void 0));
          }));
          return;
        }
        if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === "function") {
          doc = self.cursorState.transforms.doc(doc);
        }
        handleCallback(callback, null, doc);
      }
    }
    module2.exports = {
      CursorState,
      CoreCursor
    };
  }
});

// node_modules/mongodb/lib/core/topologies/server.js
var require_server = __commonJS({
  "node_modules/mongodb/lib/core/topologies/server.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var Logger = require_logger();
    var debugOptions = require_utils3().debugOptions;
    var retrieveBSON = require_utils3().retrieveBSON;
    var Pool = require_pool();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var wireProtocol = require_wireprotocol();
    var CoreCursor = require_cursor().CoreCursor;
    var sdam = require_shared2();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SessionMixins = require_shared2().SessionMixins;
    var relayEvents = require_utils2().relayEvents;
    var collationNotSupported = require_utils2().collationNotSupported;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var debugFields = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "servername"
    ];
    var id = 0;
    var serverAccounting = false;
    var servers = {};
    var BSON2 = retrieveBSON();
    function topologyId(server) {
      return server.s.parent == null ? server.id : server.s.parent.id;
    }
    var Server = function(options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.id = id++;
      this.s = {
        options: Object.assign({metadata: makeClientMetadata(options2)}, options2),
        logger: Logger("Server", options2),
        Cursor: options2.cursorFactory || CoreCursor,
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        pool: null,
        disconnectHandler: options2.disconnectHandler,
        monitoring: typeof options2.monitoring === "boolean" ? options2.monitoring : true,
        inTopology: !!options2.parent,
        monitoringInterval: typeof options2.monitoringInterval === "number" ? options2.monitoringInterval : 5e3,
        compression: {compressors: createCompressionInfo(options2)},
        parent: options2.parent
      };
      if (!this.s.parent) {
        this.s.clusterTime = null;
      }
      this.ismaster = null;
      this.lastIsMasterMS = -1;
      this.monitoringProcessId = null;
      this.initialConnect = true;
      this._type = "server";
      this.lastUpdateTime = 0;
      this.lastWriteDate = 0;
      this.staleness = 0;
    };
    inherits(Server, EventEmitter);
    Object.assign(Server.prototype, SessionMixins);
    Object.defineProperty(Server.prototype, "type", {
      enumerable: true,
      get: function() {
        return this._type;
      }
    });
    Object.defineProperty(Server.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Server.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    Object.defineProperty(Server.prototype, "clientMetadata", {
      enumerable: true,
      get: function() {
        return this.s.options.metadata;
      }
    });
    Object.defineProperty(Server.prototype, "clusterTime", {
      enumerable: true,
      set: function(clusterTime) {
        const settings = this.s.parent ? this.s.parent : this.s;
        resolveClusterTime(settings, clusterTime);
      },
      get: function() {
        const settings = this.s.parent ? this.s.parent : this.s;
        return settings.clusterTime || null;
      }
    });
    Server.enableServerAccounting = function() {
      serverAccounting = true;
      servers = {};
    };
    Server.disableServerAccounting = function() {
      serverAccounting = false;
    };
    Server.servers = function() {
      return servers;
    };
    Object.defineProperty(Server.prototype, "name", {
      enumerable: true,
      get: function() {
        return this.s.options.host + ":" + this.s.options.port;
      }
    });
    function disconnectHandler(self, type, ns, cmd, options2, callback) {
      if (!self.s.pool.isConnected() && self.s.options.reconnect && self.s.disconnectHandler != null && !options2.monitoring) {
        self.s.disconnectHandler.add(type, ns, cmd, options2, callback);
        return true;
      }
      if (!self.s.pool.isConnected()) {
        callback(new MongoError(f("no connection available to server %s", self.name)));
        return true;
      }
    }
    function monitoringProcess(self) {
      return function() {
        if (self.s.pool.isDestroyed())
          return;
        self.emit("monitoring", self);
        var start = new Date().getTime();
        self.command("admin.$cmd", {ismaster: true}, {
          socketTimeout: typeof self.s.options.connectionTimeout !== "number" ? 2e3 : self.s.options.connectionTimeout,
          monitoring: true
        }, (err, result) => {
          self.lastIsMasterMS = new Date().getTime() - start;
          if (self.s.pool.isDestroyed())
            return;
          if (result) {
            self.ismaster = result.result;
          }
          self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
        });
      };
    }
    var eventHandler = function(self, event) {
      return function(err, conn) {
        if (self.s.logger.isInfo()) {
          var object = err instanceof MongoError ? JSON.stringify(err) : {};
          self.s.logger.info(f("server %s fired event %s out with message %s", self.name, event, object));
        }
        if (event === "connect") {
          self.initialConnect = false;
          self.ismaster = conn.ismaster;
          self.lastIsMasterMS = conn.lastIsMasterMS;
          if (conn.agreedCompressor) {
            self.s.pool.options.agreedCompressor = conn.agreedCompressor;
          }
          if (conn.zlibCompressionLevel) {
            self.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
          }
          if (conn.ismaster.$clusterTime) {
            const $clusterTime = conn.ismaster.$clusterTime;
            self.clusterTime = $clusterTime;
          }
          if (self.ismaster.msg === "isdbgrid") {
            self._type = "mongos";
          }
          if (self.s.monitoring) {
            self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
          }
          sdam.emitServerDescriptionChanged(self, {
            address: self.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: sdam.getTopologyType(self)
          });
          if (!self.s.inTopology) {
            sdam.emitTopologyDescriptionChanged(self, {
              topologyType: "Single",
              servers: [
                {
                  address: self.name,
                  arbiters: [],
                  hosts: [],
                  passives: [],
                  type: sdam.getTopologyType(self)
                }
              ]
            });
          }
          if (self.s.logger.isInfo()) {
            self.s.logger.info(f("server %s connected with ismaster [%s]", self.name, JSON.stringify(self.ismaster)));
          }
          self.emit("connect", self);
        } else if (event === "error" || event === "parseError" || event === "close" || event === "timeout" || event === "reconnect" || event === "attemptReconnect" || event === "reconnectFailed") {
          if (serverAccounting && ["close", "timeout", "error", "parseError", "reconnectFailed"].indexOf(event) !== -1) {
            if (!self.s.inTopology) {
              self.emit("topologyOpening", {topologyId: self.id});
            }
            delete servers[self.id];
          }
          if (event === "close") {
            sdam.emitServerDescriptionChanged(self, {
              address: self.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            });
          }
          if (event === "reconnectFailed") {
            self.emit("reconnectFailed", err);
            if (self.listeners("error").length > 0) {
              self.emit("error", err);
            }
            return;
          }
          if (["disconnected", "connecting"].indexOf(self.s.pool.state) !== -1 && self.initialConnect && ["close", "timeout", "error", "parseError"].indexOf(event) !== -1) {
            self.initialConnect = false;
            return self.emit("error", new MongoNetworkError(f("failed to connect to server [%s] on first connect [%s]", self.name, err)));
          }
          if (event === "reconnect") {
            sdam.emitServerDescriptionChanged(self, {
              address: self.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: sdam.getTopologyType(self)
            });
            return self.emit(event, self);
          }
          self.emit(event, err);
        }
      };
    };
    Server.prototype.connect = function(options2) {
      var self = this;
      options2 = options2 || {};
      if (serverAccounting)
        servers[this.id] = this;
      if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {
        throw new MongoError(f("server instance in invalid state %s", self.s.pool.state));
      }
      self.s.pool = new Pool(this, Object.assign(self.s.options, options2, {bson: this.s.bson}));
      self.s.pool.on("close", eventHandler(self, "close"));
      self.s.pool.on("error", eventHandler(self, "error"));
      self.s.pool.on("timeout", eventHandler(self, "timeout"));
      self.s.pool.on("parseError", eventHandler(self, "parseError"));
      self.s.pool.on("connect", eventHandler(self, "connect"));
      self.s.pool.on("reconnect", eventHandler(self, "reconnect"));
      self.s.pool.on("reconnectFailed", eventHandler(self, "reconnectFailed"));
      relayEvents(self.s.pool, self, ["commandStarted", "commandSucceeded", "commandFailed"]);
      if (!self.s.inTopology) {
        this.emit("topologyOpening", {topologyId: topologyId(self)});
      }
      self.emit("serverOpening", {topologyId: topologyId(self), address: self.name});
      self.s.pool.connect();
    };
    Server.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Server.prototype.getDescription = function() {
      var ismaster = this.ismaster || {};
      var description = {
        type: sdam.getTopologyType(this),
        address: this.name
      };
      if (ismaster.hosts)
        description.hosts = ismaster.hosts;
      if (ismaster.arbiters)
        description.arbiters = ismaster.arbiters;
      if (ismaster.passives)
        description.passives = ismaster.passives;
      if (ismaster.setName)
        description.setName = ismaster.setName;
      return description;
    };
    Server.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Server.prototype.unref = function() {
      this.s.pool.unref();
    };
    Server.prototype.isConnected = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isConnected();
    };
    Server.prototype.isDestroyed = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isDestroyed();
    };
    function basicWriteValidations(self) {
      if (!self.s.pool)
        return new MongoError("server instance is not connected");
      if (self.s.pool.isDestroyed())
        return new MongoError("server instance pool was destroyed");
    }
    function basicReadValidations(self, options2) {
      basicWriteValidations(self, options2);
      if (options2.readPreference && !(options2.readPreference instanceof ReadPreference)) {
        throw new Error("readPreference must be an instance of ReadPreference");
      }
    }
    Server.prototype.command = function(ns, cmd, options2, callback) {
      var self = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicReadValidations(self, options2);
      if (result)
        return callback(result);
      options2 = Object.assign({}, options2, {wireProtocolCommand: false});
      if (self.s.logger.isDebug())
        self.s.logger.debug(f("executing command [%s] against %s", JSON.stringify({
          ns,
          cmd,
          options: debugOptions(debugFields, options2)
        }), self.name));
      if (disconnectHandler(self, "command", ns, cmd, options2, callback))
        return;
      if (collationNotSupported(this, cmd)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      wireProtocol.command(self, ns, cmd, options2, callback);
    };
    Server.prototype.query = function(ns, cmd, cursorState, options2, callback) {
      wireProtocol.query(this, ns, cmd, cursorState, options2, callback);
    };
    Server.prototype.getMore = function(ns, cursorState, batchSize, options2, callback) {
      wireProtocol.getMore(this, ns, cursorState, batchSize, options2, callback);
    };
    Server.prototype.killCursors = function(ns, cursorState, callback) {
      wireProtocol.killCursors(this, ns, cursorState, callback);
    };
    Server.prototype.insert = function(ns, ops, options2, callback) {
      var self = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self, "insert", ns, ops, options2, callback))
        return;
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.insert(self, ns, ops, options2, callback);
    };
    Server.prototype.update = function(ns, ops, options2, callback) {
      var self = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self, "update", ns, ops, options2, callback))
        return;
      if (collationNotSupported(this, options2)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.update(self, ns, ops, options2, callback);
    };
    Server.prototype.remove = function(ns, ops, options2, callback) {
      var self = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self, "remove", ns, ops, options2, callback))
        return;
      if (collationNotSupported(this, options2)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.remove(self, ns, ops, options2, callback);
    };
    Server.prototype.cursor = function(ns, cmd, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options2);
    };
    Server.prototype.equals = function(server) {
      if (typeof server === "string")
        return this.name.toLowerCase() === server.toLowerCase();
      if (server.name)
        return this.name.toLowerCase() === server.name.toLowerCase();
      return false;
    };
    Server.prototype.connections = function() {
      return this.s.pool.allConnections();
    };
    Server.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector, selector = void 0;
      callback(null, this);
    };
    var listeners = ["close", "error", "timeout", "parseError", "connect"];
    Server.prototype.destroy = function(options2, callback) {
      if (this._destroyed) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      var self = this;
      if (serverAccounting)
        delete servers[this.id];
      if (this.monitoringProcessId) {
        clearTimeout(this.monitoringProcessId);
      }
      if (!self.s.pool || this._destroyed) {
        this._destroyed = true;
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      this._destroyed = true;
      if (options2.emitClose) {
        self.emit("close", self);
      }
      if (options2.emitDestroy) {
        self.emit("destroy", self);
      }
      listeners.forEach(function(event) {
        self.s.pool.removeAllListeners(event);
      });
      if (self.listeners("serverClosed").length > 0)
        self.emit("serverClosed", {topologyId: topologyId(self), address: self.name});
      if (self.listeners("topologyClosed").length > 0 && !self.s.inTopology) {
        self.emit("topologyClosed", {topologyId: topologyId(self)});
      }
      if (self.s.logger.isDebug()) {
        self.s.logger.debug(f("destroy called on server %s", self.name));
      }
      this.s.pool.destroy(options2.force, callback);
    };
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/core/topologies/replset_state.js
var require_replset_state = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset_state.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var f = require("util").format;
    var diff = require_shared2().diff;
    var EventEmitter = require("events").EventEmitter;
    var Logger = require_logger();
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var Buffer2 = require_safe_buffer().Buffer;
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    var ReplSetState = function(options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      this.setName = options2.setName;
      this.set = {};
      this.id = options2.id;
      this.setName = options2.setName;
      this.logger = options2.logger || Logger("ReplSet", options2);
      this.index = 0;
      this.acceptableLatency = options2.acceptableLatency || 15;
      this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 1e4;
      this.primary = null;
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
      this.maxElectionId = null;
      this.maxSetVersion = 0;
      this.replicasetDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.logicalSessionTimeoutMinutes = void 0;
    };
    inherits(ReplSetState, EventEmitter);
    ReplSetState.prototype.hasPrimaryAndSecondary = function() {
      return this.primary != null && this.secondaries.length > 0;
    };
    ReplSetState.prototype.hasPrimaryOrSecondary = function() {
      return this.hasPrimary() || this.hasSecondary();
    };
    ReplSetState.prototype.hasPrimary = function() {
      return this.primary != null;
    };
    ReplSetState.prototype.hasSecondary = function() {
      return this.secondaries.length > 0;
    };
    ReplSetState.prototype.get = function(host) {
      var servers = this.allServers();
      for (var i = 0; i < servers.length; i++) {
        if (servers[i].name.toLowerCase() === host.toLowerCase()) {
          return servers[i];
        }
      }
      return null;
    };
    ReplSetState.prototype.allServers = function(options2) {
      options2 = options2 || {};
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      if (!options2.ignoreArbiters)
        servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      return servers;
    };
    ReplSetState.prototype.destroy = function(options2, callback) {
      const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);
      if (this.primary)
        serversToDestroy.push(this.primary);
      let serverCount = serversToDestroy.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        this.secondaries = [];
        this.arbiters = [];
        this.passives = [];
        this.ghosts = [];
        this.unknownServers = [];
        this.set = {};
        this.primary = null;
        emitTopologyDescriptionChanged(this);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      serversToDestroy.forEach((server) => server.destroy(options2, serverDestroyed));
    };
    ReplSetState.prototype.remove = function(server, options2) {
      options2 = options2 || {};
      var serverName = server.name.toLowerCase();
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      for (var i = 0; i < servers.length; i++) {
        if (!options2.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {
          return;
        }
      }
      if (this.set[serverName]) {
        this.set[serverName].type = ServerType.Unknown;
        this.set[serverName].electionId = null;
        this.set[serverName].setName = null;
        this.set[serverName].setVersion = null;
      }
      var removeType = null;
      if (this.primary && this.primary.equals(server)) {
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        removeType = "primary";
      }
      removeType = removeFrom(server, this.secondaries) ? "secondary" : removeType;
      removeType = removeFrom(server, this.arbiters) ? "arbiter" : removeType;
      removeType = removeFrom(server, this.passives) ? "secondary" : removeType;
      removeFrom(server, this.ghosts);
      removeFrom(server, this.unknownServers);
      this.unknownServers.push(serverName);
      if (removeType) {
        this.emit("left", removeType, server);
      }
    };
    var isArbiter = (ismaster) => ismaster.arbiterOnly && ismaster.setName;
    ReplSetState.prototype.update = function(server) {
      var self = this;
      var ismaster = server.lastIsMaster();
      var serverName = server.name.toLowerCase();
      if (ismaster) {
        var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
        hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
        hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
        hosts = hosts.map(function(s2) {
          return s2.toLowerCase();
        });
        for (var i = 0; i < hosts.length; i++) {
          if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {
            this.unknownServers.push(hosts[i].toLowerCase());
          }
          if (!this.set[hosts[i]]) {
            this.set[hosts[i]] = {
              type: ServerType.Unknown,
              electionId: null,
              setName: null,
              setVersion: null
            };
          }
        }
      }
      if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
        self.set[serverName] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self.set[serverName].type = ServerType.Unknown;
        self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
        self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
        self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
        if (self.unknownServers.indexOf(server.name) === -1) {
          self.unknownServers.push(serverName);
        }
        return false;
      }
      if (ismaster.logicalSessionTimeoutMinutes !== void 0 && !isArbiter(ismaster)) {
        if (self.logicalSessionTimeoutMinutes === void 0 || ismaster.logicalSessionTimeoutMinutes === null) {
          self.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;
        } else {
          self.logicalSessionTimeoutMinutes = Math.min(self.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);
        }
      }
      if (ismaster && ismaster.msg === "isdbgrid") {
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        return false;
      }
      if (ismaster.isreplicaset) {
        self.set[serverName] = {
          type: ServerType.RSGhost,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
        }
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {
        self.set[serverName] = {
          type: ServerType.RSOther,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster && ismaster.ismaster && !ismaster.setName) {
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
        this.remove(server, {force: true});
        return false;
      }
      if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
        this.remove(server, {force: true});
        return false;
      }
      if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {
        if (this.logger.isWarn()) {
          this.logger.warn(f("the seedlist server was removed due to its address %s not matching its ismaster.me address %s", server.name, ismaster.me));
        }
        delete this.set[serverName];
        removeFrom(server, self.unknownServers);
        server.destroy({force: true});
        if (this.primary && !this.primary.equals(server)) {
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        if (!this.primary && ismaster.primary) {
          this.set[ismaster.primary.toLowerCase()] = {
            type: ServerType.PossiblePrimary,
            setName: null,
            electionId: null,
            setVersion: null
          };
        }
        return false;
      }
      if (!this.primary && ismaster.ismaster && ismaster.setName) {
        var ismasterElectionId = server.lastIsMaster().electionId;
        if (this.setName && this.setName !== ismaster.setName) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return new MongoError(f("setName from ismaster does not match provided connection setName [%s] != [%s]", ismaster.setName, this.setName));
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          var ismasterSetVersion = server.lastIsMaster().setVersion;
          if (result === 1) {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
            return false;
          } else if (result === 0 && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              this.topologyType = TopologyType.ReplicaSetNoPrimary;
              return false;
            }
          }
          this.maxSetVersion = ismasterSetVersion;
          this.maxElectionId = ismasterElectionId;
        }
        var normalizedHosts = ismaster.hosts.map(function(x) {
          return x.toLowerCase();
        });
        var locationIndex = normalizedHosts.indexOf(serverName);
        if (locationIndex !== -1) {
          self.primary = server;
          self.set[serverName] = {
            type: ServerType.RSPrimary,
            setVersion: ismaster.setVersion,
            electionId: ismaster.electionId,
            setName: ismaster.setName
          };
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
          if (ismaster.setName)
            this.setName = ismaster.setName;
          removeFrom(server, self.unknownServers);
          removeFrom(server, self.secondaries);
          removeFrom(server, self.passives);
          self.emit("joined", "primary", server);
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        emitTopologyDescriptionChanged(self);
        return true;
      } else if (ismaster.ismaster && ismaster.setName) {
        var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;
        var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;
        var currentSetName = self.set[self.primary.name.toLowerCase()].setName;
        ismasterElectionId = server.lastIsMaster().electionId;
        ismasterSetVersion = server.lastIsMaster().setVersion;
        var ismasterSetName = server.lastIsMaster().setName;
        if (this.primary.equals(server) && currentSetName === ismasterSetName) {
          return false;
        }
        if (currentSetName && currentSetName !== ismasterSetName) {
          if (!this.primary.equals(server)) {
            this.topologyType = TopologyType.ReplicaSetWithPrimary;
          } else {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
          }
          return false;
        }
        if (currentElectionId && ismasterElectionId) {
          result = compareObjectIds(currentElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion > ismasterSetVersion) {
            return false;
          }
        } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          } else {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          }
          this.maxElectionId = ismasterElectionId;
          this.maxSetVersion = ismasterSetVersion;
        } else {
          this.maxSetVersion = ismasterSetVersion;
        }
        self.set[self.primary.name.toLowerCase()] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self.emit("left", "primary", this.primary);
        self.primary.destroy({force: true});
        self.primary = server;
        self.set[serverName] = {
          type: ServerType.RSPrimary,
          setVersion: ismaster.setVersion,
          electionId: ismaster.electionId,
          setName: ismaster.setName
        };
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self.unknownServers);
        removeFrom(server, self.secondaries);
        removeFrom(server, self.passives);
        self.emit("joined", "primary", server);
        emitTopologyDescriptionChanged(self);
        return true;
      }
      if (!this.primary && ismaster.primary) {
        self.set[ismaster.primary.toLowerCase()] = {
          type: ServerType.PossiblePrimary,
          setVersion: null,
          electionId: null,
          setName: null
        };
      }
      if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {
        addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({force: true});
          this.primary = null;
          self.emit("left", "primary", server);
        }
        self.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self);
        return true;
      }
      if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {
        addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self.unknownServers);
        self.emit("joined", "arbiter", server);
        emitTopologyDescriptionChanged(self);
        return true;
      }
      if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {
        addToList(self, ServerType.RSSecondary, ismaster, server, this.passives);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({force: true});
          this.primary = null;
          self.emit("left", "primary", server);
        }
        self.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self);
        return true;
      }
      if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {
        self.emit("left", "primary", this.primary);
        this.primary.destroy({force: true});
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return false;
      }
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      return false;
    };
    ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
      var max = 0;
      for (var i = 0; i < this.secondaries.length; i++) {
        max = Math.max(max, this.secondaries[i].lastWriteDate);
      }
      if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
        server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;
      } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
        server.staleness = max - server.lastWriteDate + haInterval;
      }
    };
    ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
      for (var i = 0; i < this.secondaries.length; i++) {
        this.updateServerMaxStaleness(this.secondaries[i], haInterval);
      }
    };
    ReplSetState.prototype.pickServer = function(readPreference) {
      readPreference = readPreference || ReadPreference.primary;
      if (readPreference.preference === "primary" && readPreference.maxStalenessSeconds != null) {
        return new MongoError("primary readPreference incompatible with maxStalenessSeconds");
      }
      var allservers = this.primary ? [this.primary] : [];
      allservers = allservers.concat(this.secondaries);
      if (readPreference.maxStalenessSeconds != null) {
        for (var i = 0; i < allservers.length; i++) {
          if (allservers[i].ismaster.maxWireVersion < 5) {
            return new MongoError("maxStalenessSeconds not supported by at least one of the replicaset members");
          }
        }
      }
      if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds == null) {
        return pickNearest(this, readPreference);
      } else if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds != null) {
        return pickNearestMaxStalenessSeconds(this, readPreference);
      }
      var secondaries = this.secondaries;
      if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {
        return new MongoError("no secondary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {
        return new MongoError("no secondary or primary server available");
      }
      if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
        return new MongoError("no primary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          var server = pickNearest(this, readPreference);
          if (server) {
            return server;
          }
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
          if (server) {
            return server;
          }
        }
        if (readPreference.equals(ReadPreference.secondaryPreferred)) {
          return this.primary;
        }
        return null;
      }
      if (readPreference.equals(ReadPreference.primaryPreferred)) {
        server = null;
        if (this.primary) {
          return this.primary;
        }
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          server = pickNearest(this, readPreference);
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
        }
        if (server)
          return server;
      }
      return this.primary;
    };
    var filterByTags = function(readPreference, servers) {
      if (readPreference.tags == null)
        return servers;
      var filteredServers = [];
      var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
      for (var j = 0; j < tagsArray.length; j++) {
        var tags = tagsArray[j];
        for (var i = 0; i < servers.length; i++) {
          var serverTag = servers[i].lastIsMaster().tags || {};
          var found = true;
          for (var name in tags) {
            if (serverTag[name] !== tags[name]) {
              found = false;
            }
          }
          if (found) {
            filteredServers.push(servers[i]);
          }
        }
      }
      return filteredServers;
    };
    function pickNearestMaxStalenessSeconds(self, readPreference) {
      var servers = [];
      var maxStalenessMS = readPreference.maxStalenessSeconds * 1e3;
      if (maxStalenessMS < 90 * 1e3) {
        return new MongoError("maxStalenessSeconds must be set to at least 90 seconds");
      }
      if (self.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self.primary);
      }
      for (var i = 0; i < self.secondaries.length; i++) {
        servers.push(self.secondaries[i]);
      }
      if (self.primary && servers.length === 0 && readPreference.preference !== "secondaryPreferred") {
        servers.push(self.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers = servers.filter(function(s2) {
        return s2.staleness <= maxStalenessMS;
      });
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      if (servers.length === 0) {
        return null;
      }
      self.index = self.index % servers.length;
      var server = servers[self.index];
      self.index = self.index + 1;
      return server;
    }
    function pickNearest(self, readPreference) {
      var servers = [];
      if (self.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self.primary);
      }
      for (var i = 0; i < self.secondaries.length; i++) {
        servers.push(self.secondaries[i]);
      }
      if (servers.length === 0 && self.primary && readPreference.preference !== "secondaryPreferred") {
        servers.push(self.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
      servers = servers.filter(function(s2) {
        return s2.lastIsMasterMS <= lowest + self.acceptableLatency;
      });
      if (servers.length === 0) {
        return null;
      }
      self.index = self.index % servers.length;
      var server = servers[self.index];
      self.index = self.index + 1;
      return server;
    }
    function inList(ismaster, server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      return false;
    }
    function addToList(self, type, ismaster, server, list) {
      var serverName = server.name.toLowerCase();
      self.set[serverName].type = type;
      self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
      self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
      self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
      list.push(server);
    }
    function compareObjectIds(id1, id2) {
      var a = Buffer2.from(id1.toHexString(), "hex");
      var b = Buffer2.from(id2.toHexString(), "hex");
      if (a === b) {
        return 0;
      }
      if (typeof Buffer2.compare === "function") {
        return Buffer2.compare(a, b);
      }
      var x = a.length;
      var y = b.length;
      var len = Math.min(x, y);
      for (var i = 0; i < len; i++) {
        if (a[i] !== b[i]) {
          break;
        }
      }
      if (i !== len) {
        x = a[i];
        y = b[i];
      }
      return x < y ? -1 : y < x ? 1 : 0;
    }
    function removeFrom(server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].equals && list[i].equals(server)) {
          list.splice(i, 1);
          return true;
        } else if (typeof list[i] === "string" && list[i].toLowerCase() === server.name.toLowerCase()) {
          list.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    function emitTopologyDescriptionChanged(self) {
      if (self.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        var setName = self.setName;
        if (self.hasPrimaryAndSecondary()) {
          topology = "ReplicaSetWithPrimary";
        } else if (!self.hasPrimary() && self.hasSecondary()) {
          topology = "ReplicaSetNoPrimary";
        }
        var description = {
          topologyType: topology,
          setName,
          servers: []
        };
        if (self.hasPrimary()) {
          var desc = self.primary.getDescription();
          desc.type = "RSPrimary";
          description.servers.push(desc);
        }
        description.servers = description.servers.concat(self.secondaries.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        description.servers = description.servers.concat(self.arbiters.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSArbiter";
          return description2;
        }));
        description.servers = description.servers.concat(self.passives.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        var diffResult = diff(self.replicasetDescription, description);
        var result = {
          topologyId: self.id,
          previousDescription: self.replicasetDescription,
          newDescription: description,
          diff: diffResult
        };
        self.emit("topologyDescriptionChanged", result);
        self.replicasetDescription = description;
      }
    }
    module2.exports = ReplSetState;
  }
});

// node_modules/mongodb/lib/core/topologies/replset.js
var require_replset = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var CoreCursor = require_cursor().CoreCursor;
    var retrieveBSON = require_utils3().retrieveBSON;
    var Logger = require_logger();
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var ReplSetState = require_replset_state();
    var Timeout = require_shared2().Timeout;
    var Interval = require_shared2().Interval;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYED = "destroyed";
    function stateTransition(self, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self.state = newState;
      } else {
        self.s.logger.error(f("Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self.id, self.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var ReplSet = function(seedlist, options2) {
      var self = this;
      options2 = options2 || {};
      if (!Array.isArray(seedlist))
        throw new MongoError("seedlist must be an array");
      if (seedlist.length === 0)
        throw new MongoError("seedlist must contain at least one entry");
      seedlist.forEach(function(e) {
        if (typeof e.host !== "string" || typeof e.port !== "number")
          throw new MongoError("seedlist entry must contain a host and port");
      });
      EventEmitter.call(this);
      this.id = id++;
      var localThresholdMS = options2.localThresholdMS || 15;
      if (options2.acceptableLatency)
        localThresholdMS = options2.acceptableLatency;
      var logger = Logger("ReplSet", options2);
      this.s = {
        options: Object.assign({metadata: makeClientMetadata(options2)}, options2),
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options2.cursorFactory || CoreCursor,
        logger,
        seedlist,
        replicaSetState: new ReplSetState({
          id: this.id,
          setName: options2.setName,
          acceptableLatency: localThresholdMS,
          heartbeatFrequencyMS: options2.haInterval ? options2.haInterval : 1e4,
          logger
        }),
        connectingServers: [],
        haInterval: options2.haInterval ? options2.haInterval : 1e4,
        minHeartbeatFrequencyMS: 500,
        disconnectHandler: options2.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options2.debug === "boolean" ? options2.debug : false
      };
      this.s.replicaSetState.on("topologyDescriptionChanged", function(r) {
        self.emit("topologyDescriptionChanged", r);
      });
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      var types2 = ["joined", "left"];
      types2.forEach(function(x) {
        self.s.replicaSetState.on(x, function(t, s2) {
          self.emit(x, t, s2);
        });
      });
      this.initialConnectState = {
        connect: false,
        fullsetup: false,
        all: false
      };
      this.state = DISCONNECTED;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.intervalIds = [];
      this.clusterTime = null;
    };
    inherits(ReplSet, EventEmitter);
    Object.assign(ReplSet.prototype, SessionMixins);
    Object.defineProperty(ReplSet.prototype, "type", {
      enumerable: true,
      get: function() {
        return "replset";
      }
    });
    Object.defineProperty(ReplSet.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(ReplSet.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;
      }
    });
    function rexecuteOperations(self) {
      if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {
        self.s.disconnectHandler.execute();
      } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {
        self.s.disconnectHandler.execute({executePrimary: true});
      } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {
        self.s.disconnectHandler.execute({executeSecondary: true});
      }
    }
    function connectNewServers(self, servers, callback) {
      if (servers.length === 0) {
        return callback();
      }
      var count = servers.length;
      var error3 = null;
      function done() {
        count = count - 1;
        if (count === 0) {
          callback(error3);
        }
      }
      var _handleEvent = function(self2, event) {
        return function(err) {
          var _self = this;
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            this.destroy({force: true});
            return done();
          }
          if (event === "connect") {
            var result = self2.s.replicaSetState.update(_self);
            if (result) {
              if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
                self2.ismaster = _self.lastIsMaster();
              }
              for (let i2 = 0; i2 < handlers.length; i2++) {
                _self.removeAllListeners(handlers[i2]);
              }
              _self.on("error", handleEvent(self2, "error"));
              _self.on("close", handleEvent(self2, "close"));
              _self.on("timeout", handleEvent(self2, "timeout"));
              _self.on("parseError", handleEvent(self2, "parseError"));
              monitorServer(_self.lastIsMaster().me, self2, {});
              rexecuteOperations(self2);
            } else {
              _self.destroy({force: true});
            }
          } else if (event === "error") {
            error3 = err;
          }
          rexecuteOperations(self2);
          done();
        };
      };
      function execute(_server, i2) {
        setTimeout(function() {
          if (self.state === DESTROYED || self.state === UNREFERENCED) {
            return;
          }
          const existingServerIdx = self.s.connectingServers.findIndex((s2) => s2.name === _server);
          if (existingServerIdx >= 0) {
            const connectingServer = self.s.connectingServers[existingServerIdx];
            connectingServer.destroy({force: true});
            self.s.connectingServers.splice(existingServerIdx, 1);
            return done();
          }
          var server = new Server(Object.assign({}, self.s.options, {
            host: _server.split(":")[0],
            port: parseInt(_server.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self
          }));
          server.once("connect", _handleEvent(self, "connect"));
          server.once("close", _handleEvent(self, "close"));
          server.once("timeout", _handleEvent(self, "timeout"));
          server.once("error", _handleEvent(self, "error"));
          server.once("parseError", _handleEvent(self, "parseError"));
          server.on("serverOpening", (e) => self.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self.emit("serverClosed", e));
          relayEvents(server, self, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self.s.connectingServers.push(server);
          server.connect(self.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < servers.length; i++) {
        execute(servers[i], i);
      }
    }
    var pingServer = function(self, server, cb) {
      var start = new Date().getTime();
      emitSDAMEvent(self, "serverHeartbeatStarted", {connectionId: server.name});
      server.command("admin.$cmd", {
        ismaster: true
      }, {
        monitoring: true,
        socketTimeout: self.s.options.connectionTimeout || 2e3
      }, function(err, r) {
        if (self.state === DESTROYED || self.state === UNREFERENCED) {
          server.destroy({force: true});
          return cb(err, r);
        }
        var latencyMS = new Date().getTime() - start;
        server.lastUpdateTime = now();
        if (err) {
          emitSDAMEvent(self, "serverHeartbeatFailed", {
            durationMS: latencyMS,
            failure: err,
            connectionId: server.name
          });
          self.s.replicaSetState.remove(server);
        } else {
          server.ismaster = r.result;
          if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
            server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
          }
          if (server.lastIsMasterMS === -1) {
            server.lastIsMasterMS = latencyMS;
          } else if (server.lastIsMasterMS) {
            server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
          }
          if (self.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self.ismaster = server.lastIsMaster();
            }
          }
          emitSDAMEvent(self, "serverHeartbeatSucceeded", {
            durationMS: latencyMS,
            reply: r.result,
            connectionId: server.name
          });
        }
        self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval);
        cb(err, r);
      });
    };
    var monitorServer = function(host, self, options2) {
      if (!options2.haInterval) {
        for (var i = 0; i < self.intervalIds.length; i++) {
          if (self.intervalIds[i].__host === host) {
            return;
          }
        }
      }
      var _process = options2.haInterval ? Timeout : Interval;
      var _haInterval = options2.haInterval ? options2.haInterval : self.s.haInterval;
      var intervalId = new _process(function() {
        if (self.state === DESTROYED || self.state === UNREFERENCED) {
          intervalId.stop();
          return;
        }
        var _server = self.s.replicaSetState.get(host);
        if (_server) {
          return pingServer(self, _server, function(err) {
            if (err) {
              return;
            }
            if (self.state === DESTROYED || self.state === UNREFERENCED) {
              intervalId.stop();
              return;
            }
            self.intervalIds = self.intervalIds.filter(function(intervalId2) {
              return intervalId2.isRunning();
            });
            if (_process === Timeout) {
              if (self.state === CONNECTING && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {
                stateTransition(self, CONNECTED);
                process.nextTick(function() {
                  self.emit("connect", self);
                });
                topologyMonitor(self, {});
              }
            } else {
              if (self.state === DISCONNECTED && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {
                stateTransition(self, CONNECTING);
                rexecuteOperations(self);
                process.nextTick(function() {
                  self.emit("reconnect", self);
                });
              }
            }
            if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {
              self.initialConnectState.fullsetup = true;
              self.initialConnectState.all = true;
              process.nextTick(function() {
                self.emit("fullsetup", self);
                self.emit("all", self);
              });
            }
          });
        }
      }, _haInterval);
      intervalId.start();
      intervalId.__host = host;
      self.intervalIds.push(intervalId);
    };
    function topologyMonitor(self, options2) {
      if (self.state === DESTROYED || self.state === UNREFERENCED)
        return;
      options2 = options2 || {};
      var servers = Object.keys(self.s.replicaSetState.set);
      var _process = options2.haInterval ? Timeout : Interval;
      var _haInterval = options2.haInterval ? options2.haInterval : self.s.haInterval;
      if (_process === Timeout) {
        return connectNewServers(self, self.s.replicaSetState.unknownServers, function(err) {
          if (self.state === DESTROYED || self.state === UNREFERENCED) {
            return;
          }
          if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self.emit("error", err);
            }
            self.emit("error", new MongoError("no primary found in replicaset or invalid replica set name"));
            return self.destroy({force: true});
          } else if (!self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self.emit("error", err);
            }
            self.emit("error", new MongoError("no secondary found in replicaset or invalid replica set name"));
            return self.destroy({force: true});
          }
          for (var i2 = 0; i2 < servers.length; i2++) {
            monitorServer(servers[i2], self, options2);
          }
        });
      } else {
        for (var i = 0; i < servers.length; i++) {
          monitorServer(servers[i], self, options2);
        }
      }
      function executeReconnect(self2) {
        return function() {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          connectNewServers(self2, self2.s.replicaSetState.unknownServers, function() {
            var monitoringFrequencey = self2.s.replicaSetState.hasPrimary() ? _haInterval : self2.s.minHeartbeatFrequencyMS;
            self2.intervalIds.push(new Timeout(executeReconnect(self2), monitoringFrequencey).start());
          });
        };
      }
      var intervalTime = !self.s.replicaSetState.hasPrimary() ? self.s.minHeartbeatFrequencyMS : _haInterval;
      self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());
    }
    function addServerToList(list, server) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      list.push(server);
    }
    function handleEvent(self, event) {
      return function() {
        if (self.state === DESTROYED || self.state === UNREFERENCED)
          return;
        if (self.s.logger.isDebug()) {
          self.s.logger.debug(f("handleEvent %s from server %s in replset with id %s", event, this.name, self.id));
        }
        self.s.replicaSetState.remove(this);
        if (self.state === DESTROYED || self.state === UNREFERENCED)
          return;
        if (!self.s.replicaSetState.hasPrimary() && !self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {
          stateTransition(self, DISCONNECTED);
        } else if (!self.s.replicaSetState.hasPrimary()) {
          stateTransition(self, DISCONNECTED);
        }
        addServerToList(self.s.connectingServers, this);
      };
    }
    function shouldTriggerConnect(self) {
      const isConnecting = self.state === CONNECTING;
      const hasPrimary = self.s.replicaSetState.hasPrimary();
      const hasSecondary = self.s.replicaSetState.hasSecondary();
      const secondaryOnlyConnectionAllowed = self.s.options.secondaryOnlyConnectionAllowed;
      const readPreferenceSecondary = self.s.connectOptions.readPreference && self.s.connectOptions.readPreference.equals(ReadPreference.secondary);
      return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;
    }
    function handleInitialConnectEvent(self, event) {
      return function() {
        var _this = this;
        if (self.s.logger.isDebug()) {
          self.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s", event, this.name, self.id));
        }
        if (self.state === DESTROYED || self.state === UNREFERENCED) {
          return this.destroy({force: true});
        }
        if (event === "connect") {
          var result = self.s.replicaSetState.update(_this);
          if (result === true) {
            if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
              self.ismaster = _this.lastIsMaster();
            }
            if (self.s.logger.isDebug()) {
              self.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]", event, _this.name, self.id, JSON.stringify(self.s.replicaSetState.set)));
            }
            for (let i2 = 0; i2 < handlers.length; i2++) {
              _this.removeAllListeners(handlers[i2]);
            }
            _this.on("error", handleEvent(self, "error"));
            _this.on("close", handleEvent(self, "close"));
            _this.on("timeout", handleEvent(self, "timeout"));
            _this.on("parseError", handleEvent(self, "parseError"));
            if (shouldTriggerConnect(self)) {
              stateTransition(self, CONNECTED);
              self.initialConnectState.connect = true;
              process.nextTick(function() {
                self.emit("connect", self);
              });
              topologyMonitor(self, {});
            }
          } else if (result instanceof MongoError) {
            _this.destroy({force: true});
            self.destroy({force: true});
            return self.emit("error", result);
          } else {
            _this.destroy({force: true});
          }
        } else {
          self.emit("failed", this);
          addServerToList(self.s.connectingServers, this);
          self.s.replicaSetState.remove(this);
        }
        if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {
          self.initialConnectState.fullsetup = true;
          self.initialConnectState.all = true;
          process.nextTick(function() {
            self.emit("fullsetup", self);
            self.emit("all", self);
          });
        }
        for (var i = 0; i < self.s.connectingServers.length; i++) {
          if (self.s.connectingServers[i].equals(this)) {
            self.s.connectingServers.splice(i, 1);
          }
        }
        if (self.s.connectingServers.length === 0 && self.state === CONNECTING) {
          topologyMonitor(self, {haInterval: 1});
        }
      };
    }
    function connectServers(self, servers) {
      self.s.connectingServers = self.s.connectingServers.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          if (self.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self.ismaster = server.lastIsMaster();
            }
          }
          server.once("close", handleInitialConnectEvent(self, "close"));
          server.once("timeout", handleInitialConnectEvent(self, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self, "parseError"));
          server.once("error", handleInitialConnectEvent(self, "error"));
          server.once("connect", handleInitialConnectEvent(self, "connect"));
          server.on("serverOpening", (e) => self.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self.emit("serverClosed", e));
          relayEvents(server, self, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self.s.connectOptions);
        }, timeoutInterval2);
      }
      while (servers.length > 0) {
        connect(servers.shift(), timeoutInterval++);
      }
    }
    function emitSDAMEvent(self, event, description) {
      if (self.listeners(event).length > 0) {
        self.emit(event, description);
      }
    }
    ReplSet.prototype.connect = function(options2) {
      var self = this;
      this.s.connectOptions = options2 || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        return new Server(Object.assign({}, self.s.options, x, options2, {
          reconnect: false,
          monitoring: false,
          parent: self
        }));
      });
      if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {
        return self.emit("error", new MongoError(f("haInterval [%s] MS must be set to less than socketTimeout [%s] MS", this.s.options.haInterval, this.s.options.socketTimeout)));
      }
      emitSDAMEvent(this, "topologyOpening", {topologyId: this.id});
      connectServers(self, servers);
    };
    ReplSet.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    ReplSet.prototype.destroy = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      let destroyCount = this.s.connectingServers.length + 1;
      const serverDestroyed = () => {
        destroyCount--;
        if (destroyCount > 0) {
          return;
        }
        emitSDAMEvent(this, "topologyClosed", {topologyId: this.id});
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (this.state === DESTROYED) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DESTROYED);
      if (this.haTimeoutId)
        clearTimeout(this.haTimeoutId);
      for (var i = 0; i < this.intervalIds.length; i++) {
        this.intervalIds[i].stop();
      }
      this.intervalIds = [];
      if (destroyCount === 0) {
        serverDestroyed();
        return;
      }
      this.s.replicaSetState.destroy(options2, serverDestroyed);
      this.s.connectingServers.forEach(function(x) {
        x.destroy(options2, serverDestroyed);
      });
    };
    ReplSet.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      this.s.replicaSetState.allServers().forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    ReplSet.prototype.lastIsMaster = function() {
      if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {
        return this.s.replicaSetState.secondaries[0].lastIsMaster();
      }
      return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
    };
    ReplSet.prototype.connections = function() {
      var servers = this.s.replicaSetState.allServers();
      var connections = [];
      for (var i = 0; i < servers.length; i++) {
        connections = connections.concat(servers[i].connections());
      }
      return connections;
    };
    ReplSet.prototype.isConnected = function(options2) {
      options2 = options2 || {};
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.secondary)) {
        return this.s.replicaSetState.hasSecondary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.primary)) {
        return this.s.replicaSetState.hasPrimary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.primaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.secondaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
        return true;
      }
      return this.s.replicaSetState.hasPrimary();
    };
    ReplSet.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    var SERVER_SELECTION_TIMEOUT_MS = 1e4;
    var SERVER_SELECTION_INTERVAL_MS = 1e3;
    ReplSet.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector;
      options2 = options2 || {};
      let readPreference;
      if (selector instanceof ReadPreference) {
        readPreference = selector;
      } else {
        readPreference = options2.readPreference || ReadPreference.primary;
      }
      let lastError;
      const start = now();
      const _selectServer = () => {
        if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {
          if (lastError != null) {
            callback(lastError, null);
          } else {
            callback(new MongoError("Server selection timed out"));
          }
          return;
        }
        const server = this.s.replicaSetState.pickServer(readPreference);
        if (server == null) {
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (!(server instanceof Server)) {
          lastError = server;
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (this.s.debug)
          this.emit("pickedServer", options2.readPreference, server);
        callback(null, server);
      };
      _selectServer();
    };
    ReplSet.prototype.getServers = function() {
      return this.s.replicaSetState.allServers();
    };
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const self = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      if (self.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self) && !options2.session.inTransaction() && options2.explain === void 0;
      if (!self.s.replicaSetState.hasPrimary()) {
        if (self.s.disconnectHandler) {
          return self.s.disconnectHandler.add(op, ns, ops, options2, callback);
        } else if (!willRetryWrite) {
          return callback(new MongoError("no primary server found"));
        }
      }
      const handler2 = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self)) {
          err = getMMAPError(err);
          return callback(err);
        }
        if (willRetryWrite) {
          const newArgs = Object.assign({}, args, {retrying: true});
          return executeWriteOperation(newArgs, options2, callback);
        }
        if (self.s.replicaSetState.primary) {
          self.s.replicaSetState.primary.destroy();
          self.s.replicaSetState.remove(self.s.replicaSetState.primary, {force: true});
        }
        return callback(err);
      };
      if (callback.operationId) {
        handler2.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      self.s.replicaSetState.primary[op](ns, ops, options2, handler2);
    }
    ReplSet.prototype.insert = function(ns, ops, options2, callback) {
      executeWriteOperation({self: this, op: "insert", ns, ops}, options2, callback);
    };
    ReplSet.prototype.update = function(ns, ops, options2, callback) {
      executeWriteOperation({self: this, op: "update", ns, ops}, options2, callback);
    };
    ReplSet.prototype.remove = function(ns, ops, options2, callback) {
      executeWriteOperation({self: this, op: "remove", ns, ops}, options2, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    ReplSet.prototype.command = function(ns, cmd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED)
        return callback(new MongoError(f("topology was destroyed")));
      var self = this;
      var readPreference = options2.readPreference ? options2.readPreference : ReadPreference.primary;
      if (readPreference.preference === "primary" && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      } else if (readPreference.preference === "secondary" && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      } else if (readPreference.preference !== "primary" && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      }
      var server = this.s.replicaSetState.pickServer(readPreference);
      if (!(server instanceof Server))
        return callback(server);
      if (self.s.debug)
        self.emit("pickedServer", ReadPreference.primary, server);
      if (server == null) {
        return callback(new MongoError(f("no server found that matches the provided readPreference %s", readPreference)));
      }
      const willRetryWrite = !options2.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self) && !options2.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, options2, {retrying: true});
          return this.command(ns, cmd, newOptions, callback);
        }
        if (this.s.replicaSetState.primary) {
          this.s.replicaSetState.primary.destroy();
          this.s.replicaSetState.remove(this.s.replicaSetState.primary, {force: true});
        }
        return callback(err);
      };
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, options2, cb);
    };
    ReplSet.prototype.cursor = function(ns, cmd, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options2);
    };
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/core/topologies/mongos.js
var require_mongos = __commonJS({
  "node_modules/mongodb/lib/core/topologies/mongos.js"(exports2, module2) {
    "use strict";
    var inherits = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var CoreCursor = require_cursor().CoreCursor;
    var Logger = require_logger();
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var diff = require_shared2().diff;
    var cloneOptions = require_shared2().cloneOptions;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    function stateTransition(self, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYING, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYING, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self.state = newState;
      } else {
        self.s.logger.error(f("Mongos with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self.id, self.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var Mongos = function(seedlist, options2) {
      options2 = options2 || {};
      this.id = id++;
      if (Array.isArray(seedlist)) {
        seedlist = seedlist.reduce((seeds, seed) => {
          if (seeds.find((s2) => s2.host === seed.host && s2.port === seed.port)) {
            return seeds;
          }
          seeds.push(seed);
          return seeds;
        }, []);
      }
      this.s = {
        options: Object.assign({metadata: makeClientMetadata(options2)}, options2),
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options2.cursorFactory || CoreCursor,
        logger: Logger("Mongos", options2),
        seedlist,
        haInterval: options2.haInterval ? options2.haInterval : 1e4,
        disconnectHandler: options2.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options2.debug === "boolean" ? options2.debug : false,
        localThresholdMS: options2.localThresholdMS || 15
      };
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      this.state = DISCONNECTED;
      this.connectingProxies = [];
      this.connectedProxies = [];
      this.disconnectedProxies = [];
      this.index = 0;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.topologyDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.clusterTime = null;
      EventEmitter.call(this);
    };
    inherits(Mongos, EventEmitter);
    Object.assign(Mongos.prototype, SessionMixins);
    Object.defineProperty(Mongos.prototype, "type", {
      enumerable: true,
      get: function() {
        return "mongos";
      }
    });
    Object.defineProperty(Mongos.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Mongos.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    function emitSDAMEvent(self, event, description) {
      if (self.listeners(event).length > 0) {
        self.emit(event, description);
      }
    }
    var SERVER_EVENTS = ["serverDescriptionChanged", "error", "close", "timeout", "parseError"];
    function destroyServer(server, options2, callback) {
      options2 = options2 || {};
      SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options2, callback);
    }
    Mongos.prototype.connect = function(options2) {
      var self = this;
      this.s.connectOptions = options2 || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        const server = new Server(Object.assign({}, self.s.options, x, options2, {
          reconnect: false,
          monitoring: false,
          parent: self
        }));
        relayEvents(server, self, ["serverDescriptionChanged"]);
        return server;
      });
      emitSDAMEvent(this, "topologyOpening", {topologyId: this.id});
      connectProxies(self, servers);
    };
    Mongos.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    function handleEvent(self) {
      return function() {
        if (self.state === DESTROYED || self.state === DESTROYING) {
          return;
        }
        moveServerFrom(self.connectedProxies, self.disconnectedProxies, this);
        emitTopologyDescriptionChanged(self);
        self.emit("left", "mongos", this);
        self.emit("serverClosed", {
          topologyId: self.id,
          address: this.name
        });
      };
    }
    function handleInitialConnectEvent(self, event) {
      return function() {
        var _this = this;
        if (self.state === DESTROYED) {
          emitTopologyDescriptionChanged(self);
          moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
          return this.destroy();
        }
        if (event === "connect") {
          self.ismaster = _this.lastIsMaster();
          if (self.ismaster.msg === "isdbgrid") {
            for (let i = 0; i < self.connectedProxies.length; i++) {
              if (self.connectedProxies[i].name === _this.name) {
                moveServerFrom(self.connectingProxies, self.disconnectedProxies, _this);
                emitTopologyDescriptionChanged(self);
                _this.destroy();
                return self.emit("failed", _this);
              }
            }
            for (let i = 0; i < handlers.length; i++) {
              _this.removeAllListeners(handlers[i]);
            }
            _this.on("error", handleEvent(self, "error"));
            _this.on("close", handleEvent(self, "close"));
            _this.on("timeout", handleEvent(self, "timeout"));
            _this.on("parseError", handleEvent(self, "parseError"));
            moveServerFrom(self.connectingProxies, self.connectedProxies, _this);
            self.emit("joined", "mongos", _this);
          } else {
            if (self.s.logger.isWarn()) {
              var message = "expected mongos proxy, but found replicaset member mongod for server %s";
              if (!self.ismaster.hosts) {
                message = "expected mongos proxy, but found standalone mongod for server %s";
              }
              self.s.logger.warn(f(message, _this.name));
            }
            _this.destroy(true);
            removeProxyFrom(self.connectingProxies, _this);
            self.emit("left", "server", _this);
            self.emit("failed", _this);
          }
        } else {
          moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
          self.emit("left", "mongos", this);
          self.emit("failed", this);
        }
        emitTopologyDescriptionChanged(self);
        if (self.connectingProxies.length === 0) {
          if (self.connectedProxies.length > 0 && self.state === CONNECTING) {
            stateTransition(self, CONNECTED);
            self.emit("connect", self);
            self.emit("fullsetup", self);
            self.emit("all", self);
          } else if (self.disconnectedProxies.length === 0) {
            if (self.s.logger.isWarn()) {
              self.s.logger.warn(f("no mongos proxies found in seed list, did you mean to connect to a replicaset"));
            }
            return self.emit("error", new MongoError("no mongos proxies found in seed list"));
          }
          topologyMonitor(self, {firstConnect: true});
        }
      };
    }
    function connectProxies(self, servers) {
      self.connectingProxies = self.connectingProxies.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          self.emit("serverOpening", {
            topologyId: self.id,
            address: server.name
          });
          emitTopologyDescriptionChanged(self);
          server.once("close", handleInitialConnectEvent(self, "close"));
          server.once("timeout", handleInitialConnectEvent(self, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self, "parseError"));
          server.once("error", handleInitialConnectEvent(self, "error"));
          server.once("connect", handleInitialConnectEvent(self, "connect"));
          relayEvents(server, self, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self.s.connectOptions);
        }, timeoutInterval2);
      }
      servers.forEach((server) => connect(server, timeoutInterval++));
    }
    function pickProxy(self, session) {
      const transaction = session && session.transaction;
      if (transaction && transaction.server) {
        if (transaction.server.isConnected()) {
          return transaction.server;
        } else {
          transaction.unpinServer();
        }
      }
      var connectedProxies = self.connectedProxies.slice(0);
      var lowerBoundLatency = Number.MAX_VALUE;
      for (var i = 0; i < connectedProxies.length; i++) {
        if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
          lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
        }
      }
      connectedProxies = connectedProxies.filter(function(server) {
        if (server.lastIsMasterMS <= lowerBoundLatency + self.s.localThresholdMS && server.isConnected()) {
          return true;
        }
      });
      let proxy;
      if (connectedProxies.length === 0) {
        proxy = self.connectedProxies[0];
      } else {
        proxy = connectedProxies[self.index % connectedProxies.length];
        self.index = (self.index + 1) % connectedProxies.length;
      }
      if (transaction && transaction.isActive && proxy && proxy.isConnected()) {
        transaction.pinServer(proxy);
      }
      return proxy;
    }
    function moveServerFrom(from, to, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
      for (i = 0; i < to.length; i++) {
        if (to[i].name === proxy.name) {
          to.splice(i, 1);
        }
      }
      to.push(proxy);
    }
    function removeProxyFrom(from, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
    }
    function reconnectProxies(self, proxies, callback) {
      var count = proxies.length;
      var _handleEvent = function(self2, event) {
        return function() {
          var _self = this;
          count = count - 1;
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _self);
            return this.destroy();
          }
          if (event === "connect") {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _self);
              return _self.destroy();
            }
            for (var i2 = 0; i2 < handlers.length; i2++) {
              _self.removeAllListeners(handlers[i2]);
            }
            _self.on("error", handleEvent(self2, "error"));
            _self.on("close", handleEvent(self2, "close"));
            _self.on("timeout", handleEvent(self2, "timeout"));
            _self.on("parseError", handleEvent(self2, "parseError"));
            moveServerFrom(self2.connectingProxies, self2.connectedProxies, _self);
            emitTopologyDescriptionChanged(self2);
            self2.emit("joined", "mongos", _self);
          } else {
            moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _self);
            this.destroy();
          }
          if (count === 0) {
            callback();
          }
        };
      };
      if (count === 0) {
        return callback();
      }
      function execute(_server, i2) {
        setTimeout(function() {
          if (self.state === DESTROYED || self.state === DESTROYING || self.state === UNREFERENCED) {
            return;
          }
          var server = new Server(Object.assign({}, self.s.options, {
            host: _server.name.split(":")[0],
            port: parseInt(_server.name.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self
          }));
          destroyServer(_server, {force: true});
          removeProxyFrom(self.disconnectedProxies, _server);
          relayEvents(server, self, ["serverDescriptionChanged"]);
          self.emit("serverOpening", {
            topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self.id,
            address: server.name
          });
          server.once("connect", _handleEvent(self, "connect"));
          server.once("close", _handleEvent(self, "close"));
          server.once("timeout", _handleEvent(self, "timeout"));
          server.once("error", _handleEvent(self, "error"));
          server.once("parseError", _handleEvent(self, "parseError"));
          relayEvents(server, self, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self.connectingProxies.push(server);
          server.connect(self.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < proxies.length; i++) {
        execute(proxies[i], i);
      }
    }
    function topologyMonitor(self, options2) {
      options2 = options2 || {};
      if (self.state === DESTROYED || self.state === DESTROYING || self.state === UNREFERENCED) {
        return;
      }
      self.haTimeoutId = setTimeout(function() {
        if (self.state === DESTROYED || self.state === DESTROYING || self.state === UNREFERENCED) {
          return;
        }
        if (self.isConnected() && self.s.disconnectHandler) {
          self.s.disconnectHandler.execute();
        }
        var proxies = self.connectedProxies.slice(0);
        var count = proxies.length;
        function pingServer(_self, _server, cb) {
          var start = new Date().getTime();
          emitSDAMEvent(self, "serverHeartbeatStarted", {connectionId: _server.name});
          _server.command("admin.$cmd", {
            ismaster: true
          }, {
            monitoring: true,
            socketTimeout: self.s.options.connectionTimeout || 2e3
          }, function(err, r) {
            if (self.state === DESTROYED || self.state === DESTROYING || self.state === UNREFERENCED) {
              moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
              _server.destroy();
              return cb(err, r);
            }
            var latencyMS = new Date().getTime() - start;
            if (err) {
              emitSDAMEvent(self, "serverHeartbeatFailed", {
                durationMS: latencyMS,
                failure: err,
                connectionId: _server.name
              });
              moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
            } else {
              _server.ismaster = r.result;
              _server.lastIsMasterMS = latencyMS;
              emitSDAMEvent(self, "serverHeartbeatSucceeded", {
                durationMS: latencyMS,
                reply: r.result,
                connectionId: _server.name
              });
            }
            cb(err, r);
          });
        }
        if (proxies.length === 0) {
          if (self.listeners("close").length > 0 && self.state === CONNECTING) {
            self.emit("error", new MongoError("no mongos proxy available"));
          } else {
            self.emit("close", self);
          }
          return reconnectProxies(self, self.disconnectedProxies, function() {
            if (self.state === DESTROYED || self.state === DESTROYING || self.state === UNREFERENCED) {
              return;
            }
            if (self.state === CONNECTING && options2.firstConnect) {
              self.emit("connect", self);
              self.emit("fullsetup", self);
              self.emit("all", self);
            } else if (self.isConnected()) {
              self.emit("reconnect", self);
            } else if (!self.isConnected() && self.listeners("close").length > 0) {
              self.emit("close", self);
            }
            topologyMonitor(self);
          });
        }
        for (var i = 0; i < proxies.length; i++) {
          pingServer(self, proxies[i], function() {
            count = count - 1;
            if (count === 0) {
              if (self.state === DESTROYED || self.state === DESTROYING || self.state === UNREFERENCED) {
                return;
              }
              reconnectProxies(self, self.disconnectedProxies, function() {
                if (self.state === DESTROYED || self.state === DESTROYING || self.state === UNREFERENCED) {
                  return;
                }
                topologyMonitor(self);
              });
            }
          });
        }
      }, self.s.haInterval);
    }
    Mongos.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Mongos.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      var proxies = this.connectedProxies.concat(this.connectingProxies);
      proxies.forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    Mongos.prototype.destroy = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      stateTransition(this, DESTROYING);
      if (this.haTimeoutId) {
        clearTimeout(this.haTimeoutId);
      }
      const proxies = this.connectedProxies.concat(this.connectingProxies);
      let serverCount = proxies.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        emitTopologyDescriptionChanged(this);
        emitSDAMEvent(this, "topologyClosed", {topologyId: this.id});
        stateTransition(this, DESTROYED);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      proxies.forEach((server) => {
        this.emit("serverClosed", {
          topologyId: this.id,
          address: server.name
        });
        destroyServer(server, options2, serverDestroyed);
        moveServerFrom(this.connectedProxies, this.disconnectedProxies, server);
      });
    };
    Mongos.prototype.isConnected = function() {
      return this.connectedProxies.length > 0;
    };
    Mongos.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const self = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      let server = pickProxy(self, options2.session);
      if (!server)
        return callback(new MongoError("no mongos proxy available"));
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self) && !options2.session.inTransaction() && options2.explain === void 0;
      const handler2 = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self) || !willRetryWrite) {
          err = getMMAPError(err);
          return callback(err);
        }
        server = pickProxy(self, options2.session);
        if (!server) {
          return callback(err);
        }
        const newArgs = Object.assign({}, args, {retrying: true});
        return executeWriteOperation(newArgs, options2, callback);
      };
      if (callback.operationId) {
        handler2.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      server[op](ns, ops, options2, handler2);
    }
    Mongos.prototype.insert = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("insert", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({self: this, op: "insert", ns, ops}, options2, callback);
    };
    Mongos.prototype.update = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("update", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({self: this, op: "update", ns, ops}, options2, callback);
    };
    Mongos.prototype.remove = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("remove", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({self: this, op: "remove", ns, ops}, options2, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    Mongos.prototype.command = function(ns, cmd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      var self = this;
      var server = pickProxy(self, options2.session);
      if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      }
      if (server == null) {
        return callback(new MongoError("no mongos proxy available"));
      }
      var clonedOptions = cloneOptions(options2);
      clonedOptions.topology = self;
      const willRetryWrite = !options2.retrying && options2.retryWrites && options2.session && isRetryableWritesSupported(self) && !options2.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, clonedOptions, {retrying: true});
          return this.command(ns, cmd, newOptions, callback);
        }
        return callback(err);
      };
      if (willRetryWrite) {
        clonedOptions.session.incrementTransactionNumber();
        clonedOptions.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, clonedOptions, cb);
    };
    Mongos.prototype.cursor = function(ns, cmd, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options2);
    };
    Mongos.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector, selector = void 0;
      options2 = options2 || {};
      const server = pickProxy(this, options2.session);
      if (server == null) {
        callback(new MongoError("server selection failed"));
        return;
      }
      if (this.s.debug)
        this.emit("pickedServer", null, server);
      callback(null, server);
    };
    Mongos.prototype.connections = function() {
      var connections = [];
      for (var i = 0; i < this.connectedProxies.length; i++) {
        connections = connections.concat(this.connectedProxies[i].connections());
      }
      return connections;
    };
    function emitTopologyDescriptionChanged(self) {
      if (self.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        if (self.connectedProxies.length > 0) {
          topology = "Sharded";
        }
        var description = {
          topologyType: topology,
          servers: []
        };
        var proxies = self.disconnectedProxies.concat(self.connectingProxies);
        description.servers = description.servers.concat(proxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Unknown";
          return description2;
        }));
        description.servers = description.servers.concat(self.connectedProxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Mongos";
          return description2;
        }));
        var diffResult = diff(self.topologyDescription, description);
        var result = {
          topologyId: self.id,
          previousDescription: self.topologyDescription,
          newDescription: description,
          diff: diffResult
        };
        if (diffResult.servers.length > 0) {
          self.emit("topologyDescriptionChanged", result);
        }
        self.topologyDescription = description;
      }
    }
    module2.exports = Mongos;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    "use strict";
    function Denque(array, options2) {
      var options2 = options2 || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options2.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index2) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get2(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index2) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index2 < size / 2) {
        for (k = index2; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index2; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index2, count) {
      var i = index2;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index2 + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index2 === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index2 + count + len & this._capacityMask;
        for (k = index2; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index2 < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index2); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index2, count) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length *= 2;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/mongodb/lib/core/sdam/events.js
var require_events = __commonJS({
  "node_modules/mongodb/lib/core/sdam/events.js"(exports2, module2) {
    "use strict";
    var ServerDescriptionChangedEvent = class {
      constructor(topologyId, address, previousDescription, newDescription) {
        Object.assign(this, {topologyId, address, previousDescription, newDescription});
      }
    };
    var ServerOpeningEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, {topologyId, address});
      }
    };
    var ServerClosedEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, {topologyId, address});
      }
    };
    var TopologyDescriptionChangedEvent = class {
      constructor(topologyId, previousDescription, newDescription) {
        Object.assign(this, {topologyId, previousDescription, newDescription});
      }
    };
    var TopologyOpeningEvent = class {
      constructor(topologyId) {
        Object.assign(this, {topologyId});
      }
    };
    var TopologyClosedEvent = class {
      constructor(topologyId) {
        Object.assign(this, {topologyId});
      }
    };
    var ServerHeartbeatStartedEvent = class {
      constructor(connectionId) {
        Object.assign(this, {connectionId});
      }
    };
    var ServerHeartbeatSucceededEvent = class {
      constructor(duration, reply, connectionId) {
        Object.assign(this, {connectionId, duration, reply});
      }
    };
    var ServerHeartbeatFailedEvent = class {
      constructor(duration, failure, connectionId) {
        Object.assign(this, {connectionId, duration, failure});
      }
    };
    module2.exports = {
      ServerDescriptionChangedEvent,
      ServerOpeningEvent,
      ServerClosedEvent,
      TopologyDescriptionChangedEvent,
      TopologyOpeningEvent,
      TopologyClosedEvent,
      ServerHeartbeatStartedEvent,
      ServerHeartbeatSucceededEvent,
      ServerHeartbeatFailedEvent
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = {nextTick};
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = require("util");
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = {data: v, next: null};
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = {data: v, next: this.head};
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s2) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s2 + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({length: this.length});
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self, err) {
      self.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream2 = require_stream();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream2);
    function nop() {
    }
    function WritableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      var hwm = options2.highWaterMark;
      var writableHwm = options2.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options2);
      }
      this._writableState = new WritableState(options2, this);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream2.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      Readable2.call(this, options2);
      Writable.call(this, options2);
      if (options2 && options2.readable === false)
        this.readable = false;
      if (options2 && options2.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options2 && options2.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self) {
      self.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable2;
    var isArray = require_isarray();
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = require_stream();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable2, Stream2);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      var hwm = options2.highWaterMark;
      var readableHwm = options2.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder)
          StringDecoder = require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable2(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options2);
      this._readableState = new ReadableState(options2, this);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src2) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend);
        src2.removeListener("end", unpipe);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src2.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src2._readableState.awaitDrain);
            src2._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src2.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state.flowing) {
        debug("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function() {
        var state = src2._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src2, "data")) {
          state.flowing = true;
          flow(src2);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {hasUnpiped: false};
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1)
        return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    function nReadingNextTick(self) {
      debug("readable nexttick read 0");
      self.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options2) {
      if (!(this instanceof Transform))
        return new Transform(options2);
      Duplex.call(this, options2);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough2;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough2, Transform);
    function PassThrough2(options2) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options2);
      Transform.call(this, options2);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream2 = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream2) {
      module2.exports = Stream2;
      exports2 = module2.exports = Stream2.Readable;
      exports2.Readable = Stream2.Readable;
      exports2.Writable = Stream2.Writable;
      exports2.Duplex = Stream2.Duplex;
      exports2.Transform = Stream2.Transform;
      exports2.PassThrough = Stream2.PassThrough;
      exports2.Stream = Stream2;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream2 || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var util = require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src2) {
          src2.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src2) {
          src2.removeListener("error", piper);
        });
      } else {
        this.append(callback);
      }
      DuplexStream.call(this);
    }
    util.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function _offset(offset) {
      var tot = 0, i = 0, _t;
      if (offset === 0)
        return [0, 0];
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length;
        if (offset < _t || i == this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      var bufferId = blOffset[0];
      var offset = blOffset[1];
      for (var i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.append = function append(buf) {
      var i = 0;
      if (Buffer2.isBuffer(buf)) {
        this._appendBuffer(buf);
      } else if (Array.isArray(buf)) {
        for (; i < buf.length; i++)
          this.append(buf[i]);
      } else if (buf instanceof BufferList) {
        for (; i < buf._bufs.length; i++)
          this.append(buf._bufs[i]);
      } else if (buf != null) {
        if (typeof buf == "number")
          buf = buf.toString();
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback == "function")
        callback();
    };
    BufferList.prototype._read = function _read(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function get2(index2) {
      if (index2 > this.length || index2 < 0) {
        return void 0;
      }
      var offset = this._offset(index2);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start == "number" && start < 0)
        start += this.length;
      if (typeof end == "number" && end < 0)
        end += this.length;
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || Buffer2.alloc(0);
      if (srcEnd <= 0)
        return dst || Buffer2.alloc(0);
      var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy2 && dstStart || 0, start = off[1], l, i;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2)
        dst = Buffer2.allocUnsafe(len);
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start)
          start = 0;
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0)
        start += this.length;
      if (end < 0)
        end += this.length;
      if (start === end) {
        return new BufferList();
      }
      var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] == 0)
        buffers.pop();
      else
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      if (startOffset[1] != 0)
        buffers[0] = buffers[0].slice(startOffset[1]);
      return new BufferList(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      var i = 0, copy = new BufferList();
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i]);
      return copy;
    };
    BufferList.prototype.destroy = function destroy() {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (search instanceof BufferList) {
        search = search.slice();
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      var blOffset = this._offset(offset);
      var blIndex = blOffset[0];
      var buffOffset = blOffset[1];
      for (blIndex; blIndex < this._bufs.length; blIndex++) {
        var buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          var availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            var nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            var revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (var searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1,
        "readIntBE": null,
        "readIntLE": null,
        "readUIntBE": null,
        "readUIntLE": null
      };
      for (var m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    module2.exports = BufferList;
  }
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS({
  "node_modules/mongodb/lib/cmap/message_stream.js"(exports2, module2) {
    "use strict";
    var Duplex = require("stream").Duplex;
    var BufferList = require_bl();
    var MongoParseError = require_error().MongoParseError;
    var decompress = require_compression().decompress;
    var Response3 = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoError = require_error().MongoError;
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var Msg = require_msg().Msg;
    var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
    var kBuffer = Symbol("buffer");
    var MessageStream = class extends Duplex {
      constructor(options2) {
        options2 = options2 || {};
        super(options2);
        this.bson = options2.bson;
        this.maxBsonMessageSize = options2.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
        this[kBuffer] = new BufferList();
      }
      _write(chunk, _, callback) {
        const buffer = this[kBuffer];
        buffer.append(chunk);
        processIncomingData(this, callback);
      }
      _read() {
        return;
      }
      writeCommand(command, operationDescription) {
        const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;
        if (!shouldCompress || !canCompress(command)) {
          const data = command.toBin();
          this.push(Array.isArray(data) ? Buffer.concat(data) : data);
          return;
        }
        const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        compress({options: operationDescription}, messageToBeCompressed, (err, compressedMessage) => {
          if (err) {
            operationDescription.cb(err, null);
            return;
          }
          const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
          msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
          msgHeader.writeInt32LE(command.requestId, 4);
          msgHeader.writeInt32LE(0, 8);
          msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
          const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
          compressionDetails.writeInt32LE(originalCommandOpCode, 0);
          compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
          compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8);
          this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
        });
      }
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function processIncomingData(stream, callback) {
      const buffer = stream[kBuffer];
      if (buffer.length < 4) {
        callback();
        return;
      }
      const sizeOfMessage = buffer.readInt32LE(0);
      if (sizeOfMessage < 0) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));
        return;
      }
      if (sizeOfMessage > stream.maxBsonMessageSize) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
        return;
      }
      if (sizeOfMessage > buffer.length) {
        callback();
        return;
      }
      const message = buffer.slice(0, sizeOfMessage);
      buffer.consume(sizeOfMessage);
      const messageHeader = {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
      let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response3;
      const responseOptions = stream.responseOptions;
      if (messageHeader.opCode !== OP_COMPRESSED) {
        const messageBody = message.slice(MESSAGE_HEADER_SIZE);
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
        return;
      }
      messageHeader.fromCompressed = true;
      messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
      messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
      const compressorID = message[MESSAGE_HEADER_SIZE + 8];
      const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
      ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response3;
      decompress(compressorID, compressedBuffer, (err, messageBody) => {
        if (err) {
          callback(err);
          return;
        }
        if (messageBody.length !== messageHeader.length) {
          callback(new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
      });
    }
    module2.exports = MessageStream;
  }
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS({
  "node_modules/mongodb/lib/cmap/stream_description.js"(exports2, module2) {
    "use strict";
    var parseServerType = require_server_description().parseServerType;
    var RESPONSE_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "__nodejs_mock_server__"
    ];
    var StreamDescription = class {
      constructor(address, options2) {
        this.address = address;
        this.type = parseServerType(null);
        this.minWireVersion = void 0;
        this.maxWireVersion = void 0;
        this.maxBsonObjectSize = 16777216;
        this.maxMessageSizeBytes = 48e6;
        this.maxWriteBatchSize = 1e5;
        this.compressors = options2 && options2.compression && Array.isArray(options2.compression.compressors) ? options2.compression.compressors : [];
      }
      receiveResponse(response) {
        this.type = parseServerType(response);
        RESPONSE_FIELDS.forEach((field) => {
          if (typeof response[field] !== "undefined") {
            this[field] = response[field];
          }
        });
        if (response.compression) {
          this.compressor = this.compressors.filter((c) => response.compression.indexOf(c) !== -1)[0];
        }
      }
    };
    module2.exports = {
      StreamDescription
    };
  }
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection2 = __commonJS({
  "node_modules/mongodb/lib/cmap/connection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var MessageStream = require_message_stream();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var CommandResult = require_command_result();
    var StreamDescription = require_stream_description().StreamDescription;
    var wp = require_wireprotocol();
    var apm = require_apm();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var uuidV4 = require_utils2().uuidV4;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var kStream = Symbol("stream");
    var kQueue = Symbol("queue");
    var kMessageStream = Symbol("messageStream");
    var kGeneration = Symbol("generation");
    var kLastUseTime = Symbol("lastUseTime");
    var kClusterTime = Symbol("clusterTime");
    var kDescription = Symbol("description");
    var kIsMaster = Symbol("ismaster");
    var kAutoEncrypter = Symbol("autoEncrypter");
    var Connection = class extends EventEmitter {
      constructor(stream, options2) {
        super(options2);
        this.id = options2.id;
        this.address = streamIdentifier(stream);
        this.bson = options2.bson;
        this.socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        this.host = options2.host || "localhost";
        this.port = options2.port || 27017;
        this.monitorCommands = typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false;
        this.closed = false;
        this.destroyed = false;
        this[kDescription] = new StreamDescription(this.address, options2);
        this[kGeneration] = options2.generation;
        this[kLastUseTime] = now();
        if (options2.autoEncrypter) {
          this[kAutoEncrypter] = options2.autoEncrypter;
        }
        this[kQueue] = new Map();
        this[kMessageStream] = new MessageStream(options2);
        this[kMessageStream].on("message", messageHandler(this));
        this[kStream] = stream;
        stream.on("error", () => {
        });
        this[kMessageStream].on("error", (error3) => this.handleIssue({destroy: error3}));
        stream.on("close", () => this.handleIssue({isClose: true}));
        stream.on("timeout", () => this.handleIssue({isTimeout: true, destroy: true}));
        stream.pipe(this[kMessageStream]);
        this[kMessageStream].pipe(stream);
      }
      get description() {
        return this[kDescription];
      }
      get ismaster() {
        return this[kIsMaster];
      }
      set ismaster(response) {
        this[kDescription].receiveResponse(response);
        this[kIsMaster] = response;
      }
      get generation() {
        return this[kGeneration] || 0;
      }
      get idleTime() {
        return calculateDurationInMs(this[kLastUseTime]);
      }
      get clusterTime() {
        return this[kClusterTime];
      }
      get stream() {
        return this[kStream];
      }
      markAvailable() {
        this[kLastUseTime] = now();
      }
      handleIssue(issue) {
        if (this.closed) {
          return;
        }
        if (issue.destroy) {
          this[kStream].destroy(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
        }
        this.closed = true;
        for (const idAndOp of this[kQueue]) {
          const op = idAndOp[1];
          if (issue.isTimeout) {
            op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {
              beforeHandshake: this.ismaster == null
            }));
          } else if (issue.isClose) {
            op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));
          } else {
            op.cb(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
          }
        }
        this[kQueue].clear();
        this.emit("close");
      }
      destroy(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = Object.assign({force: false}, options2);
        if (this[kStream] == null || this.destroyed) {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        if (options2.force) {
          this[kStream].destroy();
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        this[kStream].end((err) => {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      command(ns, cmd, options2, callback) {
        wp.command(makeServerTrampoline(this), ns, cmd, options2, callback);
      }
      query(ns, cmd, cursorState, options2, callback) {
        wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options2, callback);
      }
      getMore(ns, cursorState, batchSize, options2, callback) {
        wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options2, callback);
      }
      killCursors(ns, cursorState, callback) {
        wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);
      }
      insert(ns, ops, options2, callback) {
        wp.insert(makeServerTrampoline(this), ns, ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        wp.update(makeServerTrampoline(this), ns, ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        wp.remove(makeServerTrampoline(this), ns, ops, options2, callback);
      }
    };
    function makeServerTrampoline(connection) {
      const server = {
        description: connection.description,
        clusterTime: connection[kClusterTime],
        s: {
          bson: connection.bson,
          pool: {write: write.bind(connection), isConnected: () => true}
        }
      };
      if (connection[kAutoEncrypter]) {
        server.autoEncrypter = connection[kAutoEncrypter];
      }
      return server;
    }
    function messageHandler(conn) {
      return function messageHandler2(message) {
        conn.emit("message", message);
        if (!conn[kQueue].has(message.responseTo)) {
          return;
        }
        const operationDescription = conn[kQueue].get(message.responseTo);
        const callback = operationDescription.cb;
        conn[kQueue].delete(message.responseTo);
        if (message.moreToCome) {
          conn[kQueue].set(message.requestId, operationDescription);
        } else if (operationDescription.socketTimeoutOverride) {
          conn[kStream].setTimeout(conn.socketTimeout);
        }
        try {
          message.parse(operationDescription);
        } catch (err) {
          callback(new MongoError(err));
          return;
        }
        if (message.documents[0]) {
          const document2 = message.documents[0];
          const session = operationDescription.session;
          if (session) {
            updateSessionFromResponse(session, document2);
          }
          if (document2.$clusterTime) {
            conn[kClusterTime] = document2.$clusterTime;
            conn.emit("clusterTimeReceived", document2.$clusterTime);
          }
          if (operationDescription.command) {
            if (document2.writeConcernError) {
              callback(new MongoWriteConcernError(document2.writeConcernError, document2));
              return;
            }
            if (document2.ok === 0 || document2.$err || document2.errmsg || document2.code) {
              callback(new MongoError(document2));
              return;
            }
          }
        }
        callback(void 0, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));
      };
    }
    function streamIdentifier(stream) {
      if (typeof stream.address === "function") {
        return `${stream.remoteAddress}:${stream.remotePort}`;
      }
      return uuidV4().toString("hex");
    }
    function write(command, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
      }
      options2 = options2 || {};
      const operationDescription = {
        requestId: command.requestId,
        cb: callback,
        session: options2.session,
        fullResult: typeof options2.fullResult === "boolean" ? options2.fullResult : false,
        noResponse: typeof options2.noResponse === "boolean" ? options2.noResponse : false,
        documentsReturnedIn: options2.documentsReturnedIn,
        command: !!options2.command,
        promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
        promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
        promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false,
        raw: typeof options2.raw === "boolean" ? options2.raw : false
      };
      if (this[kDescription] && this[kDescription].compressor) {
        operationDescription.agreedCompressor = this[kDescription].compressor;
        if (this[kDescription].zlibCompressionLevel) {
          operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;
        }
      }
      if (typeof options2.socketTimeout === "number") {
        operationDescription.socketTimeoutOverride = true;
        this[kStream].setTimeout(options2.socketTimeout);
      }
      if (this.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operationDescription.started = now();
        operationDescription.cb = (err, reply) => {
          if (err) {
            this.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operationDescription.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              this.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));
            } else {
              this.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));
            }
          }
          if (typeof callback === "function") {
            callback(err, reply);
          }
        };
      }
      if (!operationDescription.noResponse) {
        this[kQueue].set(operationDescription.requestId, operationDescription);
      }
      try {
        this[kMessageStream].writeCommand(command, operationDescription);
      } catch (e) {
        if (!operationDescription.noResponse) {
          this[kQueue].delete(operationDescription.requestId);
          operationDescription.cb(e);
          return;
        }
      }
      if (operationDescription.noResponse) {
        operationDescription.cb();
      }
    }
    module2.exports = {
      Connection
    };
  }
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors = __commonJS({
  "node_modules/mongodb/lib/cmap/errors.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var PoolClosedError = class extends MongoError {
      constructor(pool) {
        super("Attempted to check out a connection from closed connection pool");
        this.name = "MongoPoolClosedError";
        this.address = pool.address;
      }
    };
    var WaitQueueTimeoutError = class extends MongoError {
      constructor(pool) {
        super("Timed out while checking out a connection from connection pool");
        this.name = "MongoWaitQueueTimeoutError";
        this.address = pool.address;
      }
    };
    module2.exports = {
      PoolClosedError,
      WaitQueueTimeoutError
    };
  }
});

// node_modules/mongodb/lib/cmap/events.js
var require_events2 = __commonJS({
  "node_modules/mongodb/lib/cmap/events.js"(exports2, module2) {
    "use strict";
    var ConnectionPoolMonitoringEvent = class {
      constructor(pool) {
        this.time = new Date();
        this.address = pool.address;
      }
    };
    var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
        this.options = pool.options;
      }
    };
    var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection, reason) {
        super(pool);
        this.connectionId = connection.id;
        this.reason = reason || "unknown";
      }
    };
    var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, reason) {
        super(pool);
        this.reason = reason;
      }
    };
    var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var CMAP_EVENT_NAMES = [
      "connectionPoolCreated",
      "connectionPoolClosed",
      "connectionCreated",
      "connectionReady",
      "connectionClosed",
      "connectionCheckOutStarted",
      "connectionCheckOutFailed",
      "connectionCheckedOut",
      "connectionCheckedIn",
      "connectionPoolCleared"
    ];
    module2.exports = {
      CMAP_EVENT_NAMES,
      ConnectionPoolCreatedEvent,
      ConnectionPoolClosedEvent,
      ConnectionCreatedEvent,
      ConnectionReadyEvent,
      ConnectionClosedEvent,
      ConnectionCheckOutStartedEvent,
      ConnectionCheckOutFailedEvent,
      ConnectionCheckedOutEvent,
      ConnectionCheckedInEvent,
      ConnectionPoolClearedEvent
    };
  }
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events").EventEmitter;
    var Logger = require_logger();
    var makeCounter = require_utils4().makeCounter;
    var MongoError = require_error().MongoError;
    var Connection = require_connection2().Connection;
    var eachAsync = require_utils2().eachAsync;
    var connect = require_connect();
    var relayEvents = require_utils2().relayEvents;
    var errors = require_errors();
    var PoolClosedError = errors.PoolClosedError;
    var WaitQueueTimeoutError = errors.WaitQueueTimeoutError;
    var events = require_events2();
    var ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;
    var ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;
    var ConnectionCreatedEvent = events.ConnectionCreatedEvent;
    var ConnectionReadyEvent = events.ConnectionReadyEvent;
    var ConnectionClosedEvent = events.ConnectionClosedEvent;
    var ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;
    var ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;
    var ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;
    var ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;
    var ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;
    var kLogger = Symbol("logger");
    var kConnections = Symbol("connections");
    var kPermits = Symbol("permits");
    var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
    var kGeneration = Symbol("generation");
    var kConnectionCounter = Symbol("connectionCounter");
    var kCancellationToken = Symbol("cancellationToken");
    var kWaitQueue = Symbol("waitQueue");
    var kCancelled = Symbol("cancelled");
    var VALID_POOL_OPTIONS = new Set([
      "ssl",
      "bson",
      "connectionType",
      "monitorCommands",
      "socketTimeout",
      "credentials",
      "compression",
      "host",
      "port",
      "localAddress",
      "localPort",
      "family",
      "hints",
      "lookup",
      "path",
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "passphrase",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "allowHalfOpen",
      "rejectUnauthorized",
      "pskCallback",
      "ALPNProtocols",
      "servername",
      "checkServerIdentity",
      "session",
      "minDHSize",
      "secureContext",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ]);
    function resolveOptions(options2, defaults) {
      const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {
        if (Object.prototype.hasOwnProperty.call(options2, key)) {
          obj[key] = options2[key];
        }
        return obj;
      }, {});
      return Object.freeze(Object.assign({}, defaults, newOptions));
    }
    var ConnectionPool = class extends EventEmitter {
      constructor(options2) {
        super();
        options2 = options2 || {};
        this.closed = false;
        this.options = resolveOptions(options2, {
          connectionType: Connection,
          maxPoolSize: typeof options2.maxPoolSize === "number" ? options2.maxPoolSize : 100,
          minPoolSize: typeof options2.minPoolSize === "number" ? options2.minPoolSize : 0,
          maxIdleTimeMS: typeof options2.maxIdleTimeMS === "number" ? options2.maxIdleTimeMS : 0,
          waitQueueTimeoutMS: typeof options2.waitQueueTimeoutMS === "number" ? options2.waitQueueTimeoutMS : 0,
          autoEncrypter: options2.autoEncrypter,
          metadata: options2.metadata
        });
        if (options2.minSize > options2.maxSize) {
          throw new TypeError("Connection pool minimum size must not be greater than maxiumum pool size");
        }
        this[kLogger] = Logger("ConnectionPool", options2);
        this[kConnections] = new Denque();
        this[kPermits] = this.options.maxPoolSize;
        this[kMinPoolSizeTimer] = void 0;
        this[kGeneration] = 0;
        this[kConnectionCounter] = makeCounter(1);
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kWaitQueue] = new Denque();
        process.nextTick(() => {
          this.emit("connectionPoolCreated", new ConnectionPoolCreatedEvent(this));
          ensureMinPoolSize(this);
        });
      }
      get address() {
        return `${this.options.host}:${this.options.port}`;
      }
      get generation() {
        return this[kGeneration];
      }
      get totalConnectionCount() {
        return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);
      }
      get availableConnectionCount() {
        return this[kConnections].length;
      }
      get waitQueueSize() {
        return this[kWaitQueue].length;
      }
      checkOut(callback) {
        this.emit("connectionCheckOutStarted", new ConnectionCheckOutStartedEvent(this));
        if (this.closed) {
          this.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(this, "poolClosed"));
          callback(new PoolClosedError(this));
          return;
        }
        const waitQueueMember = {callback};
        const pool = this;
        const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
        if (waitQueueTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, "timeout"));
            waitQueueMember.callback(new WaitQueueTimeoutError(pool));
          }, waitQueueTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        process.nextTick(() => processWaitQueue(this));
      }
      checkIn(connection) {
        const poolClosed = this.closed;
        const stale = connectionIsStale(this, connection);
        const willDestroy = !!(poolClosed || stale || connection.closed);
        if (!willDestroy) {
          connection.markAvailable();
          this[kConnections].push(connection);
        }
        this.emit("connectionCheckedIn", new ConnectionCheckedInEvent(this, connection));
        if (willDestroy) {
          const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
          destroyConnection(this, connection, reason);
        }
        process.nextTick(() => processWaitQueue(this));
      }
      clear() {
        this[kGeneration] += 1;
        this.emit("connectionPoolCleared", new ConnectionPoolClearedEvent(this));
      }
      close(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
        }
        options2 = Object.assign({force: false}, options2);
        if (this.closed) {
          return callback();
        }
        this[kCancellationToken].emit("cancel");
        while (this.waitQueueSize) {
          const waitQueueMember = this[kWaitQueue].pop();
          clearTimeout(waitQueueMember.timer);
          if (!waitQueueMember[kCancelled]) {
            waitQueueMember.callback(new MongoError("connection pool closed"));
          }
        }
        if (this[kMinPoolSizeTimer]) {
          clearTimeout(this[kMinPoolSizeTimer]);
        }
        if (typeof this[kConnectionCounter].return === "function") {
          this[kConnectionCounter].return();
        }
        this.closed = true;
        eachAsync(this[kConnections].toArray(), (conn, cb) => {
          this.emit("connectionClosed", new ConnectionClosedEvent(this, conn, "poolClosed"));
          conn.destroy(options2, cb);
        }, (err) => {
          this[kConnections].clear();
          this.emit("connectionPoolClosed", new ConnectionPoolClosedEvent(this));
          callback(err);
        });
      }
      withConnection(fn, callback) {
        this.checkOut((err, conn) => {
          fn(err, conn, (fnErr, result) => {
            if (typeof callback === "function") {
              if (fnErr) {
                callback(fnErr);
              } else {
                callback(void 0, result);
              }
            }
            if (conn) {
              this.checkIn(conn);
            }
          });
        });
      }
    };
    function ensureMinPoolSize(pool) {
      if (pool.closed || pool.options.minPoolSize === 0) {
        return;
      }
      const minPoolSize = pool.options.minPoolSize;
      for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {
        createConnection(pool);
      }
      pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool[kGeneration];
    }
    function connectionIsIdle(pool, connection) {
      return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);
    }
    function createConnection(pool, callback) {
      const connectOptions = Object.assign({
        id: pool[kConnectionCounter].next().value,
        generation: pool[kGeneration]
      }, pool.options);
      pool[kPermits]--;
      connect(connectOptions, pool[kCancellationToken], (err, connection) => {
        if (err) {
          pool[kPermits]++;
          pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.closed) {
          connection.destroy({force: true});
          return;
        }
        relayEvents(connection, pool, [
          "commandStarted",
          "commandFailed",
          "commandSucceeded",
          "clusterTimeReceived"
        ]);
        pool.emit("connectionCreated", new ConnectionCreatedEvent(pool, connection));
        connection.markAvailable();
        pool.emit("connectionReady", new ConnectionReadyEvent(pool, connection));
        if (typeof callback === "function") {
          callback(void 0, connection);
          return;
        }
        pool[kConnections].push(connection);
        process.nextTick(() => processWaitQueue(pool));
      });
    }
    function destroyConnection(pool, connection, reason) {
      pool.emit("connectionClosed", new ConnectionClosedEvent(pool, connection, reason));
      pool[kPermits]++;
      process.nextTick(() => connection.destroy());
    }
    function processWaitQueue(pool) {
      if (pool.closed) {
        return;
      }
      while (pool.waitQueueSize) {
        const waitQueueMember = pool[kWaitQueue].peekFront();
        if (waitQueueMember[kCancelled]) {
          pool[kWaitQueue].shift();
          continue;
        }
        if (!pool.availableConnectionCount) {
          break;
        }
        const connection = pool[kConnections].shift();
        const isStale = connectionIsStale(pool, connection);
        const isIdle = connectionIsIdle(pool, connection);
        if (!isStale && !isIdle && !connection.closed) {
          pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          clearTimeout(waitQueueMember.timer);
          pool[kWaitQueue].shift();
          waitQueueMember.callback(void 0, connection);
          return;
        }
        const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
        destroyConnection(pool, connection, reason);
      }
      const maxPoolSize = pool.options.maxPoolSize;
      if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {
        createConnection(pool, (err, connection) => {
          const waitQueueMember = pool[kWaitQueue].shift();
          if (waitQueueMember == null || waitQueueMember[kCancelled]) {
            if (err == null) {
              pool[kConnections].push(connection);
            }
            return;
          }
          if (err) {
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, err));
          } else {
            pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          }
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(err, connection);
        });
        return;
      }
    }
    module2.exports = {
      ConnectionPool
    };
  }
});

// node_modules/mongodb/lib/core/sdam/monitor.js
var require_monitor = __commonJS({
  "node_modules/mongodb/lib/core/sdam/monitor.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var EventEmitter = require("events");
    var connect = require_connect();
    var Connection = require_connection2().Connection;
    var common = require_common();
    var makeStateMachine = require_utils2().makeStateMachine;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = require_utils3().retrieveBSON();
    var makeInterruptableAsyncInterval = require_utils4().makeInterruptableAsyncInterval;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var now = require_utils4().now;
    var sdamEvents = require_events();
    var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
    var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
    var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
    var kServer = Symbol("server");
    var kMonitorId = Symbol("monitorId");
    var kConnection = Symbol("connection");
    var kCancellationToken = Symbol("cancellationToken");
    var kRTTPinger = Symbol("rttPinger");
    var kRoundTripTime = Symbol("roundTripTime");
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_IDLE = "idle";
    var STATE_MONITORING = "monitoring";
    var stateTransition = makeStateMachine({
      [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],
      [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],
      [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],
      [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]
    });
    var INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);
    function isInCloseState(monitor) {
      return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;
    }
    var Monitor = class extends EventEmitter {
      constructor(server, options2) {
        super(options2);
        this[kServer] = server;
        this[kConnection] = void 0;
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kMonitorId] = null;
        this.s = {
          state: STATE_CLOSED
        };
        this.address = server.description.address;
        this.options = Object.freeze({
          connectTimeoutMS: typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : typeof options2.connectTimeoutMS === "number" ? options2.connectTimeoutMS : 1e4,
          heartbeatFrequencyMS: typeof options2.heartbeatFrequencyMS === "number" ? options2.heartbeatFrequencyMS : 1e4,
          minHeartbeatFrequencyMS: typeof options2.minHeartbeatFrequencyMS === "number" ? options2.minHeartbeatFrequencyMS : 500
        });
        const connectOptions = Object.assign({
          id: "<monitor>",
          host: server.description.host,
          port: server.description.port,
          bson: server.s.bson,
          connectionType: Connection
        }, server.s.options, this.options, {
          raw: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: true
        });
        delete connectOptions.credentials;
        delete connectOptions.autoEncrypter;
        this.connectOptions = Object.freeze(connectOptions);
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS,
          immediate: true
        });
      }
      requestCheck() {
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
          return;
        }
        this[kMonitorId].wake();
      }
      reset() {
        const topologyVersion = this[kServer].description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        stateTransition(this, STATE_IDLE);
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS
        });
      }
      close() {
        if (isInCloseState(this)) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        this.emit("close");
        stateTransition(this, STATE_CLOSED);
      }
    };
    function resetMonitorState(monitor) {
      if (monitor[kMonitorId]) {
        monitor[kMonitorId].stop();
        monitor[kMonitorId] = null;
      }
      if (monitor[kRTTPinger]) {
        monitor[kRTTPinger].close();
        monitor[kRTTPinger] = void 0;
      }
      monitor[kCancellationToken].emit("cancel");
      if (monitor[kMonitorId]) {
        clearTimeout(monitor[kMonitorId]);
        monitor[kMonitorId] = void 0;
      }
      if (monitor[kConnection]) {
        monitor[kConnection].destroy({force: true});
      }
    }
    function checkServer(monitor, callback) {
      let start = now();
      monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
      function failureHandler(err) {
        if (monitor[kConnection]) {
          monitor[kConnection].destroy({force: true});
          monitor[kConnection] = void 0;
        }
        monitor.emit("serverHeartbeatFailed", new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));
        monitor.emit("resetServer", err);
        monitor.emit("resetConnectionPool");
        callback(err);
      }
      if (monitor[kConnection] != null && !monitor[kConnection].closed) {
        const connectTimeoutMS = monitor.options.connectTimeoutMS;
        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        const topologyVersion = monitor[kServer].description.topologyVersion;
        const isAwaitable = topologyVersion != null;
        const cmd = {ismaster: true};
        const options2 = {socketTimeout: connectTimeoutMS};
        if (isAwaitable) {
          cmd.maxAwaitTimeMS = maxAwaitTimeMS;
          cmd.topologyVersion = makeTopologyVersion(topologyVersion);
          if (connectTimeoutMS) {
            options2.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;
          }
          options2.exhaustAllowed = true;
          if (monitor[kRTTPinger] == null) {
            monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);
          }
        }
        monitor[kConnection].command("admin.$cmd", cmd, options2, (err, result) => {
          if (err) {
            failureHandler(err);
            return;
          }
          const isMaster = result.result;
          const rttPinger = monitor[kRTTPinger];
          const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);
          monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address));
          if (isAwaitable && isMaster.topologyVersion) {
            monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
            start = now();
          } else {
            if (monitor[kRTTPinger]) {
              monitor[kRTTPinger].close();
              monitor[kRTTPinger] = void 0;
            }
            callback(void 0, isMaster);
          }
        });
        return;
      }
      connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {
        if (conn && isInCloseState(monitor)) {
          conn.destroy({force: true});
          return;
        }
        if (err) {
          monitor[kConnection] = void 0;
          if (!(err instanceof MongoNetworkError)) {
            monitor.emit("resetConnectionPool");
          }
          failureHandler(err);
          return;
        }
        monitor[kConnection] = conn;
        monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));
        callback(void 0, conn.ismaster);
      });
    }
    function monitorServer(monitor) {
      return (callback) => {
        stateTransition(monitor, STATE_MONITORING);
        function done() {
          if (!isInCloseState(monitor)) {
            stateTransition(monitor, STATE_IDLE);
          }
          callback();
        }
        process.nextTick(() => monitor.emit("monitoring", monitor[kServer]));
        checkServer(monitor, (err, isMaster) => {
          if (err) {
            if (monitor[kServer].description.type === ServerType.Unknown) {
              monitor.emit("resetServer", err);
              return done();
            }
          }
          if (isMaster && isMaster.topologyVersion) {
            setTimeout(() => {
              if (!isInCloseState(monitor)) {
                monitor[kMonitorId].wake();
              }
            });
          }
          done();
        });
      };
    }
    function makeTopologyVersion(tv) {
      return {
        processId: tv.processId,
        counter: BSON2.Long.fromNumber(tv.counter)
      };
    }
    var RTTPinger = class {
      constructor(cancellationToken, options2) {
        this[kConnection] = null;
        this[kCancellationToken] = cancellationToken;
        this[kRoundTripTime] = 0;
        this.closed = false;
        const heartbeatFrequencyMS = options2.heartbeatFrequencyMS;
        this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options2), heartbeatFrequencyMS);
      }
      get roundTripTime() {
        return this[kRoundTripTime];
      }
      close() {
        this.closed = true;
        clearTimeout(this[kMonitorId]);
        this[kMonitorId] = void 0;
        if (this[kConnection]) {
          this[kConnection].destroy({force: true});
        }
      }
    };
    function measureRoundTripTime(rttPinger, options2) {
      const start = now();
      const cancellationToken = rttPinger[kCancellationToken];
      const heartbeatFrequencyMS = options2.heartbeatFrequencyMS;
      if (rttPinger.closed) {
        return;
      }
      function measureAndReschedule(conn) {
        if (rttPinger.closed) {
          conn.destroy({force: true});
          return;
        }
        if (rttPinger[kConnection] == null) {
          rttPinger[kConnection] = conn;
        }
        rttPinger[kRoundTripTime] = calculateDurationInMs(start);
        rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options2), heartbeatFrequencyMS);
      }
      if (rttPinger[kConnection] == null) {
        connect(options2, cancellationToken, (err, conn) => {
          if (err) {
            rttPinger[kConnection] = void 0;
            rttPinger[kRoundTripTime] = 0;
            return;
          }
          measureAndReschedule(conn);
        });
        return;
      }
      rttPinger[kConnection].command("admin.$cmd", {ismaster: 1}, (err) => {
        if (err) {
          rttPinger[kConnection] = void 0;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule();
      });
    }
    module2.exports = {
      Monitor
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server.js
var require_server2 = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var ConnectionPool = require_connection_pool().ConnectionPool;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var MongoError = require_error().MongoError;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = require_utils3().retrieveBSON();
    var Logger = require_logger();
    var ServerDescription = require_server_description().ServerDescription;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var ReadPreference = require_read_preference();
    var Monitor = require_monitor().Monitor;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var collationNotSupported = require_utils2().collationNotSupported;
    var debugOptions = require_utils3().debugOptions;
    var isSDAMUnrecoverableError = require_error().isSDAMUnrecoverableError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var isNodeShuttingDownError = require_error().isNodeShuttingDownError;
    var isNetworkErrorBeforeHandshake = require_error().isNetworkErrorBeforeHandshake;
    var maxWireVersion = require_utils2().maxWireVersion;
    var makeStateMachine = require_utils2().makeStateMachine;
    var common = require_common();
    var ServerType = common.ServerType;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var DEBUG_FIELDS = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "servername"
    ];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var kMonitor = Symbol("monitor");
    var Server = class extends EventEmitter {
      constructor(description, options2, topology) {
        super();
        this.s = {
          description,
          options: options2,
          logger: Logger("Server", options2),
          bson: options2.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          state: STATE_CLOSED,
          credentials: options2.credentials,
          topology
        };
        const poolOptions = Object.assign({host: this.description.host, port: this.description.port, bson: this.s.bson}, options2);
        this.s.pool = new ConnectionPool(poolOptions);
        relayEvents(this.s.pool, this, ["commandStarted", "commandSucceeded", "commandFailed"].concat(CMAP_EVENT_NAMES));
        this.s.pool.on("clusterTimeReceived", (clusterTime) => {
          this.clusterTime = clusterTime;
        });
        this[kMonitor] = new Monitor(this, this.s.options);
        relayEvents(this[kMonitor], this, [
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "monitoring"
        ]);
        this[kMonitor].on("resetConnectionPool", () => {
          this.s.pool.clear();
        });
        this[kMonitor].on("resetServer", (error3) => markServerUnknown(this, error3));
        this[kMonitor].on("serverHeartbeatSucceeded", (event) => {
          this.emit("descriptionReceived", new ServerDescription(this.description.address, event.reply, {
            roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
          }));
          if (this.s.state === STATE_CONNECTING) {
            stateTransition(this, STATE_CONNECTED);
            this.emit("connect", this);
          }
        });
      }
      get description() {
        return this.s.description;
      }
      get name() {
        return this.s.description.address;
      }
      get autoEncrypter() {
        if (this.s.options && this.s.options.autoEncrypter) {
          return this.s.options.autoEncrypter;
        }
        return null;
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this[kMonitor].connect();
      }
      destroy(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = Object.assign({}, {force: false}, options2);
        if (this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        this[kMonitor].close();
        this.s.pool.close(options2, (err) => {
          stateTransition(this, STATE_CLOSED);
          this.emit("closed");
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      requestCheck() {
        this[kMonitor].requestCheck();
      }
      command(ns, cmd, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2, options2 = {}, options2 = options2 || {};
        }
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        const error3 = basicReadValidations(this, options2);
        if (error3) {
          return callback(error3);
        }
        options2 = Object.assign({}, options2, {wireProtocolCommand: false});
        if (this.s.logger.isDebug()) {
          this.s.logger.debug(`executing command [${JSON.stringify({
            ns,
            cmd,
            options: debugOptions(DEBUG_FIELDS, options2)
          })}] against ${this.name}`);
        }
        if (collationNotSupported(this, cmd)) {
          callback(new MongoError(`server ${this.name} does not support collation`));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.command(ns, cmd, options2, makeOperationHandler(this, conn, cmd, options2, cb));
        }, callback);
      }
      query(ns, cmd, cursorState, options2, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.query(ns, cmd, cursorState, options2, makeOperationHandler(this, conn, cmd, options2, cb));
        }, callback);
      }
      getMore(ns, cursorState, batchSize, options2, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.getMore(ns, cursorState, batchSize, options2, makeOperationHandler(this, conn, null, options2, cb));
        }, callback);
      }
      killCursors(ns, cursorState, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback(new MongoError("server is closed"));
          }
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, void 0, cb));
        }, callback);
      }
      insert(ns, ops, options2, callback) {
        executeWriteOperation({server: this, op: "insert", ns, ops}, options2, callback);
      }
      update(ns, ops, options2, callback) {
        executeWriteOperation({server: this, op: "update", ns, ops}, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        executeWriteOperation({server: this, op: "remove", ns, ops}, options2, callback);
      }
    };
    Object.defineProperty(Server.prototype, "clusterTime", {
      get: function() {
        return this.s.topology.clusterTime;
      },
      set: function(clusterTime) {
        this.s.topology.clusterTime = clusterTime;
      }
    });
    function supportsRetryableWrites(server) {
      return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;
    }
    function calculateRoundTripTime(oldRtt, duration) {
      if (oldRtt === -1) {
        return duration;
      }
      const alpha = 0.2;
      return alpha * duration + (1 - alpha) * oldRtt;
    }
    function basicReadValidations(server, options2) {
      if (options2.readPreference && !(options2.readPreference instanceof ReadPreference)) {
        return new MongoError("readPreference must be an instance of ReadPreference");
      }
    }
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const server = args.server;
      const op = args.op;
      const ns = args.ns;
      const ops = Array.isArray(args.ops) ? args.ops : [args.ops];
      if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      if (collationNotSupported(server, options2)) {
        callback(new MongoError(`server ${server.name} does not support collation`));
        return;
      }
      const unacknowledgedWrite = options2.writeConcern && options2.writeConcern.w === 0;
      if (unacknowledgedWrite || maxWireVersion(server) < 5) {
        if ((op === "update" || op === "remove") && ops.find((o) => o.hint)) {
          callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));
          return;
        }
      }
      server.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(server, err);
          return cb(err);
        }
        conn[op](ns, ops, options2, makeOperationHandler(server, conn, ops, options2, cb));
      }, callback);
    }
    function markServerUnknown(server, error3) {
      if (error3 instanceof MongoNetworkError && !(error3 instanceof MongoNetworkTimeoutError)) {
        server[kMonitor].reset();
      }
      server.emit("descriptionReceived", new ServerDescription(server.description.address, null, {
        error: error3,
        topologyVersion: error3 && error3.topologyVersion ? error3.topologyVersion : server.description.topologyVersion
      }));
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool.generation;
    }
    function shouldHandleStateChangeError(server, err) {
      const etv = err.topologyVersion;
      const stv = server.description.topologyVersion;
      return compareTopologyVersion(stv, etv) < 0;
    }
    function inActiveTransaction(session, cmd) {
      return session && session.inTransaction() && !isTransactionCommand(cmd);
    }
    function makeOperationHandler(server, connection, cmd, options2, callback) {
      const session = options2 && options2.session;
      return function handleOperationResult(err, result) {
        if (err && !connectionIsStale(server.s.pool, connection)) {
          if (err instanceof MongoNetworkError) {
            if (session && !session.hasEnded) {
              session.serverSession.isDirty = true;
            }
            if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {
              markServerUnknown(server, err);
              server.s.pool.clear();
            }
          } else {
            if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (isSDAMUnrecoverableError(err)) {
              if (shouldHandleStateChangeError(server, err)) {
                if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {
                  server.s.pool.clear();
                }
                markServerUnknown(server, err);
                process.nextTick(() => server.requestCheck());
              }
            }
          }
        }
        callback(err, result);
      };
    }
    module2.exports = {
      Server
    };
  }
});

// node_modules/mongodb/lib/core/sdam/srv_polling.js
var require_srv_polling = __commonJS({
  "node_modules/mongodb/lib/core/sdam/srv_polling.js"(exports2, module2) {
    "use strict";
    var Logger = require_logger();
    var EventEmitter = require("events").EventEmitter;
    var dns = require("dns");
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    var SrvPollingEvent = class {
      constructor(srvRecords) {
        this.srvRecords = srvRecords;
      }
      addresses() {
        return new Set(this.srvRecords.map((record) => `${record.name}:${record.port}`));
      }
    };
    var SrvPoller = class extends EventEmitter {
      constructor(options2) {
        super();
        if (!options2 || !options2.srvHost) {
          throw new TypeError("options for SrvPoller must exist and include srvHost");
        }
        this.srvHost = options2.srvHost;
        this.rescanSrvIntervalMS = 6e4;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 1e4;
        this.logger = Logger("srvPoller", options2);
        this.haMode = false;
        this.generation = 0;
        this._timeout = null;
      }
      get srvAddress() {
        return `_mongodb._tcp.${this.srvHost}`;
      }
      get intervalMS() {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
      }
      start() {
        if (!this._timeout) {
          this.schedule();
        }
      }
      stop() {
        if (this._timeout) {
          clearTimeout(this._timeout);
          this.generation += 1;
          this._timeout = null;
        }
      }
      schedule() {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => this._poll(), this.intervalMS);
      }
      success(srvRecords) {
        this.haMode = false;
        this.schedule();
        this.emit("srvRecordDiscovery", new SrvPollingEvent(srvRecords));
      }
      failure(message, obj) {
        this.logger.warn(message, obj);
        this.haMode = true;
        this.schedule();
      }
      parentDomainMismatch(srvRecord) {
        this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);
      }
      _poll() {
        const generation = this.generation;
        dns.resolveSrv(this.srvAddress, (err, srvRecords) => {
          if (generation !== this.generation) {
            return;
          }
          if (err) {
            this.failure("DNS error", err);
            return;
          }
          const finalAddresses = [];
          srvRecords.forEach((record) => {
            if (matchesParentDomain(record.name, this.srvHost)) {
              finalAddresses.push(record);
            } else {
              this.parentDomainMismatch(record);
            }
          });
          if (!finalAddresses.length) {
            this.failure("No valid addresses found at host");
            return;
          }
          this.success(finalAddresses);
        });
      }
    };
    module2.exports.SrvPollingEvent = SrvPollingEvent;
    module2.exports.SrvPoller = SrvPoller;
  }
});

// node_modules/mongodb/lib/core/sdam/server_selection.js
var require_server_selection = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_selection.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var TopologyType = require_common().TopologyType;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var IDLE_WRITE_PERIOD = 1e4;
    var SMALLEST_MAX_STALENESS_SECONDS = 90;
    function writableServerSelector() {
      return function(topologyDescription, servers) {
        return latencyWindowReducer(topologyDescription, servers.filter((s2) => s2.isWritable));
      };
    }
    function maxStalenessReducer(readPreference, topologyDescription, servers) {
      if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
        return servers;
      }
      const maxStaleness = readPreference.maxStalenessSeconds;
      const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
      if (maxStaleness < maxStalenessVariance) {
        throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);
      }
      if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
        throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {
        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
        return servers.reduce((result, server) => {
          const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {
        if (servers.length === 0) {
          return servers;
        }
        const sMax = servers.reduce((max, s2) => s2.lastWriteDate > max.lastWriteDate ? s2 : max);
        return servers.reduce((result, server) => {
          const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      return servers;
    }
    function tagSetMatch(tagSet, serverTags) {
      const keys = Object.keys(tagSet);
      const serverTagKeys = Object.keys(serverTags);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
          return false;
        }
      }
      return true;
    }
    function tagSetReducer(readPreference, servers) {
      if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
        return servers;
      }
      for (let i = 0; i < readPreference.tags.length; ++i) {
        const tagSet = readPreference.tags[i];
        const serversMatchingTagset = servers.reduce((matched, server) => {
          if (tagSetMatch(tagSet, server.tags))
            matched.push(server);
          return matched;
        }, []);
        if (serversMatchingTagset.length) {
          return serversMatchingTagset;
        }
      }
      return [];
    }
    function latencyWindowReducer(topologyDescription, servers) {
      const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
      const high = low + topologyDescription.localThresholdMS;
      return servers.reduce((result, server) => {
        if (server.roundTripTime <= high && server.roundTripTime >= low)
          result.push(server);
        return result;
      }, []);
    }
    function primaryFilter(server) {
      return server.type === ServerType.RSPrimary;
    }
    function secondaryFilter(server) {
      return server.type === ServerType.RSSecondary;
    }
    function nearestFilter(server) {
      return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
    }
    function knownFilter(server) {
      return server.type !== ServerType.Unknown;
    }
    function readPreferenceServerSelector(readPreference) {
      if (!readPreference.isValid()) {
        throw new TypeError("Invalid read preference specified");
      }
      return function(topologyDescription, servers) {
        const commonWireVersion = topologyDescription.commonWireVersion;
        if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
          throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
        }
        if (topologyDescription.type === TopologyType.Unknown) {
          return [];
        }
        if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {
          return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
        }
        const mode = readPreference.mode;
        if (mode === ReadPreference.PRIMARY) {
          return servers.filter(primaryFilter);
        }
        if (mode === ReadPreference.PRIMARY_PREFERRED) {
          const result = servers.filter(primaryFilter);
          if (result.length) {
            return result;
          }
        }
        const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
        if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
          return servers.filter(primaryFilter);
        }
        return selectedServers;
      };
    }
    module2.exports = {
      writableServerSelector,
      readPreferenceServerSelector
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology.js
var require_topology = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events");
    var ServerDescription = require_server_description().ServerDescription;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var TopologyType = require_common().TopologyType;
    var events = require_events();
    var Server = require_server2().Server;
    var relayEvents = require_utils2().relayEvents;
    var ReadPreference = require_read_preference();
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var CoreCursor = require_cursor().CoreCursor;
    var deprecate = require("util").deprecate;
    var BSON2 = require_utils3().retrieveBSON();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var ClientSession = require_sessions().ClientSession;
    var MongoError = require_error().MongoError;
    var MongoServerSelectionError = require_error().MongoServerSelectionError;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SrvPoller = require_srv_polling().SrvPoller;
    var getMMAPError = require_shared2().getMMAPError;
    var makeStateMachine = require_utils2().makeStateMachine;
    var eachAsync = require_utils2().eachAsync;
    var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
    var ServerSessionPool = require_sessions().ServerSessionPool;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var emitWarning = require_utils4().emitWarning;
    var common = require_common();
    var drainTimerQueue = common.drainTimerQueue;
    var clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;
    var serverSelection = require_server_selection();
    var readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;
    var writableServerSelector = serverSelection.writableServerSelector;
    var globalTopologyCounter = 0;
    var SERVER_RELAY_EVENTS = [
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "monitoring"
    ].concat(CMAP_EVENT_NAMES);
    var LOCAL_SERVER_EVENTS = ["connect", "descriptionReceived", "close", "ended"];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var DEPRECATED_OPTIONS = new Set([
      "autoReconnect",
      "reconnectTries",
      "reconnectInterval",
      "bufferMaxEntries"
    ]);
    var kCancelled = Symbol("cancelled");
    var kWaitQueue = Symbol("waitQueue");
    var Topology = class extends EventEmitter {
      constructor(seedlist, options2) {
        super();
        if (typeof options2 === "undefined" && typeof seedlist !== "string") {
          options2 = seedlist;
          seedlist = [];
          if (options2.host) {
            seedlist.push({host: options2.host, port: options2.port});
          }
        }
        seedlist = seedlist || [];
        if (typeof seedlist === "string") {
          seedlist = parseStringSeedlist(seedlist);
        }
        options2 = Object.assign({}, common.TOPOLOGY_DEFAULTS, options2);
        options2 = Object.freeze(Object.assign(options2, {
          metadata: makeClientMetadata(options2),
          compression: {compressors: createCompressionInfo(options2)}
        }));
        DEPRECATED_OPTIONS.forEach((optionName) => {
          if (options2[optionName]) {
            emitDeprecationWarning(`The option \`${optionName}\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
          }
        });
        const topologyType = topologyTypeFromSeedlist(seedlist, options2);
        const topologyId = globalTopologyCounter++;
        const serverDescriptions = seedlist.reduce((result, seed) => {
          if (seed.domain_socket)
            seed.host = seed.domain_socket;
          const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;
          result.set(address, new ServerDescription(address));
          return result;
        }, new Map());
        this[kWaitQueue] = new Denque();
        this.s = {
          id: topologyId,
          options: options2,
          seedlist,
          state: STATE_CLOSED,
          description: new TopologyDescription(topologyType, serverDescriptions, options2.replicaSet, null, null, null, options2),
          serverSelectionTimeoutMS: options2.serverSelectionTimeoutMS,
          heartbeatFrequencyMS: options2.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: options2.minHeartbeatFrequencyMS,
          Cursor: options2.cursorFactory || CoreCursor,
          bson: options2.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          servers: new Map(),
          sessionPool: new ServerSessionPool(this),
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise,
          credentials: options2.credentials,
          clusterTime: null,
          connectionTimers: new Set()
        };
        if (options2.srvHost) {
          this.s.srvPoller = options2.srvPoller || new SrvPoller({
            heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
            srvHost: options2.srvHost,
            logger: options2.logger,
            loggerLevel: options2.loggerLevel
          });
          this.s.detectTopologyDescriptionChange = (ev) => {
            const previousType = ev.previousDescription.type;
            const newType = ev.newDescription.type;
            if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {
              this.s.handleSrvPolling = srvPollingHandler(this);
              this.s.srvPoller.on("srvRecordDiscovery", this.s.handleSrvPolling);
              this.s.srvPoller.start();
            }
          };
          this.on("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
        }
        this.setMaxListeners(Infinity);
      }
      get description() {
        return this.s.description;
      }
      get parserType() {
        return BSON2.native ? "c++" : "js";
      }
      connect(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        if (this.s.state === STATE_CONNECTED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this.emit("topologyOpening", new events.TopologyOpeningEvent(this.s.id));
        this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown), this.s.description));
        connectServers(this, Array.from(this.s.description.servers.values()));
        ReadPreference.translate(options2);
        const readPreference = options2.readPreference || ReadPreference.primary;
        const connectHandler = (err) => {
          if (err) {
            this.close();
            if (typeof callback === "function") {
              callback(err);
            } else {
              this.emit("error", err);
            }
            return;
          }
          stateTransition(this, STATE_CONNECTED);
          this.emit("open", err, this);
          this.emit("connect", this);
          if (typeof callback === "function")
            callback(err, this);
        };
        if (this.s.credentials) {
          this.command("admin.$cmd", {ping: 1}, {readPreference}, connectHandler);
          return;
        }
        this.selectServer(readPreferenceServerSelector(readPreference), options2, connectHandler);
      }
      close(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        if (typeof options2 === "boolean") {
          options2 = {force: options2};
        }
        options2 = options2 || {};
        if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        drainWaitQueue(this[kWaitQueue], new MongoError("Topology closed"));
        drainTimerQueue(this.s.connectionTimers);
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          if (this.s.handleSrvPolling) {
            this.s.srvPoller.removeListener("srvRecordDiscovery", this.s.handleSrvPolling);
            delete this.s.handleSrvPolling;
          }
        }
        if (this.s.detectTopologyDescriptionChange) {
          this.removeListener("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
          delete this.s.detectTopologyDescriptionChange;
        }
        this.s.sessions.forEach((session) => session.endSession());
        this.s.sessionPool.endAllPooledSessions(() => {
          eachAsync(Array.from(this.s.servers.values()), (server, cb) => destroyServer(server, this, options2, cb), (err) => {
            this.s.servers.clear();
            this.emit("topologyClosed", new events.TopologyClosedEvent(this.s.id));
            stateTransition(this, STATE_CLOSED);
            if (typeof callback === "function") {
              callback(err);
            }
          });
        });
      }
      selectServer(selector, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          if (typeof selector !== "function") {
            options2 = selector;
            let readPreference;
            if (selector instanceof ReadPreference) {
              readPreference = selector;
            } else if (typeof selector === "string") {
              readPreference = new ReadPreference(selector);
            } else {
              ReadPreference.translate(options2);
              readPreference = options2.readPreference || ReadPreference.primary;
            }
            selector = readPreferenceServerSelector(readPreference);
          } else {
            options2 = {};
          }
        }
        options2 = Object.assign({}, {serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS}, options2);
        const isSharded = this.description.type === TopologyType.Sharded;
        const session = options2.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
          callback(void 0, transaction.server);
          return;
        }
        let serverSelector = selector;
        if (typeof selector === "object") {
          const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;
          serverSelector = readPreferenceServerSelector(readPreference);
        }
        const waitQueueMember = {
          serverSelector,
          transaction,
          callback
        };
        const serverSelectionTimeoutMS = options2.serverSelectionTimeoutMS;
        if (serverSelectionTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            const timeoutError = new MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
            waitQueueMember.callback(timeoutError);
          }, serverSelectionTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        processWaitQueue(this);
      }
      shouldCheckForSessionSupport() {
        if (this.description.type === TopologyType.Single) {
          return !this.description.hasKnownServers;
        }
        return !this.description.hasDataBearingServers;
      }
      hasSessionSupport() {
        return this.description.logicalSessionTimeoutMinutes != null;
      }
      startSession(options2, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options2, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", {endSessions: sessions}, {readPreference: ReadPreference.primaryPreferred, noResponse: true}, () => {
          if (typeof callback === "function")
            callback();
        });
      }
      serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
          return;
        }
        if (isStaleServerDescription(this.s.description, serverDescription)) {
          return;
        }
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
          resolveClusterTime(this, clusterTime);
        }
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
          this.emit("error", new MongoError(this.s.description.compatibilityError));
          return;
        }
        if (!equalDescriptions) {
          this.emit("serverDescriptionChanged", new events.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address)));
        }
        updateServers(this, serverDescription);
        if (this[kWaitQueue].length > 0) {
          processWaitQueue(this);
        }
        if (!equalDescriptions) {
          this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
      }
      auth(credentials, callback) {
        if (typeof credentials === "function")
          callback = credentials, credentials = null;
        if (typeof callback === "function")
          callback(null, true);
      }
      logout(callback) {
        if (typeof callback === "function")
          callback(null, true);
      }
      insert(ns, ops, options2, callback) {
        executeWriteOperation({topology: this, op: "insert", ns, ops}, options2, callback);
      }
      update(ns, ops, options2, callback) {
        executeWriteOperation({topology: this, op: "update", ns, ops}, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        executeWriteOperation({topology: this, op: "remove", ns, ops}, options2, callback);
      }
      command(ns, cmd, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2, options2 = {}, options2 = options2 || {};
        }
        ReadPreference.translate(options2);
        const readPreference = options2.readPreference || ReadPreference.primary;
        this.selectServer(readPreferenceServerSelector(readPreference), options2, (err, server) => {
          if (err) {
            callback(err);
            return;
          }
          const willRetryWrite = !options2.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(this) && !options2.session.inTransaction() && isWriteCommand(cmd);
          const cb = (err2, result) => {
            if (!err2)
              return callback(null, result);
            if (!shouldRetryOperation(err2)) {
              return callback(err2);
            }
            if (willRetryWrite) {
              const newOptions = Object.assign({}, options2, {retrying: true});
              return this.command(ns, cmd, newOptions, callback);
            }
            return callback(err2);
          };
          if (willRetryWrite) {
            options2.session.incrementTransactionNumber();
            options2.willRetryWrite = willRetryWrite;
          }
          server.command(ns, cmd, options2, cb);
        });
      }
      cursor(ns, cmd, options2) {
        options2 = options2 || {};
        const topology = options2.topology || this;
        const CursorClass = options2.cursorFactory || this.s.Cursor;
        ReadPreference.translate(options2);
        return new CursorClass(topology, ns, cmd, options2);
      }
      get clientMetadata() {
        return this.s.options.metadata;
      }
      isConnected() {
        return this.s.state === STATE_CONNECTED;
      }
      isDestroyed() {
        return this.s.state === STATE_CLOSED;
      }
      unref() {
        emitWarning("not implemented: `unref`");
      }
      lastIsMaster() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
          return {};
        const sd = serverDescriptions.filter((sd2) => sd2.type !== ServerType.Unknown)[0];
        const result = sd || {maxWireVersion: this.description.commonWireVersion};
        return result;
      }
      get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
      }
      get bson() {
        return this.s.bson;
      }
    };
    Object.defineProperty(Topology.prototype, "clusterTime", {
      enumerable: true,
      get: function() {
        return this.s.clusterTime;
      },
      set: function(clusterTime) {
        this.s.clusterTime = clusterTime;
      }
    });
    Topology.prototype.destroy = deprecate(Topology.prototype.close, "destroy() is deprecated, please use close() instead");
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    function isStaleServerDescription(topologyDescription, incomingServerDescription) {
      const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
      const currentTopologyVersion = currentServerDescription.topologyVersion;
      return compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
    }
    function destroyServer(server, topology, options2, callback) {
      options2 = options2 || {};
      LOCAL_SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options2, () => {
        topology.emit("serverClosed", new events.ServerClosedEvent(topology.s.id, server.description.address));
        SERVER_RELAY_EVENTS.forEach((event) => server.removeAllListeners(event));
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    function parseStringSeedlist(seedlist) {
      return seedlist.split(",").map((seed) => ({
        host: seed.split(":")[0],
        port: seed.split(":")[1] || 27017
      }));
    }
    function topologyTypeFromSeedlist(seedlist, options2) {
      if (options2.directConnection) {
        return TopologyType.Single;
      }
      const replicaSet = options2.replicaSet || options2.setName || options2.rs_name;
      if (replicaSet == null) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function randomSelection(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    function createAndConnectServer(topology, serverDescription, connectDelay) {
      topology.emit("serverOpening", new events.ServerOpeningEvent(topology.s.id, serverDescription.address));
      const server = new Server(serverDescription, topology.s.options, topology);
      relayEvents(server, topology, SERVER_RELAY_EVENTS);
      server.on("descriptionReceived", topology.serverUpdateHandler.bind(topology));
      if (connectDelay) {
        const connectTimer = setTimeout(() => {
          clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);
          server.connect();
        }, connectDelay);
        topology.s.connectionTimers.add(connectTimer);
        return server;
      }
      server.connect();
      return server;
    }
    function connectServers(topology, serverDescriptions) {
      topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {
        const server = createAndConnectServer(topology, serverDescription);
        servers.set(serverDescription.address, server);
        return servers;
      }, new Map());
    }
    function updateServers(topology, incomingServerDescription) {
      if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server = topology.s.servers.get(incomingServerDescription.address);
        server.s.description = incomingServerDescription;
      }
      for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
          const server = createAndConnectServer(topology, serverDescription);
          topology.s.servers.set(serverDescription.address, server);
        }
      }
      for (const entry of topology.s.servers) {
        const serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
          continue;
        }
        const server = topology.s.servers.get(serverAddress);
        topology.s.servers.delete(serverAddress);
        destroyServer(server, topology);
      }
    }
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const topology = args.topology;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(topology) && !options2.session.inTransaction() && options2.explain === void 0;
      topology.selectServer(writableServerSelector(), options2, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const handler2 = (err2, result) => {
          if (!err2)
            return callback(null, result);
          if (!shouldRetryOperation(err2)) {
            err2 = getMMAPError(err2);
            return callback(err2);
          }
          if (willRetryWrite) {
            const newArgs = Object.assign({}, args, {retrying: true});
            return executeWriteOperation(newArgs, options2, callback);
          }
          return callback(err2);
        };
        if (callback.operationId) {
          handler2.operationId = callback.operationId;
        }
        if (willRetryWrite) {
          options2.session.incrementTransactionNumber();
          options2.willRetryWrite = willRetryWrite;
        }
        server[op](ns, ops, options2, handler2);
      });
    }
    function shouldRetryOperation(err) {
      return err instanceof MongoError && err.hasErrorLabel("RetryableWriteError");
    }
    function srvPollingHandler(topology) {
      return function handleSrvPolling(ev) {
        const previousTopologyDescription = topology.s.description;
        topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);
        if (topology.s.description === previousTopologyDescription) {
          return;
        }
        updateServers(topology);
        topology.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(topology.s.id, previousTopologyDescription, topology.s.description));
      };
    }
    function drainWaitQueue(queue, err) {
      while (queue.length) {
        const waitQueueMember = queue.shift();
        clearTimeout(waitQueueMember.timer);
        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(err);
        }
      }
    }
    function processWaitQueue(topology) {
      if (topology.s.state === STATE_CLOSED) {
        drainWaitQueue(topology[kWaitQueue], new MongoError("Topology is closed, please connect"));
        return;
      }
      const serverDescriptions = Array.from(topology.description.servers.values());
      const membersToProcess = topology[kWaitQueue].length;
      for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {
        const waitQueueMember = topology[kWaitQueue].shift();
        if (waitQueueMember[kCancelled]) {
          continue;
        }
        let selectedDescriptions;
        try {
          const serverSelector = waitQueueMember.serverSelector;
          selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
        } catch (e) {
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(e);
          continue;
        }
        if (selectedDescriptions.length === 0) {
          topology[kWaitQueue].push(waitQueueMember);
          continue;
        }
        const selectedServerDescription = randomSelection(selectedDescriptions);
        const selectedServer = topology.s.servers.get(selectedServerDescription.address);
        const transaction = waitQueueMember.transaction;
        const isSharded = topology.description.type === TopologyType.Sharded;
        if (isSharded && transaction && transaction.isActive) {
          transaction.pinServer(selectedServer);
        }
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(void 0, selectedServer);
      }
      if (topology[kWaitQueue].length > 0) {
        topology.s.servers.forEach((server) => process.nextTick(() => server.requestCheck()));
      }
    }
    module2.exports = {
      Topology
    };
  }
});

// node_modules/mongodb/lib/core/uri_parser.js
var require_uri_parser = __commonJS({
  "node_modules/mongodb/lib/core/uri_parser.js"(exports2, module2) {
    "use strict";
    var URL2 = require("url");
    var qs = require("querystring");
    var dns = require("dns");
    var MongoParseError = require_error().MongoParseError;
    var ReadPreference = require_read_preference();
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;
    var FILE_PATH_OPTIONS = new Set(["sslCA", "sslCert", "sslKey", "tlsCAFile", "tlsCertificateKeyFile"].map((key) => key.toLowerCase()));
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    function parseSrvConnectionString(uri, options2, callback) {
      const result = URL2.parse(uri, true);
      if (options2.directConnection || options2.directconnection) {
        return callback(new MongoParseError("directConnection not supported with SRV URI"));
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new MongoParseError("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = uri.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new MongoParseError("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new MongoParseError(`Ports not accepted with '${PROTOCOL_MONGODB_SRV}' URIs`));
      }
      const lookupAddress = result.host;
      dns.resolveSrv(`_mongodb._tcp.${lookupAddress}`, (err, addresses) => {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new MongoParseError("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new MongoParseError("Server record does not share hostname with parent URI"));
          }
        }
        result.protocol = "mongodb";
        result.host = addresses.map((address) => `${address.name}:${address.port}`).join(",");
        if (!("ssl" in options2) && (!result.search || !("ssl" in result.query) || result.query.ssl === null)) {
          result.query.ssl = true;
        }
        dns.resolveTxt(lookupAddress, (err2, record) => {
          if (err2) {
            if (err2.code !== "ENODATA" && err2.code !== "ENOTFOUND") {
              return callback(err2);
            }
            record = null;
          }
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = qs.parse(record[0].join(""));
            if (Object.keys(record).some((key) => key !== "authSource" && key !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            result.query = Object.assign({}, record, result.query);
          }
          result.search = qs.stringify(result.query);
          const finalString = URL2.format(result);
          parseConnectionString(finalString, options2, (err3, ret) => {
            if (err3) {
              callback(err3);
              return;
            }
            callback(null, Object.assign({}, ret, {srvHost: lookupAddress}));
          });
        });
      });
    }
    function parseQueryStringItemValue(key, value) {
      if (Array.isArray(value)) {
        value = value.filter((v, idx) => value.indexOf(v) === idx);
        if (value.length === 1)
          value = value[0];
      } else if (value.indexOf(":") > 0) {
        value = value.split(",").reduce((result, pair) => {
          const parts = pair.split(":");
          result[parts[0]] = parseQueryStringItemValue(key, parts[1]);
          return result;
        }, {});
      } else if (value.indexOf(",") > 0) {
        value = value.split(",").map((v) => {
          return parseQueryStringItemValue(key, v);
        });
      } else if (value.toLowerCase() === "true" || value.toLowerCase() === "false") {
        value = value.toLowerCase() === "true";
      } else if (!Number.isNaN(value) && !STRING_OPTIONS.has(key)) {
        const numericValue = parseFloat(value);
        if (!Number.isNaN(numericValue)) {
          value = parseFloat(value);
        }
      }
      return value;
    }
    var BOOLEAN_OPTIONS = new Set([
      "slaveok",
      "slave_ok",
      "sslvalidate",
      "fsync",
      "safe",
      "retrywrites",
      "j"
    ]);
    var STRING_OPTIONS = new Set(["authsource", "replicaset"]);
    var AUTH_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-AWS",
      "MONGODB-X509",
      "MONGODB-CR",
      "DEFAULT",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256",
      "PLAIN"
    ]);
    var CASE_TRANSLATION = {
      replicaset: "replicaSet",
      connecttimeoutms: "connectTimeoutMS",
      sockettimeoutms: "socketTimeoutMS",
      maxpoolsize: "maxPoolSize",
      minpoolsize: "minPoolSize",
      maxidletimems: "maxIdleTimeMS",
      waitqueuemultiple: "waitQueueMultiple",
      waitqueuetimeoutms: "waitQueueTimeoutMS",
      wtimeoutms: "wtimeoutMS",
      readconcern: "readConcern",
      readconcernlevel: "readConcernLevel",
      readpreference: "readPreference",
      maxstalenessseconds: "maxStalenessSeconds",
      readpreferencetags: "readPreferenceTags",
      authsource: "authSource",
      authmechanism: "authMechanism",
      authmechanismproperties: "authMechanismProperties",
      gssapiservicename: "gssapiServiceName",
      localthresholdms: "localThresholdMS",
      serverselectiontimeoutms: "serverSelectionTimeoutMS",
      serverselectiontryonce: "serverSelectionTryOnce",
      heartbeatfrequencyms: "heartbeatFrequencyMS",
      retrywrites: "retryWrites",
      uuidrepresentation: "uuidRepresentation",
      zlibcompressionlevel: "zlibCompressionLevel",
      tlsallowinvalidcertificates: "tlsAllowInvalidCertificates",
      tlsallowinvalidhostnames: "tlsAllowInvalidHostnames",
      tlsinsecure: "tlsInsecure",
      tlscafile: "tlsCAFile",
      tlscertificatekeyfile: "tlsCertificateKeyFile",
      tlscertificatekeyfilepassword: "tlsCertificateKeyFilePassword",
      wtimeout: "wTimeoutMS",
      j: "journal",
      directconnection: "directConnection"
    };
    function applyConnectionStringOption(obj, key, value, options2) {
      if (key === "journal") {
        key = "j";
      } else if (key === "wtimeoutms") {
        key = "wtimeout";
      }
      if (BOOLEAN_OPTIONS.has(key)) {
        value = value === "true" || value === true;
      } else if (key === "appname") {
        value = decodeURIComponent(value);
      } else if (key === "readconcernlevel") {
        obj["readConcernLevel"] = value;
        key = "readconcern";
        value = {level: value};
      }
      if (key === "compressors") {
        value = Array.isArray(value) ? value : [value];
        if (!value.every((c) => c === "snappy" || c === "zlib")) {
          throw new MongoParseError("Value for `compressors` must be at least one of: `snappy`, `zlib`");
        }
      }
      if (key === "authmechanism" && !AUTH_MECHANISMS.has(value)) {
        throw new MongoParseError(`Value for authMechanism must be one of: ${Array.from(AUTH_MECHANISMS).join(", ")}, found: ${value}`);
      }
      if (key === "readpreference" && !ReadPreference.isValid(value)) {
        throw new MongoParseError("Value for `readPreference` must be one of: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`");
      }
      if (key === "zlibcompressionlevel" && (value < -1 || value > 9)) {
        throw new MongoParseError("zlibCompressionLevel must be an integer between -1 and 9");
      }
      if (key === "compressors" || key === "zlibcompressionlevel") {
        obj.compression = obj.compression || {};
        obj = obj.compression;
      }
      if (key === "authmechanismproperties") {
        if (typeof value.SERVICE_NAME === "string")
          obj.gssapiServiceName = value.SERVICE_NAME;
        if (typeof value.SERVICE_REALM === "string")
          obj.gssapiServiceRealm = value.SERVICE_REALM;
        if (typeof value.CANONICALIZE_HOST_NAME !== "undefined") {
          obj.gssapiCanonicalizeHostName = value.CANONICALIZE_HOST_NAME;
        }
      }
      if (key === "readpreferencetags") {
        value = Array.isArray(value) ? splitArrayOfMultipleReadPreferenceTags(value) : [value];
      }
      if (options2.caseTranslate && CASE_TRANSLATION[key]) {
        obj[CASE_TRANSLATION[key]] = value;
        return;
      }
      obj[key] = value;
    }
    var USERNAME_REQUIRED_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-CR",
      "PLAIN",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    function splitArrayOfMultipleReadPreferenceTags(value) {
      const parsedTags = [];
      for (let i = 0; i < value.length; i++) {
        parsedTags[i] = {};
        value[i].split(",").forEach((individualTag) => {
          const splitTag = individualTag.split(":");
          parsedTags[i][splitTag[0]] = splitTag[1];
        });
      }
      return parsedTags;
    }
    function applyAuthExpectations(parsed) {
      if (parsed.options == null) {
        return;
      }
      const options2 = parsed.options;
      const authSource = options2.authsource || options2.authSource;
      if (authSource != null) {
        parsed.auth = Object.assign({}, parsed.auth, {db: authSource});
      }
      const authMechanism = options2.authmechanism || options2.authMechanism;
      if (authMechanism != null) {
        if (USERNAME_REQUIRED_MECHANISMS.has(authMechanism) && (!parsed.auth || parsed.auth.username == null)) {
          throw new MongoParseError(`Username required for mechanism \`${authMechanism}\``);
        }
        if (authMechanism === "GSSAPI") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
        }
        if (authMechanism === "MONGODB-AWS") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
        }
        if (authMechanism === "MONGODB-X509") {
          if (parsed.auth && parsed.auth.password != null) {
            throw new MongoParseError(`Password not allowed for mechanism \`${authMechanism}\``);
          }
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
        }
        if (authMechanism === "PLAIN") {
          if (parsed.auth && parsed.auth.db == null) {
            parsed.auth = Object.assign({}, parsed.auth, {db: "$external"});
          }
        }
      }
      if (parsed.auth && parsed.auth.db == null) {
        parsed.auth = Object.assign({}, parsed.auth, {db: "admin"});
      }
      return parsed;
    }
    function parseQueryString(query, options2) {
      const result = {};
      let parsedQueryString = qs.parse(query);
      checkTLSOptions(parsedQueryString);
      for (const key in parsedQueryString) {
        const value = parsedQueryString[key];
        if (value === "" || value == null) {
          throw new MongoParseError("Incomplete key value pair for option");
        }
        const normalizedKey = key.toLowerCase();
        const parsedValue = FILE_PATH_OPTIONS.has(normalizedKey) ? value : parseQueryStringItemValue(normalizedKey, value);
        applyConnectionStringOption(result, normalizedKey, parsedValue, options2);
      }
      if (result.wtimeout && result.wtimeoutms) {
        delete result.wtimeout;
        emitWarningOnce("Unsupported option `wtimeout` specified");
      }
      return Object.keys(result).length ? result : null;
    }
    function translateTLSOptions(queryString) {
      if (queryString.tls) {
        queryString.ssl = queryString.tls;
      }
      if (queryString.tlsInsecure) {
        queryString.checkServerIdentity = false;
        queryString.sslValidate = false;
      } else {
        Object.assign(queryString, {
          checkServerIdentity: queryString.tlsAllowInvalidHostnames ? false : true,
          sslValidate: queryString.tlsAllowInvalidCertificates ? false : true
        });
      }
      if (queryString.tlsCAFile) {
        queryString.ssl = true;
        queryString.sslCA = queryString.tlsCAFile;
      }
      if (queryString.tlsCertificateKeyFile) {
        queryString.ssl = true;
        if (queryString.tlsCertificateFile) {
          queryString.sslCert = queryString.tlsCertificateFile;
          queryString.sslKey = queryString.tlsCertificateKeyFile;
        } else {
          queryString.sslKey = queryString.tlsCertificateKeyFile;
          queryString.sslCert = queryString.tlsCertificateKeyFile;
        }
      }
      if (queryString.tlsCertificateKeyFilePassword) {
        queryString.ssl = true;
        queryString.sslPass = queryString.tlsCertificateKeyFilePassword;
      }
      return queryString;
    }
    function checkTLSOptions(queryString) {
      const queryStringKeys = Object.keys(queryString);
      if (queryStringKeys.indexOf("tlsInsecure") !== -1 && (queryStringKeys.indexOf("tlsAllowInvalidCertificates") !== -1 || queryStringKeys.indexOf("tlsAllowInvalidHostnames") !== -1)) {
        throw new MongoParseError("The `tlsInsecure` option cannot be used with `tlsAllowInvalidCertificates` or `tlsAllowInvalidHostnames`.");
      }
      const tlsValue = assertTlsOptionsAreEqual("tls", queryString, queryStringKeys);
      const sslValue = assertTlsOptionsAreEqual("ssl", queryString, queryStringKeys);
      if (tlsValue != null && sslValue != null) {
        if (tlsValue !== sslValue) {
          throw new MongoParseError("All values of `tls` and `ssl` must be the same.");
        }
      }
    }
    function assertTlsOptionsAreEqual(optionName, queryString, queryStringKeys) {
      const queryStringHasTLSOption = queryStringKeys.indexOf(optionName) !== -1;
      let optionValue;
      if (Array.isArray(queryString[optionName])) {
        optionValue = queryString[optionName][0];
      } else {
        optionValue = queryString[optionName];
      }
      if (queryStringHasTLSOption) {
        if (Array.isArray(queryString[optionName])) {
          const firstValue = queryString[optionName][0];
          queryString[optionName].forEach((tlsValue) => {
            if (tlsValue !== firstValue) {
              throw new MongoParseError(`All values of ${optionName} must be the same.`);
            }
          });
        }
      }
      return optionValue;
    }
    var PROTOCOL_MONGODB = "mongodb";
    var PROTOCOL_MONGODB_SRV = "mongodb+srv";
    var SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];
    function parseConnectionString(uri, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, {caseTranslate: true}, options2);
      try {
        URL2.parse(uri);
      } catch (e) {
        return callback(new MongoParseError("URI malformed, cannot be parsed"));
      }
      const cap = uri.match(HOSTS_RX);
      if (!cap) {
        return callback(new MongoParseError("Invalid connection string"));
      }
      const protocol = cap[1];
      if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {
        return callback(new MongoParseError("Invalid protocol provided"));
      }
      const dbAndQuery = cap[4].split("?");
      const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
      const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;
      let parsedOptions;
      try {
        parsedOptions = parseQueryString(query, options2);
      } catch (parseError) {
        return callback(parseError);
      }
      parsedOptions = Object.assign({}, parsedOptions, options2);
      if (protocol === PROTOCOL_MONGODB_SRV) {
        return parseSrvConnectionString(uri, parsedOptions, callback);
      }
      const auth = {username: null, password: null, db: db && db !== "" ? qs.unescape(db) : null};
      if (parsedOptions.auth) {
        if (parsedOptions.auth.username)
          auth.username = parsedOptions.auth.username;
        if (parsedOptions.auth.user)
          auth.username = parsedOptions.auth.user;
        if (parsedOptions.auth.password)
          auth.password = parsedOptions.auth.password;
      } else {
        if (parsedOptions.username)
          auth.username = parsedOptions.username;
        if (parsedOptions.user)
          auth.username = parsedOptions.user;
        if (parsedOptions.password)
          auth.password = parsedOptions.password;
      }
      if (cap[4].split("?")[0].indexOf("@") !== -1) {
        return callback(new MongoParseError("Unescaped slash in userinfo section"));
      }
      const authorityParts = cap[3].split("@");
      if (authorityParts.length > 2) {
        return callback(new MongoParseError("Unescaped at-sign in authority section"));
      }
      if (authorityParts[0] == null || authorityParts[0] === "") {
        return callback(new MongoParseError("No username provided in authority section"));
      }
      if (authorityParts.length > 1) {
        const authParts = authorityParts.shift().split(":");
        if (authParts.length > 2) {
          return callback(new MongoParseError("Unescaped colon in authority section"));
        }
        if (authParts[0] === "") {
          return callback(new MongoParseError("Invalid empty username provided"));
        }
        if (!auth.username)
          auth.username = qs.unescape(authParts[0]);
        if (!auth.password)
          auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;
      }
      let hostParsingError = null;
      const hosts = authorityParts.shift().split(",").map((host) => {
        let parsedHost = URL2.parse(`mongodb://${host}`);
        if (parsedHost.path === "/:") {
          hostParsingError = new MongoParseError("Double colon in host identifier");
          return null;
        }
        if (host.match(/\.sock/)) {
          parsedHost.hostname = qs.unescape(host);
          parsedHost.port = null;
        }
        if (Number.isNaN(parsedHost.port)) {
          hostParsingError = new MongoParseError("Invalid port (non-numeric string)");
          return;
        }
        const result2 = {
          host: parsedHost.hostname,
          port: parsedHost.port ? parseInt(parsedHost.port) : 27017
        };
        if (result2.port === 0) {
          hostParsingError = new MongoParseError("Invalid port (zero) with hostname");
          return;
        }
        if (result2.port > 65535) {
          hostParsingError = new MongoParseError("Invalid port (larger than 65535) with hostname");
          return;
        }
        if (result2.port < 0) {
          hostParsingError = new MongoParseError("Invalid port (negative number)");
          return;
        }
        return result2;
      }).filter((host) => !!host);
      if (hostParsingError) {
        return callback(hostParsingError);
      }
      if (hosts.length === 0 || hosts[0].host === "" || hosts[0].host === null) {
        return callback(new MongoParseError("No hostname or hostnames provided in connection string"));
      }
      const directConnection = !!parsedOptions.directConnection;
      if (directConnection && hosts.length !== 1) {
        return callback(new MongoParseError("directConnection option requires exactly one host"));
      }
      if (parsedOptions.directConnection == null && hosts.length === 1 && parsedOptions.replicaSet == null) {
        parsedOptions.directConnection = true;
      }
      const result = {
        hosts,
        auth: auth.db || auth.username ? auth : null,
        options: Object.keys(parsedOptions).length ? parsedOptions : null
      };
      if (result.auth && result.auth.db) {
        result.defaultDatabase = result.auth.db;
      } else {
        result.defaultDatabase = "test";
      }
      result.options = translateTLSOptions(result.options);
      try {
        applyAuthExpectations(result);
      } catch (authError) {
        return callback(authError);
      }
      callback(null, result);
    }
    module2.exports = parseConnectionString;
  }
});

// node_modules/mongodb/lib/core/index.js
var require_core = __commonJS({
  "node_modules/mongodb/lib/core/index.js"(exports2, module2) {
    "use strict";
    var BSON2 = require_bson2();
    var require_optional = require_optional_require()(require);
    var EJSON = require_utils2().retrieveEJSON();
    try {
      const BSONNative = require_optional("bson-ext");
      if (BSONNative) {
        BSON2 = BSONNative;
      }
    } catch (err) {
    }
    module2.exports = {
      MongoError: require_error().MongoError,
      MongoNetworkError: require_error().MongoNetworkError,
      MongoParseError: require_error().MongoParseError,
      MongoTimeoutError: require_error().MongoTimeoutError,
      MongoServerSelectionError: require_error().MongoServerSelectionError,
      MongoWriteConcernError: require_error().MongoWriteConcernError,
      Connection: require_connection(),
      Server: require_server(),
      ReplSet: require_replset(),
      Mongos: require_mongos(),
      Logger: require_logger(),
      Cursor: require_cursor().CoreCursor,
      ReadPreference: require_read_preference(),
      Sessions: require_sessions(),
      BSON: BSON2,
      EJSON,
      Topology: require_topology().Topology,
      Query: require_commands().Query,
      MongoCredentials: require_mongo_credentials().MongoCredentials,
      defaultAuthProviders: require_defaultAuthProviders().defaultAuthProviders,
      MongoCR: require_mongocr(),
      X509: require_x509(),
      Plain: require_plain(),
      GSSAPI: require_gssapi(),
      ScramSHA1: require_scram().ScramSHA1,
      ScramSHA256: require_scram().ScramSHA256,
      parseConnectionString: require_uri_parser()
    };
  }
});

// node_modules/mongodb/lib/apm.js
var require_apm2 = __commonJS({
  "node_modules/mongodb/lib/apm.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var Instrumentation = class extends EventEmitter {
      constructor() {
        super();
      }
      instrument(MongoClient2, callback) {
        this.$MongoClient = MongoClient2;
        const $prototypeConnect = this.$prototypeConnect = MongoClient2.prototype.connect;
        const instrumentation = this;
        MongoClient2.prototype.connect = function(callback2) {
          this.s.options.monitorCommands = true;
          this.on("commandStarted", (event) => instrumentation.emit("started", event));
          this.on("commandSucceeded", (event) => instrumentation.emit("succeeded", event));
          this.on("commandFailed", (event) => instrumentation.emit("failed", event));
          return $prototypeConnect.call(this, callback2);
        };
        if (typeof callback === "function")
          callback(null, this);
      }
      uninstrument() {
        this.$MongoClient.prototype.connect = this.$prototypeConnect;
      }
    };
    module2.exports = Instrumentation;
  }
});

// node_modules/mongodb/lib/error.js
var require_error2 = __commonJS({
  "node_modules/mongodb/lib/error.js"(exports2, module2) {
    "use strict";
    var MongoNetworkError = require_core().MongoNetworkError;
    var GET_MORE_RESUMABLE_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      262,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436,
      63,
      150,
      13388,
      234,
      133,
      43
    ]);
    function isResumableError(error3, wireVersion) {
      if (error3 instanceof MongoNetworkError) {
        return true;
      }
      if (wireVersion >= 9) {
        if (error3.code === 43) {
          return true;
        }
        return error3.hasErrorLabel("ResumableChangeStreamError");
      }
      return GET_MORE_RESUMABLE_CODES.has(error3.code);
    }
    module2.exports = {GET_MORE_RESUMABLE_CODES, isResumableError};
  }
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/mongodb/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SYSTEM_NAMESPACE_COLLECTION: "system.namespaces",
      SYSTEM_INDEX_COLLECTION: "system.indexes",
      SYSTEM_PROFILE_COLLECTION: "system.profile",
      SYSTEM_USER_COLLECTION: "system.users",
      SYSTEM_COMMAND_COLLECTION: "$cmd",
      SYSTEM_JS_COLLECTION: "system.js"
    };
  }
});

// node_modules/mongodb/lib/operations/db_ops.js
var require_db_ops = __commonJS({
  "node_modules/mongodb/lib/operations/db_ops.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var debugOptions = require_utils4().debugOptions;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils4().parseIndexOptions;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var CONSTANTS = require_constants2();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    function createIndex(db, name, fieldOrSpec, options2, callback) {
      let finalOptions = Object.assign({}, {readPreference: ReadPreference.PRIMARY}, options2);
      finalOptions = applyWriteConcern(finalOptions, {db}, options2);
      if (finalOptions.writeConcern && typeof callback !== "function") {
        throw MongoError.create({
          message: "Cannot use a writeConcern without a provided callback",
          driver: true
        });
      }
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {
        if (err == null)
          return handleCallback(callback, err, result);
        if (err.code === 67 || err.code === 11e3 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {
          return handleCallback(callback, err, result);
        }
        const doc = createCreateIndexCommand(db, name, fieldOrSpec, options2);
        finalOptions.checkKeys = false;
        db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, (err2, result2) => {
          if (callback == null)
            return;
          if (err2)
            return handleCallback(callback, err2);
          if (result2 == null)
            return handleCallback(callback, null, null);
          if (result2.result.writeErrors)
            return handleCallback(callback, MongoError.create(result2.result.writeErrors[0]), null);
          handleCallback(callback, null, doc.name);
        });
      });
    }
    function createListener(db, e, object) {
      function listener(err) {
        if (object.listeners(e).length > 0) {
          object.emit(e, err, db);
          for (let i = 0; i < db.s.children.length; i++) {
            db.s.children[i].emit(e, err, db.s.children[i]);
          }
        }
      }
      return listener;
    }
    function ensureIndex(db, name, fieldOrSpec, options2, callback) {
      const finalOptions = applyWriteConcern({}, {db}, options2);
      const selector = createCreateIndexCommand(db, name, fieldOrSpec, options2);
      const index_name = selector.name;
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      finalOptions.readPreference = ReadPreference.PRIMARY;
      indexInformation(db, name, finalOptions, (err, indexInformation2) => {
        if (err != null && err.code !== 26)
          return handleCallback(callback, err, null);
        if (indexInformation2 == null || !indexInformation2[index_name]) {
          createIndex(db, name, fieldOrSpec, options2, callback);
        } else {
          if (typeof callback === "function")
            return handleCallback(callback, null, index_name);
        }
      });
    }
    function evaluate(db, code, parameters, options2, callback) {
      let finalCode = code;
      let finalParameters = [];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      if (!(finalCode && finalCode._bsontype === "Code"))
        finalCode = new Code2(finalCode);
      if (parameters != null && !Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = [parameters];
      } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = parameters;
      }
      let cmd = {$eval: finalCode, args: finalParameters};
      if (options2["nolock"]) {
        cmd["nolock"] = options2["nolock"];
      }
      options2.readPreference = new ReadPreference(ReadPreference.PRIMARY);
      executeCommand(db, cmd, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result && result.ok === 1)
          return handleCallback(callback, null, result.retval);
        if (result)
          return handleCallback(callback, MongoError.create({message: `eval failed: ${result.errmsg}`, driver: true}), null);
        handleCallback(callback, err, result);
      });
    }
    function executeCommand(db, command, options2, callback) {
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      const dbName = options2.dbName || options2.authdb || db.databaseName;
      options2.readPreference = ReadPreference.resolve(db, options2);
      if (db.s.logger.isDebug())
        db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options2))}]`);
      db.s.topology.command(db.s.namespace.withCollection("$cmd"), command, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (options2.full)
          return handleCallback(callback, null, result);
        handleCallback(callback, null, result.result);
      });
    }
    function executeDbAdminCommand(db, command, options2, callback) {
      const namespace = new MongoDBNamespace("admin", "$cmd");
      db.s.topology.command(namespace, command, options2, (err, result) => {
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, result.result);
      });
    }
    function indexInformation(db, name, options2, callback) {
      const full = options2["full"] == null ? false : options2["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index2 = indexes[i];
          info[index2.name] = [];
          for (let name2 in index2.key) {
            info[index2.name].push([name2, index2.key[name2]]);
          }
        }
        return info;
      }
      db.collection(name).listIndexes(options2).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function profilingInfo(db, options2, callback) {
      try {
        db.collection("system.profile").find({}, options2).toArray(callback);
      } catch (err) {
        return callback(err, null);
      }
    }
    function validateDatabaseName(databaseName) {
      if (typeof databaseName !== "string")
        throw MongoError.create({message: "database name must be a string", driver: true});
      if (databaseName.length === 0)
        throw MongoError.create({message: "database name cannot be the empty string", driver: true});
      if (databaseName === "$external")
        return;
      const invalidChars = [" ", ".", "$", "/", "\\"];
      for (let i = 0; i < invalidChars.length; i++) {
        if (databaseName.indexOf(invalidChars[i]) !== -1)
          throw MongoError.create({
            message: "database names cannot contain the character '" + invalidChars[i] + "'",
            driver: true
          });
      }
    }
    function createCreateIndexCommand(db, name, fieldOrSpec, options2) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const fieldHash = indexParameters.fieldHash;
      const indexName = typeof options2.name === "string" ? options2.name : indexParameters.name;
      const selector = {
        ns: db.s.namespace.withCollection(name).toString(),
        key: fieldHash,
        name: indexName
      };
      const finalUnique = options2 == null || typeof options2 === "object" ? false : options2;
      options2 = options2 == null || typeof options2 === "boolean" ? {} : options2;
      const keysToOmit = Object.keys(selector);
      for (let optionName in options2) {
        if (keysToOmit.indexOf(optionName) === -1) {
          selector[optionName] = options2[optionName];
        }
      }
      if (selector["unique"] == null)
        selector["unique"] = finalUnique;
      const removeKeys = ["w", "wtimeout", "j", "fsync", "readPreference", "session"];
      for (let i = 0; i < removeKeys.length; i++) {
        delete selector[removeKeys[i]];
      }
      return selector;
    }
    function createIndexUsingCreateIndexes(db, name, fieldOrSpec, options2, callback) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const indexName = typeof options2.name === "string" ? options2.name : indexParameters.name;
      const indexes = [{name: indexName, key: indexParameters.fieldHash}];
      const keysToOmit = Object.keys(indexes[0]).concat([
        "writeConcern",
        "w",
        "wtimeout",
        "j",
        "fsync",
        "readPreference",
        "session"
      ]);
      for (let optionName in options2) {
        if (keysToOmit.indexOf(optionName) === -1) {
          indexes[0][optionName] = options2[optionName];
        }
      }
      const capabilities = db.s.topology.capabilities();
      if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
        const error3 = new MongoError("server/primary/mongos does not support collation");
        error3.code = 67;
        return callback(error3);
      }
      const cmd = applyWriteConcern({createIndexes: name, indexes}, {db}, options2);
      options2.readPreference = ReadPreference.PRIMARY;
      executeCommand(db, cmd, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result.ok === 0)
          return handleCallback(callback, toError(result), null);
        handleCallback(callback, null, indexName);
      });
    }
    module2.exports = {
      createListener,
      createIndex,
      ensureIndex,
      evaluate,
      executeCommand,
      executeDbAdminCommand,
      indexInformation,
      profilingInfo,
      validateDatabaseName
    };
  }
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS({
  "node_modules/mongodb/lib/operations/common_functions.js"(exports2, module2) {
    "use strict";
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var CursorState = require_cursor().CursorState;
    var maxWireVersion = require_utils2().maxWireVersion;
    function buildCountCommand(collectionOrCursor, query, options2) {
      const skip = options2.skip;
      const limit = options2.limit;
      let hint = options2.hint;
      const maxTimeMS = options2.maxTimeMS;
      query = query || {};
      const cmd = {
        count: options2.collectionName,
        query
      };
      if (collectionOrCursor.s.numberOfRetries) {
        if (collectionOrCursor.options.hint) {
          hint = collectionOrCursor.options.hint;
        } else if (collectionOrCursor.cmd.hint) {
          hint = collectionOrCursor.cmd.hint;
        }
        decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);
      } else {
        decorateWithCollation(cmd, collectionOrCursor, options2);
      }
      if (typeof skip === "number")
        cmd.skip = skip;
      if (typeof limit === "number")
        cmd.limit = limit;
      if (typeof maxTimeMS === "number")
        cmd.maxTimeMS = maxTimeMS;
      if (hint)
        cmd.hint = hint;
      decorateWithReadConcern(cmd, collectionOrCursor);
      return cmd;
    }
    function findAndModify(coll, query, sort, doc, options2, callback) {
      const queryObject = {
        findAndModify: coll.collectionName,
        query
      };
      sort = formattedOrderClause(sort);
      if (sort) {
        queryObject.sort = sort;
      }
      queryObject.new = options2.new ? true : false;
      queryObject.remove = options2.remove ? true : false;
      queryObject.upsert = options2.upsert ? true : false;
      const projection = options2.projection || options2.fields;
      if (projection) {
        queryObject.fields = projection;
      }
      if (options2.arrayFilters) {
        queryObject.arrayFilters = options2.arrayFilters;
        delete options2.arrayFilters;
      }
      if (doc && !options2.remove) {
        queryObject.update = doc;
      }
      if (options2.maxTimeMS)
        queryObject.maxTimeMS = options2.maxTimeMS;
      options2.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      options2.checkKeys = false;
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
      if (finalOptions.writeConcern) {
        queryObject.writeConcern = finalOptions.writeConcern;
      }
      if (finalOptions.bypassDocumentValidation === true) {
        queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
      }
      finalOptions.readPreference = ReadPreference.primary;
      try {
        decorateWithCollation(queryObject, coll, finalOptions);
      } catch (err) {
        return callback(err, null);
      }
      executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        return handleCallback(callback, null, result);
      });
    }
    function indexInformation(db, name, options2, callback) {
      const full = options2["full"] == null ? false : options2["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index2 = indexes[i];
          info[index2.name] = [];
          for (let name2 in index2.key) {
            info[index2.name].push([name2, index2.key[name2]]);
          }
        }
        return info;
      }
      db.collection(name).listIndexes(options2).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function prepareDocs(coll, docs, options2) {
      const forceServerObjectId = typeof options2.forceServerObjectId === "boolean" ? options2.forceServerObjectId : coll.s.db.options.forceServerObjectId;
      if (forceServerObjectId === true) {
        return docs;
      }
      return docs.map((doc) => {
        if (forceServerObjectId !== true && doc._id == null) {
          doc._id = coll.s.pkFactory.createPk();
        }
        return doc;
      });
    }
    function nextObject(cursor, callback) {
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
        return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver: true}));
      }
      if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {
        try {
          cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
        } catch (err) {
          return handleCallback(callback, err);
        }
      }
      cursor._next((err, doc) => {
        cursor.s.state = CursorState.OPEN;
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, doc);
      });
    }
    function insertDocuments(coll, docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      docs = Array.isArray(docs) ? docs : [docs];
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
      if (finalOptions.keepGoing === true)
        finalOptions.ordered = false;
      finalOptions.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      docs = prepareDocs(coll, docs, options2);
      coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        result.ops = docs;
        handleCallback(callback, null, result);
      });
    }
    function removeDocuments(coll, selector, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {};
      } else if (typeof selector === "function") {
        callback = selector;
        options2 = {};
        selector = {};
      }
      options2 = options2 || {};
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
      if (selector == null)
        selector = {};
      const op = {q: selector, limit: 0};
      if (options2.single) {
        op.limit = 1;
      } else if (finalOptions.retryWrites) {
        finalOptions.retryWrites = false;
      }
      if (options2.hint) {
        op.hint = options2.hint;
      }
      try {
        decorateWithCollation(finalOptions, coll, options2);
      } catch (err) {
        return callback(err, null);
      }
      if (options2.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on remove`)) : void 0;
      }
      coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors) {
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        }
        handleCallback(callback, null, result);
      });
    }
    function updateDocuments(coll, selector, document2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = null;
      if (options2 == null)
        options2 = {};
      if (!(typeof callback === "function"))
        callback = null;
      if (selector == null || typeof selector !== "object")
        return callback(toError("selector must be a valid JavaScript object"));
      if (document2 == null || typeof document2 !== "object")
        return callback(toError("document must be a valid JavaScript object"));
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
      finalOptions.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      const op = {q: selector, u: document2};
      op.upsert = options2.upsert !== void 0 ? !!options2.upsert : false;
      op.multi = options2.multi !== void 0 ? !!options2.multi : false;
      if (options2.hint) {
        op.hint = options2.hint;
      }
      if (finalOptions.arrayFilters) {
        op.arrayFilters = finalOptions.arrayFilters;
        delete finalOptions.arrayFilters;
      }
      if (finalOptions.retryWrites && op.multi) {
        finalOptions.retryWrites = false;
      }
      try {
        decorateWithCollation(finalOptions, coll, options2);
      } catch (err) {
        return callback(err, null);
      }
      if (options2.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on update`)) : void 0;
      }
      coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      buildCountCommand,
      findAndModify,
      indexInformation,
      nextObject,
      prepareDocs,
      insertDocuments,
      removeDocuments,
      updateDocuments
    };
  }
});

// node_modules/mongodb/lib/operations/collection_ops.js
var require_collection_ops = __commonJS({
  "node_modules/mongodb/lib/operations/collection_ops.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var createIndexDb = require_db_ops().createIndex;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var ensureIndexDb = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var insertDocuments = require_common_functions().insertDocuments;
    var updateDocuments = require_common_functions().updateDocuments;
    var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
    function createIndex(coll, fieldOrSpec, options2, callback) {
      createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options2, callback);
    }
    function createIndexes(coll, indexSpecs, options2, callback) {
      const capabilities = coll.s.topology.capabilities();
      for (let i = 0; i < indexSpecs.length; i++) {
        if (indexSpecs[i].name == null) {
          const keys = [];
          if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
            return callback(new MongoError("server/primary/mongos does not support collation"));
          }
          for (let name in indexSpecs[i].key) {
            keys.push(`${name}_${indexSpecs[i].key[name]}`);
          }
          indexSpecs[i].name = keys.join("_");
        }
      }
      options2 = Object.assign({}, options2, {readPreference: ReadPreference.PRIMARY});
      executeCommand(coll.s.db, {
        createIndexes: coll.collectionName,
        indexes: indexSpecs
      }, options2, callback);
    }
    function ensureIndex(coll, fieldOrSpec, options2, callback) {
      ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options2, callback);
    }
    function group(coll, keys, condition, initial, reduce, finalize, command, options2, callback) {
      if (command) {
        const reduceFunction = reduce && reduce._bsontype === "Code" ? reduce : new Code2(reduce);
        const selector = {
          group: {
            ns: coll.collectionName,
            $reduce: reduceFunction,
            cond: condition,
            initial,
            out: "inline"
          }
        };
        if (finalize != null)
          selector.group["finalize"] = finalize;
        if (typeof keys === "function" || keys && keys._bsontype === "Code") {
          selector.group.$keyf = keys && keys._bsontype === "Code" ? keys : new Code2(keys);
        } else {
          const hash2 = {};
          keys.forEach((key) => {
            hash2[key] = 1;
          });
          selector.group.key = hash2;
        }
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        decorateWithReadConcern(selector, coll, options2);
        try {
          decorateWithCollation(selector, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        executeCommand(coll.s.db, selector, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result.retval);
        });
      } else {
        const scope = reduce != null && reduce._bsontype === "Code" ? reduce.scope : {};
        scope.ns = coll.collectionName;
        scope.keys = keys;
        scope.condition = condition;
        scope.initial = initial;
        const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ";");
        evaluate(coll.s.db, new Code2(groupfn, scope), null, options2, (err, results) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, results.result || results);
        });
      }
    }
    function indexes(coll, options2, callback) {
      options2 = Object.assign({}, {full: true}, options2);
      indexInformationDb(coll.s.db, coll.collectionName, options2, callback);
    }
    function indexExists(coll, indexes2, options2, callback) {
      indexInformation(coll, options2, (err, indexInformation2) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (!Array.isArray(indexes2))
          return handleCallback(callback, null, indexInformation2[indexes2] != null);
        for (let i = 0; i < indexes2.length; i++) {
          if (indexInformation2[indexes2[i]] == null) {
            return handleCallback(callback, null, false);
          }
        }
        return handleCallback(callback, null, true);
      });
    }
    function indexInformation(coll, options2, callback) {
      indexInformationDb(coll.s.db, coll.collectionName, options2, callback);
    }
    function parallelCollectionScan(coll, options2, callback) {
      const commandObject = {
        parallelCollectionScan: coll.collectionName,
        numCursors: options2.numCursors
      };
      decorateWithReadConcern(commandObject, coll, options2);
      const raw = options2.raw;
      delete options2["raw"];
      executeCommand(coll.s.db, commandObject, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
        options2 = Object.assign({explicitlyIgnoreSession: true}, options2);
        const cursors = [];
        if (raw)
          options2.raw = raw;
        for (let i = 0; i < result.cursors.length; i++) {
          const rawId = result.cursors[i].cursor.id;
          const cursorId = typeof rawId === "number" ? Long2.fromNumber(rawId) : rawId;
          cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options2));
        }
        handleCallback(callback, null, cursors);
      });
    }
    function save(coll, doc, options2, callback) {
      const finalOptions = applyWriteConcern(Object.assign({}, options2), {db: coll.s.db, collection: coll}, options2);
      if (doc._id != null) {
        finalOptions.upsert = true;
        return updateDocuments(coll, {_id: doc._id}, doc, finalOptions, callback);
      }
      insertDocuments(coll, [doc], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (doc == null)
          return handleCallback(callback, null, null);
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      createIndex,
      createIndexes,
      ensureIndex,
      group,
      indexes,
      indexExists,
      indexInformation,
      parallelCollectionScan,
      save
    };
  }
});

// node_modules/mongodb/lib/operations/cursor_ops.js
var require_cursor_ops = __commonJS({
  "node_modules/mongodb/lib/operations/cursor_ops.js"(exports2, module2) {
    "use strict";
    var buildCountCommand = require_collection_ops().buildCountCommand;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var push = Array.prototype.push;
    var CursorState = require_cursor().CursorState;
    function count(cursor, applySkipLimit, opts, callback) {
      if (applySkipLimit) {
        if (typeof cursor.cursorSkip() === "number")
          opts.skip = cursor.cursorSkip();
        if (typeof cursor.cursorLimit() === "number")
          opts.limit = cursor.cursorLimit();
      }
      if (opts.readPreference) {
        cursor.setReadPreference(opts.readPreference);
      }
      if (typeof opts.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
        opts.maxTimeMS = cursor.cmd.maxTimeMS;
      }
      let options2 = {};
      options2.skip = opts.skip;
      options2.limit = opts.limit;
      options2.hint = opts.hint;
      options2.maxTimeMS = opts.maxTimeMS;
      options2.collectionName = cursor.namespace.collection;
      let command;
      try {
        command = buildCountCommand(cursor, cursor.cmd.query, options2);
      } catch (err) {
        return callback(err);
      }
      cursor.server = cursor.topology.s.coreTopology;
      cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
        callback(err, result ? result.result.n : null);
      });
    }
    function each2(cursor, callback) {
      if (!callback)
        throw MongoError.create({message: "callback is mandatory", driver: true});
      if (cursor.isNotified())
        return;
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {
        return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver: true}));
      }
      if (cursor.s.state === CursorState.INIT) {
        cursor.s.state = CursorState.OPEN;
      }
      let fn = null;
      if (cursor.bufferedCount() > 0) {
        while (fn = loop(cursor, callback))
          fn(cursor, callback);
        each2(cursor, callback);
      } else {
        cursor.next((err, item) => {
          if (err)
            return handleCallback(callback, err);
          if (item == null) {
            return cursor.close({skipKillCursors: true}, () => handleCallback(callback, null, null));
          }
          if (handleCallback(callback, null, item) === false)
            return;
          each2(cursor, callback);
        });
      }
    }
    function loop(cursor, callback) {
      if (cursor.bufferedCount() === 0)
        return;
      cursor._next(callback);
      return loop;
    }
    function toArray(cursor, callback) {
      const items = [];
      cursor.rewind();
      cursor.s.state = CursorState.INIT;
      const fetchDocs = () => {
        cursor._next((err, doc) => {
          if (err) {
            return handleCallback(callback, err);
          }
          if (doc == null) {
            return cursor.close({skipKillCursors: true}, () => handleCallback(callback, null, items));
          }
          items.push(doc);
          if (cursor.bufferedCount() > 0) {
            let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
            if (cursor.s.transforms && typeof cursor.s.transforms.doc === "function") {
              docs = docs.map(cursor.s.transforms.doc);
            }
            push.apply(items, docs);
          }
          fetchDocs();
        });
      };
      fetchDocs();
    }
    module2.exports = {count, each: each2, toArray};
  }
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS({
  "node_modules/mongodb/lib/operations/count.js"(exports2, module2) {
    "use strict";
    var buildCountCommand = require_common_functions().buildCountCommand;
    var OperationBase = require_operation().OperationBase;
    var CountOperation = class extends OperationBase {
      constructor(cursor, applySkipLimit, options2) {
        super(options2);
        this.cursor = cursor;
        this.applySkipLimit = applySkipLimit;
      }
      execute(callback) {
        const cursor = this.cursor;
        const applySkipLimit = this.applySkipLimit;
        const options2 = this.options;
        if (applySkipLimit) {
          if (typeof cursor.cursorSkip() === "number")
            options2.skip = cursor.cursorSkip();
          if (typeof cursor.cursorLimit() === "number")
            options2.limit = cursor.cursorLimit();
        }
        if (options2.readPreference) {
          cursor.setReadPreference(options2.readPreference);
        }
        if (typeof options2.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
          options2.maxTimeMS = cursor.cmd.maxTimeMS;
        }
        let finalOptions = {};
        finalOptions.skip = options2.skip;
        finalOptions.limit = options2.limit;
        finalOptions.hint = options2.hint;
        finalOptions.maxTimeMS = options2.maxTimeMS;
        finalOptions.collectionName = cursor.namespace.collection;
        let command;
        try {
          command = buildCountCommand(cursor, cursor.cmd.query, finalOptions);
        } catch (err) {
          return callback(err);
        }
        cursor.server = cursor.topology.s.coreTopology;
        cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
          callback(err, result ? result.result.n : null);
        });
      }
    };
    module2.exports = CountOperation;
  }
});

// node_modules/mongodb/lib/cursor.js
var require_cursor2 = __commonJS({
  "node_modules/mongodb/lib/cursor.js"(exports2, module2) {
    "use strict";
    var Transform = require("stream").Transform;
    var PassThrough2 = require("stream").PassThrough;
    var deprecate = require("util").deprecate;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var CoreCursor = require_cursor().CoreCursor;
    var CursorState = require_cursor().CursorState;
    var Map2 = require_core().BSON.Map;
    var maybePromise = require_utils4().maybePromise;
    var executeOperation = require_execute_operation();
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var Explain = require_explain().Explain;
    var Aspect = require_operation().Aspect;
    var each2 = require_cursor_ops().each;
    var CountOperation = require_count();
    var flags = ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];
    var fields = ["numberOfRetries", "tailableRetryInterval"];
    var Cursor = class extends CoreCursor {
      constructor(topology, ns, cmd, options2) {
        super(topology, ns, cmd, options2);
        if (this.operation) {
          options2 = this.operation.options;
        }
        const numberOfRetries = options2.numberOfRetries || 5;
        const tailableRetryInterval = options2.tailableRetryInterval || 500;
        const currentNumberOfRetries = numberOfRetries;
        const promiseLibrary = options2.promiseLibrary || Promise;
        this.s = {
          numberOfRetries,
          tailableRetryInterval,
          currentNumberOfRetries,
          state: CursorState.INIT,
          promiseLibrary,
          explicitlyIgnoreSession: !!options2.explicitlyIgnoreSession
        };
        if (!options2.explicitlyIgnoreSession && options2.session) {
          this.cursorState.session = options2.session;
        }
        if (this.options.noCursorTimeout === true) {
          this.addCursorFlag("noCursorTimeout", true);
        }
        let batchSize = 1e3;
        if (this.cmd.cursor && this.cmd.cursor.batchSize) {
          batchSize = this.cmd.cursor.batchSize;
        } else if (options2.cursor && options2.cursor.batchSize) {
          batchSize = options2.cursor.batchSize;
        } else if (typeof options2.batchSize === "number") {
          batchSize = options2.batchSize;
        }
        this.setCursorBatchSize(batchSize);
      }
      get readPreference() {
        if (this.operation) {
          return this.operation.readPreference;
        }
        return this.options.readPreference;
      }
      get sortValue() {
        return this.cmd.sort;
      }
      _initializeCursor(callback) {
        if (this.operation && this.operation.session != null) {
          this.cursorState.session = this.operation.session;
        } else {
          if (!this.s.explicitlyIgnoreSession && !this.cursorState.session && this.topology.hasSessionSupport()) {
            this.cursorState.session = this.topology.startSession({owner: this});
            if (this.operation) {
              this.operation.session = this.cursorState.session;
            }
          }
        }
        super._initializeCursor(callback);
      }
      hasNext(callback) {
        if (this.s.state === CursorState.CLOSED || this.isDead && this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.isNotified()) {
            return cb(null, false);
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            if (doc == null || cursor.s.state === Cursor.CLOSED || cursor.isDead()) {
              return cb(null, false);
            }
            cursor.s.state = CursorState.OPEN;
            cursor.cursorState.cursorIndex--;
            if (cursor.cursorState.limit > 0) {
              cursor.cursorState.currentLimit--;
            }
            cb(null, true);
          });
        });
      }
      next(callback) {
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
            cb(MongoError.create({message: "Cursor is closed", driver: true}));
            return;
          }
          if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {
            try {
              cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
            } catch (err) {
              return cb(err);
            }
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            cursor.s.state = CursorState.OPEN;
            cb(null, doc);
          });
        });
      }
      filter(filter) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.query = filter;
        return this;
      }
      maxScan(maxScan) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.maxScan = maxScan;
        return this;
      }
      hint(hint) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.hint = hint;
        return this;
      }
      min(min) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.min = min;
        return this;
      }
      max(max) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.max = max;
        return this;
      }
      returnKey(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.returnKey = value;
        return this;
      }
      showRecordId(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.showDiskLoc = value;
        return this;
      }
      snapshot(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.snapshot = value;
        return this;
      }
      setCursorOption(field, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (fields.indexOf(field) === -1) {
          throw MongoError.create({
            message: `option ${field} is not a supported option ${fields}`,
            driver: true
          });
        }
        this.s[field] = value;
        if (field === "numberOfRetries")
          this.s.currentNumberOfRetries = value;
        return this;
      }
      addCursorFlag(flag, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (flags.indexOf(flag) === -1) {
          throw MongoError.create({
            message: `flag ${flag} is not a supported flag ${flags}`,
            driver: true
          });
        }
        if (typeof value !== "boolean") {
          throw MongoError.create({message: `flag ${flag} must be a boolean value`, driver: true});
        }
        this.cmd[flag] = value;
        return this;
      }
      addQueryModifier(name, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (name[0] !== "$") {
          throw MongoError.create({message: `${name} is not a valid query modifier`, driver: true});
        }
        const field = name.substr(1);
        this.cmd[field] = value;
        if (field === "orderby")
          this.cmd.sort = this.cmd[field];
        return this;
      }
      comment(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.comment = value;
        return this;
      }
      maxAwaitTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({message: "maxAwaitTimeMS must be a number", driver: true});
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.maxAwaitTimeMS = value;
        return this;
      }
      maxTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({message: "maxTimeMS must be a number", driver: true});
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.maxTimeMS = value;
        return this;
      }
      project(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        this.cmd.fields = value;
        return this;
      }
      sort(keyOrList, direction) {
        if (this.options.tailable) {
          throw MongoError.create({message: "Tailable cursor doesn't support sorting", driver: true});
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        let order = keyOrList;
        if (Array.isArray(order) && Array.isArray(order[0])) {
          order = new Map2(order.map((x) => {
            const value = [x[0], null];
            if (x[1] === "asc") {
              value[1] = 1;
            } else if (x[1] === "desc") {
              value[1] = -1;
            } else if (x[1] === 1 || x[1] === -1 || x[1].$meta) {
              value[1] = x[1];
            } else {
              throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
            }
            return value;
          }));
        }
        if (direction != null) {
          order = [[keyOrList, direction]];
        }
        this.cmd.sort = order;
        return this;
      }
      batchSize(value) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor doesn't support batchSize",
            driver: true
          });
        }
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "batchSize requires an integer", driver: true});
        }
        this.cmd.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      collation(value) {
        this.cmd.collation = value;
        return this;
      }
      limit(value) {
        if (this.options.tailable) {
          throw MongoError.create({message: "Tailable cursor doesn't support limit", driver: true});
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "limit requires an integer", driver: true});
        }
        this.cmd.limit = value;
        this.setCursorLimit(value);
        return this;
      }
      skip(value) {
        if (this.options.tailable) {
          throw MongoError.create({message: "Tailable cursor doesn't support skip", driver: true});
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "skip requires an integer", driver: true});
        }
        this.cmd.skip = value;
        this.setCursorSkip(value);
        return this;
      }
      each(callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        each2(this, callback);
      }
      forEach(iterator, callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        if (typeof callback === "function") {
          each2(this, (err, doc) => {
            if (err) {
              callback(err);
              return false;
            }
            if (doc != null) {
              iterator(doc);
              return true;
            }
            if (doc == null && callback) {
              const internalCallback = callback;
              callback = null;
              internalCallback(null);
              return false;
            }
          });
        } else {
          return new this.s.promiseLibrary((fulfill, reject) => {
            each2(this, (err, doc) => {
              if (err) {
                reject(err);
                return false;
              } else if (doc == null) {
                fulfill(null);
                return false;
              } else {
                iterator(doc);
                return true;
              }
            });
          });
        }
      }
      setReadPreference(readPreference) {
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      toArray(callback) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor cannot be converted to array",
            driver: true
          });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          const items = [];
          cursor.rewind();
          cursor.s.state = CursorState.INIT;
          const fetchDocs = () => {
            cursor._next((err, doc) => {
              if (err) {
                return handleCallback(cb, err);
              }
              if (doc == null) {
                return cursor.close({skipKillCursors: true}, () => handleCallback(cb, null, items));
              }
              items.push(doc);
              if (cursor.bufferedCount() > 0) {
                let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
                Array.prototype.push.apply(items, docs);
              }
              fetchDocs();
            });
          };
          fetchDocs();
        });
      }
      count(applySkipLimit, opts, callback) {
        if (this.cmd.query == null)
          throw MongoError.create({
            message: "count can only be used with find command",
            driver: true
          });
        if (typeof opts === "function")
          callback = opts, opts = {};
        opts = opts || {};
        if (typeof applySkipLimit === "function") {
          callback = applySkipLimit;
          applySkipLimit = true;
        }
        if (this.cursorState.session) {
          opts = Object.assign({}, opts, {session: this.cursorState.session});
        }
        const countOperation = new CountOperation(this, applySkipLimit, opts);
        return executeOperation(this.topology, countOperation, callback);
      }
      close(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = Object.assign({}, {skipKillCursors: false}, options2);
        return maybePromise(this, callback, (cb) => {
          this.s.state = CursorState.CLOSED;
          if (!options2.skipKillCursors) {
            this.kill();
          }
          this._endSession(() => {
            this.emit("close");
            cb(null, this);
          });
        });
      }
      map(transform) {
        if (this.cursorState.transforms && this.cursorState.transforms.doc) {
          const oldTransform = this.cursorState.transforms.doc;
          this.cursorState.transforms.doc = (doc) => {
            return transform(oldTransform(doc));
          };
        } else {
          this.cursorState.transforms = {doc: transform};
        }
        return this;
      }
      isClosed() {
        return this.isDead();
      }
      destroy(err) {
        if (err)
          this.emit("error", err);
        this.pause();
        this.close();
      }
      stream(options2) {
        this.cursorState.streamOptions = options2 || {};
        return this;
      }
      transformStream(options2) {
        const streamOptions = options2 || {};
        if (typeof streamOptions.transform === "function") {
          const stream = new Transform({
            objectMode: true,
            transform: function(chunk, encoding, callback) {
              this.push(streamOptions.transform(chunk));
              callback();
            }
          });
          return this.pipe(stream);
        }
        return this.pipe(new PassThrough2({objectMode: true}));
      }
      explain(verbosity, callback) {
        if (typeof verbosity === "function")
          callback = verbosity, verbosity = true;
        if (verbosity === void 0)
          verbosity = true;
        if (!this.operation || !this.operation.hasAspect(Aspect.EXPLAINABLE)) {
          throw new MongoError("This command cannot be explained");
        }
        this.operation.explain = new Explain(verbosity);
        return maybePromise(this, callback, (cb) => {
          CoreCursor.prototype._next.apply(this, [cb]);
        });
      }
      getLogger() {
        return this.logger;
      }
    };
    Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
    deprecate(Cursor.prototype.each, "Cursor.each is deprecated. Use Cursor.forEach instead.");
    deprecate(Cursor.prototype.maxScan, "Cursor.maxScan is deprecated, and will be removed in a later version");
    deprecate(Cursor.prototype.snapshot, "Cursor Snapshot is deprecated, and will be removed in a later version");
    module2.exports = Cursor;
  }
});

// node_modules/mongodb/lib/operations/command_v2.js
var require_command_v2 = __commonJS({
  "node_modules/mongodb/lib/operations/command_v2.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var maxWireVersion = require_utils2().maxWireVersion;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var commandSupportsReadConcern = require_sessions().commandSupportsReadConcern;
    var MongoError = require_error().MongoError;
    var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
    var CommandOperationV2 = class extends OperationBase {
      constructor(parent, options2, operationOptions) {
        super(options2);
        this.ns = parent.s.namespace.withCollection("$cmd");
        const propertyProvider = this.hasAspect(Aspect.NO_INHERIT_OPTIONS) ? void 0 : parent;
        this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION) ? ReadPreference.primary : ReadPreference.resolve(propertyProvider, this.options);
        this.readConcern = resolveReadConcern(propertyProvider, this.options);
        this.writeConcern = resolveWriteConcern(propertyProvider, this.options);
        if (operationOptions && typeof operationOptions.fullResponse === "boolean") {
          this.fullResponse = true;
        }
        this.options.readPreference = this.readPreference;
        if (parent.s.logger) {
          this.logger = parent.s.logger;
        } else if (parent.s.db && parent.s.db.logger) {
          this.logger = parent.s.db.logger;
        }
      }
      executeCommand(server, cmd, callback) {
        this.server = server;
        const options2 = this.options;
        const serverWireVersion = maxWireVersion(server);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && commandSupportsReadConcern(cmd) && !inTransaction) {
          Object.assign(cmd, {readConcern: this.readConcern});
        }
        if (options2.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
          return;
        }
        if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION)) {
            Object.assign(cmd, {writeConcern: this.writeConcern});
          }
          if (options2.collation && typeof options2.collation === "object") {
            Object.assign(cmd, {collation: options2.collation});
          }
        }
        if (typeof options2.maxTimeMS === "number") {
          cmd.maxTimeMS = options2.maxTimeMS;
        }
        if (typeof options2.comment === "string") {
          cmd.comment = options2.comment;
        }
        if (this.hasAspect(Aspect.EXPLAINABLE) && this.explain) {
          if (serverWireVersion < 6 && cmd.aggregate) {
            cmd.explain = true;
          } else {
            cmd = decorateWithExplain(cmd, this.explain);
          }
        }
        if (this.logger && this.logger.isDebug()) {
          this.logger.debug(`executing command ${JSON.stringify(cmd)} against ${this.ns}`);
        }
        server.command(this.ns.toString(), cmd, this.options, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          if (this.fullResponse) {
            callback(null, result);
            return;
          }
          callback(null, result.result);
        });
      }
    };
    function resolveWriteConcern(parent, options2) {
      return WriteConcern.fromOptions(options2) || parent && parent.writeConcern;
    }
    function resolveReadConcern(parent, options2) {
      return ReadConcern.fromOptions(options2) || parent && parent.readConcern;
    }
    module2.exports = CommandOperationV2;
  }
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/mongodb/lib/operations/aggregate.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var ReadPreference = require_core().ReadPreference;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DB_AGGREGATE_COLLECTION = 1;
    var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
    var AggregateOperation = class extends CommandOperationV2 {
      constructor(parent, pipeline2, options2) {
        super(parent, options2, {fullResponse: true});
        this.target = parent.s.namespace && parent.s.namespace.collection ? parent.s.namespace.collection : DB_AGGREGATE_COLLECTION;
        this.pipeline = pipeline2;
        this.hasWriteStage = false;
        if (typeof options2.out === "string") {
          this.pipeline = this.pipeline.concat({$out: options2.out});
          this.hasWriteStage = true;
        } else if (pipeline2.length > 0) {
          const finalStage = pipeline2[pipeline2.length - 1];
          if (finalStage.$out || finalStage.$merge) {
            this.hasWriteStage = true;
          }
        }
        if (this.hasWriteStage) {
          this.readPreference = ReadPreference.primary;
        }
        if (this.explain && this.writeConcern) {
          throw new MongoError('"explain" cannot be used on an aggregate call with writeConcern');
        }
        if (options2.cursor != null && typeof options2.cursor !== "object") {
          throw new MongoError("cursor options must be an object");
        }
      }
      get canRetryRead() {
        return !this.hasWriteStage;
      }
      addToPipeline(stage) {
        this.pipeline.push(stage);
      }
      execute(server, callback) {
        const options2 = this.options;
        const serverWireVersion = maxWireVersion(server);
        const command = {aggregate: this.target, pipeline: this.pipeline};
        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
          this.readConcern = null;
        }
        if (serverWireVersion >= 5) {
          if (this.hasWriteStage && this.writeConcern) {
            Object.assign(command, {writeConcern: this.writeConcern});
          }
        }
        if (options2.bypassDocumentValidation === true) {
          command.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        if (typeof options2.allowDiskUse === "boolean") {
          command.allowDiskUse = options2.allowDiskUse;
        }
        if (options2.hint) {
          command.hint = options2.hint;
        }
        if (this.explain) {
          options2.full = false;
        }
        command.cursor = options2.cursor || {};
        if (options2.batchSize && !this.hasWriteStage) {
          command.cursor.batchSize = options2.batchSize;
        }
        super.executeCommand(server, command, callback);
      }
    };
    defineAspects(AggregateOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = AggregateOperation;
  }
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS({
  "node_modules/mongodb/lib/bulk/common.js"(exports2, module2) {
    "use strict";
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().BSON.ObjectID;
    var BSON2 = require_core().BSON;
    var MongoWriteConcernError = require_core().MongoWriteConcernError;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var toError = require_utils4().toError;
    var handleCallback = require_utils4().handleCallback;
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var isPromiseLike = require_utils4().isPromiseLike;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var maxWireVersion = require_utils2().maxWireVersion;
    var WRITE_CONCERN_ERROR = 64;
    var INSERT = 1;
    var UPDATE = 2;
    var REMOVE = 3;
    var bson = new BSON2([
      BSON2.Binary,
      BSON2.Code,
      BSON2.DBRef,
      BSON2.Decimal128,
      BSON2.Double,
      BSON2.Int32,
      BSON2.Long,
      BSON2.Map,
      BSON2.MaxKey,
      BSON2.MinKey,
      BSON2.ObjectId,
      BSON2.BSONRegExp,
      BSON2.Symbol,
      BSON2.Timestamp
    ]);
    var Batch = class {
      constructor(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
      }
    };
    var kUpsertedIds = Symbol("upsertedIds");
    var kInsertedIds = Symbol("insertedIds");
    var BulkWriteResult = class {
      constructor(bulkResult) {
        this.result = bulkResult;
        this[kUpsertedIds] = void 0;
        this[kInsertedIds] = void 0;
      }
      get insertedCount() {
        return typeof this.result.nInserted !== "number" ? 0 : this.result.nInserted;
      }
      get matchedCount() {
        return typeof this.result.nMatched !== "number" ? 0 : this.result.nMatched;
      }
      get modifiedCount() {
        return typeof this.result.nModified !== "number" ? 0 : this.result.nModified;
      }
      get deletedCount() {
        return typeof this.result.nRemoved !== "number" ? 0 : this.result.nRemoved;
      }
      get upsertedCount() {
        return !this.result.upserted ? 0 : this.result.upserted.length;
      }
      get upsertedIds() {
        if (this[kUpsertedIds]) {
          return this[kUpsertedIds];
        }
        this[kUpsertedIds] = {};
        for (const doc of this.result.upserted || []) {
          this[kUpsertedIds][doc.index] = doc._id;
        }
        return this[kUpsertedIds];
      }
      get insertedIds() {
        if (this[kInsertedIds]) {
          return this[kInsertedIds];
        }
        this[kInsertedIds] = {};
        for (const doc of this.result.insertedIds || []) {
          this[kInsertedIds][doc.index] = doc._id;
        }
        return this[kInsertedIds];
      }
      get n() {
        return this.result.insertedCount;
      }
      get ok() {
        return this.result.ok;
      }
      get nInserted() {
        return this.result.nInserted;
      }
      get nUpserted() {
        return this.result.nUpserted;
      }
      get nMatched() {
        return this.result.nMatched;
      }
      get nModified() {
        return this.result.nModified;
      }
      get nRemoved() {
        return this.result.nRemoved;
      }
      getInsertedIds() {
        return this.result.insertedIds;
      }
      getUpsertedIds() {
        return this.result.upserted;
      }
      getUpsertedIdAt(index2) {
        return this.result.upserted[index2];
      }
      getRawResponse() {
        return this.result;
      }
      hasWriteErrors() {
        return this.result.writeErrors.length > 0;
      }
      getWriteErrorCount() {
        return this.result.writeErrors.length;
      }
      getWriteErrorAt(index2) {
        if (index2 < this.result.writeErrors.length) {
          return this.result.writeErrors[index2];
        }
        return null;
      }
      getWriteErrors() {
        return this.result.writeErrors;
      }
      getLastOp() {
        return this.result.lastOp;
      }
      getWriteConcernError() {
        if (this.result.writeConcernErrors.length === 0) {
          return null;
        } else if (this.result.writeConcernErrors.length === 1) {
          return this.result.writeConcernErrors[0];
        } else {
          let errmsg = "";
          for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
            const err = this.result.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i === 0)
              errmsg = errmsg + " and ";
          }
          return new WriteConcernError({errmsg, code: WRITE_CONCERN_ERROR});
        }
      }
      toJSON() {
        return this.result;
      }
      toString() {
        return `BulkWriteResult(${this.toJSON(this.result)})`;
      }
      isOk() {
        return this.result.ok === 1;
      }
    };
    var WriteConcernError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      toJSON() {
        return {code: this.err.code, errmsg: this.err.errmsg};
      }
      toString() {
        return `WriteConcernError(${this.err.errmsg})`;
      }
    };
    var WriteError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get index() {
        return this.err.index;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      getOperation() {
        return this.err.op;
      }
      toJSON() {
        return {code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op};
      }
      toString() {
        return `WriteError(${JSON.stringify(this.toJSON())})`;
      }
    };
    function mergeBatchResults(batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      } else if (result == null) {
        return;
      }
      if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        const writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
      }
      if (result.opTime || result.lastOp) {
        const opTime = result.lastOp || result.opTime;
        let lastOpTS = null;
        let lastOpT = null;
        if (opTime && opTime._bsontype === "Timestamp") {
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTime.greaterThan(bulkResult.lastOp)) {
            bulkResult.lastOp = opTime;
          }
        } else {
          if (bulkResult.lastOp) {
            lastOpTS = typeof bulkResult.lastOp.ts === "number" ? Long2.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
            lastOpT = typeof bulkResult.lastOp.t === "number" ? Long2.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
          }
          const opTimeTS = typeof opTime.ts === "number" ? Long2.fromNumber(opTime.ts) : opTime.ts;
          const opTimeT = typeof opTime.t === "number" ? Long2.fromNumber(opTime.t) : opTime.t;
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.greaterThan(lastOpTS)) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.equals(lastOpTS)) {
            if (opTimeT.greaterThan(lastOpT)) {
              bulkResult.lastOp = opTime;
            }
          }
        }
      }
      if (batch.batchType === INSERT && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (batch.batchType === REMOVE && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      let nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (let i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (batch.batchType === UPDATE && result.n) {
        const nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === "number") {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = null;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (let i = 0; i < result.writeErrors.length; i++) {
          const writeError = {
            index: batch.originalIndexes[result.writeErrors[i].index],
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    }
    function executeCommands(bulkOperation, options2, callback) {
      if (bulkOperation.s.batches.length === 0) {
        return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
      }
      const batch = bulkOperation.s.batches.shift();
      function resultHandler(err, result) {
        if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
          return handleCallback(callback, err);
        }
        if (err)
          err.ok = 0;
        if (err instanceof MongoWriteConcernError) {
          return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
        }
        const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
        const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
        if (mergeResult != null) {
          return handleCallback(callback, null, writeResult);
        }
        if (bulkOperation.handleWriteError(callback, writeResult))
          return;
        executeCommands(bulkOperation, options2, callback);
      }
      bulkOperation.finalOptionsHandler({options: options2, batch, resultHandler}, callback);
    }
    function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
      mergeBatchResults(batch, bulkResult, null, err.result);
      const wrappedWriteConcernError = new WriteConcernError({
        errmsg: err.result.writeConcernError.errmsg,
        code: err.result.writeConcernError.result
      });
      return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);
    }
    var BulkWriteError = class extends MongoError {
      constructor(error3, result) {
        const message = error3.err || error3.errmsg || error3.errMessage || error3;
        super(message);
        Object.assign(this, error3);
        this.name = "BulkWriteError";
        this.result = result;
      }
      get insertedCount() {
        return this.result.insertedCount;
      }
      get matchedCount() {
        return this.result.matchedCount;
      }
      get modifiedCount() {
        return this.result.modifiedCount;
      }
      get deletedCount() {
        return this.result.deletedCount;
      }
      get upsertedCount() {
        return this.result.upsertedCount;
      }
      get insertedIds() {
        return this.result.insertedIds;
      }
      get upsertedIds() {
        return this.result.upsertedIds;
      }
    };
    var FindOperators = class {
      constructor(bulkOperation) {
        this.s = bulkOperation.s;
      }
      update(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: true,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      updateOne(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: false,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        if (!hasAtomicOperators(updateDocument)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      replaceOne(replacement) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: replacement,
          multi: false,
          upsert
        };
        if (replacement.hint) {
          document2.hint = replacement.hint;
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not use atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      upsert() {
        this.s.currentOp.upsert = true;
        return this;
      }
      deleteOne() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 1
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      delete() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 0
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      removeOne() {
        emitWarningOnce("bulk operation `removeOne` has been deprecated, please use `deleteOne`");
        return this.deleteOne();
      }
      remove() {
        emitWarningOnce("bulk operation `remove` has been deprecated, please use `delete`");
        return this.delete();
      }
    };
    var BulkOperationBase = class {
      constructor(topology, collection, options2, isOrdered) {
        this.isOrdered = isOrdered;
        options2 = options2 == null ? {} : options2;
        const namespace = collection.s.namespace;
        const executed = false;
        const currentOp = null;
        const bson2 = topology.bson;
        const isMaster = topology.lastIsMaster();
        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;
        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1e3;
        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        let finalOptions = Object.assign({}, options2);
        finalOptions = applyRetryableWrites(finalOptions, collection.s.db);
        finalOptions = applyWriteConcern(finalOptions, {collection}, options2);
        const writeConcern = finalOptions.writeConcern;
        const promiseLibrary = options2.promiseLibrary || Promise;
        const bulkResult = {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        };
        this.s = {
          bulkResult,
          currentBatch: null,
          currentIndex: 0,
          currentBatchSize: 0,
          currentBatchSizeBytes: 0,
          currentInsertBatch: null,
          currentUpdateBatch: null,
          currentRemoveBatch: null,
          batches: [],
          writeConcern,
          maxBsonObjectSize,
          maxBatchSizeBytes,
          maxWriteBatchSize,
          maxKeySize,
          namespace,
          bson: bson2,
          topology,
          options: finalOptions,
          currentOp,
          executed,
          collection,
          promiseLibrary,
          err: null,
          checkKeys: typeof options2.checkKeys === "boolean" ? options2.checkKeys : true
        };
        if (options2.bypassDocumentValidation === true) {
          this.s.bypassDocumentValidation = true;
        }
      }
      insert(document2) {
        if (this.s.collection.s.db.options.forceServerObjectId !== true && document2._id == null)
          document2._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, document2);
      }
      find(selector) {
        if (!selector) {
          throw toError("Bulk find operation must specify a selector");
        }
        this.s.currentOp = {
          selector
        };
        return new FindOperators(this);
      }
      raw(op) {
        const key = Object.keys(op)[0];
        const forceServerObjectId = typeof this.s.options.forceServerObjectId === "boolean" ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
        if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
          op[key].multi = op.updateOne || op.replaceOne ? false : true;
          return this.s.options.addToOperationsList(this, UPDATE, op[key]);
        }
        if (op.updateOne || op.updateMany || op.replaceOne) {
          if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {
            throw new TypeError("Replacement document must not use atomic operators");
          } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {
            throw new TypeError("Update document requires atomic operators");
          }
          const multi = op.updateOne || op.replaceOne ? false : true;
          const operation = {
            q: op[key].filter,
            u: op[key].update || op[key].replacement,
            multi
          };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            operation.upsert = op[key].upsert ? true : false;
            if (op.collation)
              operation.collation = op.collation;
          } else {
            if (op[key].upsert)
              operation.upsert = true;
          }
          if (op[key].arrayFilters) {
            if (maxWireVersion(this.s.topology) < 6) {
              throw new TypeError("arrayFilters are only supported on MongoDB 3.6+");
            }
            operation.arrayFilters = op[key].arrayFilters;
          }
          return this.s.options.addToOperationsList(this, UPDATE, operation);
        }
        if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
          op[key].limit = op.removeOne ? 1 : 0;
          return this.s.options.addToOperationsList(this, REMOVE, op[key]);
        }
        if (op.deleteOne || op.deleteMany) {
          const limit = op.deleteOne ? 1 : 0;
          const operation = {q: op[key].filter, limit};
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            if (op.collation)
              operation.collation = op.collation;
          }
          return this.s.options.addToOperationsList(this, REMOVE, operation);
        }
        if (op.insertOne && op.insertOne.document == null) {
          if (forceServerObjectId !== true && op.insertOne._id == null)
            op.insertOne._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne);
        } else if (op.insertOne && op.insertOne.document) {
          if (forceServerObjectId !== true && op.insertOne.document._id == null)
            op.insertOne.document._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);
        }
        if (op.insertMany) {
          emitWarningOnce("bulk operation `insertMany` has been deprecated; use multiple `insertOne` ops instead");
          for (let i = 0; i < op.insertMany.length; i++) {
            if (forceServerObjectId !== true && op.insertMany[i]._id == null)
              op.insertMany[i]._id = new ObjectID2();
            this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);
          }
          return;
        }
        throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
      }
      _handleEarlyError(err, callback) {
        if (typeof callback === "function") {
          callback(err, null);
          return;
        }
        return this.s.promiseLibrary.reject(err);
      }
      bulkExecute(_writeConcern, options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        if (typeof _writeConcern === "function") {
          callback = _writeConcern;
        } else if (_writeConcern && typeof _writeConcern === "object") {
          this.s.writeConcern = _writeConcern;
        }
        if (this.s.executed) {
          const executedError = toError("batch cannot be re-executed");
          return this._handleEarlyError(executedError, callback);
        }
        if (this.isOrdered) {
          if (this.s.currentBatch)
            this.s.batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            this.s.batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            this.s.batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            this.s.batches.push(this.s.currentRemoveBatch);
        }
        if (this.s.batches.length === 0) {
          const emptyBatchError = toError("Invalid Operation, no operations specified");
          return this._handleEarlyError(emptyBatchError, callback);
        }
        return {options: options2, callback};
      }
      execute(_writeConcern, options2, callback) {
        const ret = this.bulkExecute(_writeConcern, options2, callback);
        if (!ret || isPromiseLike(ret)) {
          return ret;
        }
        options2 = ret.options;
        callback = ret.callback;
        return executeLegacyOperation(this.s.topology, executeCommands, [this, options2, callback]);
      }
      finalOptionsHandler(config, callback) {
        const finalOptions = Object.assign({ordered: this.isOrdered}, config.options);
        if (this.s.writeConcern != null) {
          finalOptions.writeConcern = this.s.writeConcern;
        }
        if (finalOptions.bypassDocumentValidation !== true) {
          delete finalOptions.bypassDocumentValidation;
        }
        if (this.operationId) {
          config.resultHandler.operationId = this.operationId;
        }
        if (this.s.options.serializeFunctions) {
          finalOptions.serializeFunctions = true;
        }
        if (this.s.options.ignoreUndefined) {
          finalOptions.ignoreUndefined = true;
        }
        if (this.s.bypassDocumentValidation === true) {
          finalOptions.bypassDocumentValidation = true;
        }
        if (this.s.checkKeys === false) {
          finalOptions.checkKeys = false;
        }
        if (finalOptions.retryWrites) {
          if (config.batch.batchType === UPDATE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.multi);
          }
          if (config.batch.batchType === REMOVE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.limit === 0);
          }
        }
        try {
          if (config.batch.batchType === INSERT) {
            this.s.topology.insert(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          } else if (config.batch.batchType === UPDATE) {
            this.s.topology.update(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          } else if (config.batch.batchType === REMOVE) {
            this.s.topology.remove(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          }
        } catch (err) {
          err.ok = 0;
          handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));
        }
      }
      handleWriteError(callback, writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
          const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
          handleCallback(callback, new BulkWriteError(toError({
            message: msg,
            code: this.s.bulkResult.writeErrors[0].code,
            writeErrors: this.s.bulkResult.writeErrors
          }), writeResult), null);
          return true;
        }
        if (writeResult.getWriteConcernError()) {
          handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);
          return true;
        }
      }
    };
    Object.defineProperty(BulkOperationBase.prototype, "length", {
      enumerable: true,
      get: function() {
        return this.s.currentIndex;
      }
    });
    module2.exports = {
      Batch,
      BulkOperationBase,
      bson,
      INSERT,
      UPDATE,
      REMOVE,
      BulkWriteError,
      BulkWriteResult
    };
  }
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS({
  "node_modules/mongodb/lib/bulk/unordered.js"(exports2, module2) {
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils4();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      bulkOperation.s.currentBatch = null;
      if (docType === common.INSERT) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;
      }
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      if (bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
      if (docType === common.INSERT) {
        bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.bulkResult.insertedIds.length,
          _id: document2._id
        });
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;
      }
      bulkOperation.s.currentBatch.size += 1;
      bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return bulkOperation;
    }
    var UnorderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options2) {
        options2 = options2 || {};
        options2 = Object.assign(options2, {addToOperationsList});
        super(topology, collection, options2, false);
      }
      handleWriteError(callback, writeResult) {
        if (this.s.batches.length) {
          return false;
        }
        return super.handleWriteError(callback, writeResult);
      }
    };
    function initializeUnorderedBulkOp(topology, collection, options2) {
      return new UnorderedBulkOperation(topology, collection, options2);
    }
    initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
    module2.exports = initializeUnorderedBulkOp;
    module2.exports.Bulk = UnorderedBulkOperation;
  }
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS({
  "node_modules/mongodb/lib/bulk/ordered.js"(exports2, module2) {
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils4();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatchSize > 0 && bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
        bulkOperation.s.currentBatchSize = 0;
        bulkOperation.s.currentBatchSizeBytes = 0;
      }
      if (docType === common.INSERT) {
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.currentIndex,
          _id: document2._id
        });
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatchSize += 1;
      bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      bulkOperation.s.currentIndex += 1;
      return bulkOperation;
    }
    var OrderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options2) {
        options2 = options2 || {};
        options2 = Object.assign(options2, {addToOperationsList});
        super(topology, collection, options2, true);
      }
    };
    function initializeOrderedBulkOp(topology, collection, options2) {
      return new OrderedBulkOperation(topology, collection, options2);
    }
    initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
    module2.exports = initializeOrderedBulkOp;
    module2.exports.Bulk = OrderedBulkOperation;
  }
});

// node_modules/mongodb/lib/aggregation_cursor.js
var require_aggregation_cursor = __commonJS({
  "node_modules/mongodb/lib/aggregation_cursor.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var AggregationCursor = class extends Cursor {
      constructor(topology, operation, options2) {
        super(topology, operation, options2);
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "batchSize requires an integer", driver: true});
        }
        this.operation.options.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      geoNear(document2) {
        this.operation.addToPipeline({$geoNear: document2});
        return this;
      }
      group(document2) {
        this.operation.addToPipeline({$group: document2});
        return this;
      }
      limit(value) {
        this.operation.addToPipeline({$limit: value});
        return this;
      }
      match(document2) {
        this.operation.addToPipeline({$match: document2});
        return this;
      }
      maxTimeMS(value) {
        this.operation.options.maxTimeMS = value;
        return this;
      }
      out(destination) {
        this.operation.addToPipeline({$out: destination});
        return this;
      }
      project(document2) {
        this.operation.addToPipeline({$project: document2});
        return this;
      }
      lookup(document2) {
        this.operation.addToPipeline({$lookup: document2});
        return this;
      }
      redact(document2) {
        this.operation.addToPipeline({$redact: document2});
        return this;
      }
      skip(value) {
        this.operation.addToPipeline({$skip: value});
        return this;
      }
      sort(document2) {
        this.operation.addToPipeline({$sort: document2});
        return this;
      }
      unwind(field) {
        this.operation.addToPipeline({$unwind: field});
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
    module2.exports = AggregationCursor;
  }
});

// node_modules/mongodb/lib/command_cursor.js
var require_command_cursor = __commonJS({
  "node_modules/mongodb/lib/command_cursor.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var CommandCursor = class extends Cursor {
      constructor(topology, ns, cmd, options2) {
        super(topology, ns, cmd, options2);
      }
      setReadPreference(readPreference) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({message: "Cursor is closed", driver: true});
        }
        if (typeof value !== "number") {
          throw MongoError.create({message: "batchSize requires an integer", driver: true});
        }
        if (this.cmd.cursor) {
          this.cmd.cursor.batchSize = value;
        }
        this.setCursorBatchSize(value);
        return this;
      }
      maxTimeMS(value) {
        if (this.topology.lastIsMaster().minWireVersion > 2) {
          this.cmd.maxTimeMS = value;
        }
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    CommandCursor.prototype.get = CommandCursor.prototype.toArray;
    module2.exports = CommandCursor;
  }
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/bulk_write.js"(exports2, module2) {
    "use strict";
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = class extends OperationBase {
      constructor(collection, operations, options2) {
        super(options2);
        this.collection = collection;
        this.operations = operations;
      }
      execute(callback) {
        const coll = this.collection;
        const operations = this.operations;
        let options2 = this.options;
        if (coll.s.options.ignoreUndefined) {
          options2 = Object.assign({}, options2);
          options2.ignoreUndefined = coll.s.options.ignoreUndefined;
        }
        const bulk = options2.ordered === true || options2.ordered == null ? coll.initializeOrderedBulkOp(options2) : coll.initializeUnorderedBulkOp(options2);
        let collation = false;
        try {
          for (let i = 0; i < operations.length; i++) {
            const key = Object.keys(operations[i])[0];
            if (operations[i][key].collation) {
              collation = true;
            }
            bulk.raw(operations[i]);
          }
        } catch (err) {
          return callback(err, null);
        }
        let finalOptions = Object.assign({}, options2);
        finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
        finalOptions = applyWriteConcern(finalOptions, {db: coll.s.db, collection: coll}, options2);
        const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
        const capabilities = coll.s.topology.capabilities();
        if (collation && capabilities && !capabilities.commandsTakeCollation) {
          return callback(new MongoError("server/primary/mongos does not support collation"));
        }
        bulk.execute(writeCon, finalOptions, (err, r) => {
          if (!r && err) {
            return callback(err, null);
          }
          callback(null, r);
        });
      }
    };
    module2.exports = BulkWriteOperation;
  }
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS({
  "node_modules/mongodb/lib/operations/count_documents.js"(exports2, module2) {
    "use strict";
    var AggregateOperation = require_aggregate();
    var CountDocumentsOperation = class extends AggregateOperation {
      constructor(collection, query, options2) {
        const pipeline2 = [{$match: query}];
        if (typeof options2.skip === "number") {
          pipeline2.push({$skip: options2.skip});
        }
        if (typeof options2.limit === "number") {
          pipeline2.push({$limit: options2.limit});
        }
        pipeline2.push({$group: {_id: 1, n: {$sum: 1}}});
        super(collection, pipeline2, options2);
      }
      execute(server, callback) {
        super.execute(server, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          const response = result.result;
          if (response.cursor == null || response.cursor.firstBatch == null) {
            callback(null, 0);
            return;
          }
          const docs = response.cursor.firstBatch;
          callback(null, docs.length ? docs[0].n : 0);
        });
      }
    };
    module2.exports = CountDocumentsOperation;
  }
});

// node_modules/mongodb/lib/operations/create_indexes.js
var require_create_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/create_indexes.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils4().parseIndexOptions;
    var maxWireVersion = require_utils2().maxWireVersion;
    var VALID_INDEX_OPTIONS = new Set([
      "background",
      "unique",
      "name",
      "partialFilterExpression",
      "sparse",
      "expireAfterSeconds",
      "storageEngine",
      "collation",
      "weights",
      "default_language",
      "language_override",
      "textIndexVersion",
      "2dsphereIndexVersion",
      "bits",
      "min",
      "max",
      "bucketSize",
      "wildcardProjection"
    ]);
    var CreateIndexesOperation = class extends CommandOperationV2 {
      constructor(parent, collection, indexes, options2) {
        super(parent, options2);
        this.collection = collection;
        if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {
          this.onlyReturnNameOfCreatedIndex = true;
          const indexParameters = parseIndexOptions(indexes);
          const name = typeof options2.name === "string" ? options2.name : indexParameters.name;
          const indexSpec = {name, key: indexParameters.fieldHash};
          for (let optionName in options2) {
            if (VALID_INDEX_OPTIONS.has(optionName)) {
              indexSpec[optionName] = options2[optionName];
            }
          }
          this.indexes = [indexSpec];
          return;
        }
        this.indexes = indexes;
      }
      execute(server, callback) {
        const options2 = this.options;
        const indexes = this.indexes;
        const serverWireVersion = maxWireVersion(server);
        for (let i = 0; i < indexes.length; i++) {
          if (indexes[i].collation && serverWireVersion < 5) {
            callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
            return;
          }
          if (indexes[i].name == null) {
            const keys = [];
            for (let name in indexes[i].key) {
              keys.push(`${name}_${indexes[i].key[name]}`);
            }
            indexes[i].name = keys.join("_");
          }
        }
        const cmd = {createIndexes: this.collection, indexes};
        if (options2.commitQuorum != null) {
          if (serverWireVersion < 9) {
            callback(new MongoError("`commitQuorum` option for `createIndexes` not supported on servers < 4.4"));
            return;
          }
          cmd.commitQuorum = options2.commitQuorum;
        }
        this.options.collation = void 0;
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);
        });
      }
    };
    defineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = CreateIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_many.js
var require_delete_many = __commonJS({
  "node_modules/mongodb/lib/operations/delete_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteManyOperation = class extends OperationBase {
      constructor(collection, filter, options2) {
        super(options2);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options2 = this.options;
        options2.single = false;
        removeDocuments(coll, filter, options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteManyOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_one.js
var require_delete_one = __commonJS({
  "node_modules/mongodb/lib/operations/delete_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteOneOperation = class extends OperationBase {
      constructor(collection, filter, options2) {
        super(options2);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options2 = this.options;
        options2.single = true;
        removeDocuments(coll, filter, options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteOneOperation;
  }
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS({
  "node_modules/mongodb/lib/operations/distinct.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var DistinctOperation = class extends CommandOperationV2 {
      constructor(collection, key, query, options2) {
        super(collection, options2);
        this.collection = collection;
        this.key = key;
        this.query = query;
      }
      execute(server, callback) {
        const coll = this.collection;
        const key = this.key;
        const query = this.query;
        const options2 = this.options;
        const cmd = {
          distinct: coll.collectionName,
          key,
          query
        };
        if (typeof options2.maxTimeMS === "number") {
          cmd.maxTimeMS = options2.maxTimeMS;
        }
        decorateWithReadConcern(cmd, coll, options2);
        try {
          decorateWithCollation(cmd, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain && maxWireVersion(server) < 4) {
          callback(new MongoError(`server does not support explain on distinct`));
          return;
        }
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.options.full || this.explain ? result : result.values);
        });
      }
    };
    defineAspects(DistinctOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = DistinctOperation;
  }
});

// node_modules/mongodb/lib/operations/command.js
var require_command2 = __commonJS({
  "node_modules/mongodb/lib/operations/command.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var debugOptions = require_utils4().debugOptions;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    var CommandOperation = class extends OperationBase {
      constructor(db, options2, collection, command) {
        super(options2);
        if (!this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (collection != null) {
            this.options.readPreference = ReadPreference.resolve(collection, options2);
          } else {
            this.options.readPreference = ReadPreference.resolve(db, options2);
          }
        } else {
          if (collection != null) {
            applyWriteConcern(this.options, {db, coll: collection}, this.options);
          } else {
            applyWriteConcern(this.options, {db}, this.options);
          }
          this.options.readPreference = ReadPreference.primary;
        }
        this.db = db;
        if (command != null) {
          this.command = command;
        }
        if (collection != null) {
          this.collection = collection;
        }
      }
      _buildCommand() {
        if (this.command != null) {
          return this.command;
        }
      }
      execute(callback) {
        const db = this.db;
        const options2 = Object.assign({}, this.options);
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        let command;
        try {
          command = this._buildCommand();
        } catch (e) {
          return callback(e);
        }
        const dbName = options2.dbName || options2.authdb || db.databaseName;
        if (this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (options2.writeConcern && (!options2.session || !options2.session.inTransaction())) {
            command.writeConcern = options2.writeConcern;
          }
        }
        if (db.s.logger.isDebug()) {
          db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options2))}]`);
        }
        const namespace = this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, "$cmd");
        db.s.topology.command(namespace, command, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (options2.full)
            return handleCallback(callback, null, result);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = CommandOperation;
  }
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS({
  "node_modules/mongodb/lib/operations/drop.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils4().handleCallback;
    var DropOperation = class extends CommandOperation {
      constructor(db, options2) {
        const finalOptions = Object.assign({}, options2, db.s.options);
        if (options2.session) {
          finalOptions.session = options2.session;
        }
        super(db, finalOptions);
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok)
            return handleCallback(callback, null, true);
          handleCallback(callback, null, false);
        });
      }
    };
    defineAspects(DropOperation, Aspect.WRITE_OPERATION);
    var DropCollectionOperation = class extends DropOperation {
      constructor(db, name, options2) {
        super(db, options2);
        this.name = name;
        this.namespace = `${db.namespace}.${name}`;
      }
      _buildCommand() {
        return {drop: this.name};
      }
    };
    var DropDatabaseOperation = class extends DropOperation {
      _buildCommand() {
        return {dropDatabase: 1};
      }
    };
    module2.exports = {
      DropOperation,
      DropCollectionOperation,
      DropDatabaseOperation
    };
  }
});

// node_modules/mongodb/lib/operations/drop_index.js
var require_drop_index = __commonJS({
  "node_modules/mongodb/lib/operations/drop_index.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var handleCallback = require_utils4().handleCallback;
    var DropIndexOperation = class extends CommandOperation {
      constructor(collection, indexName, options2) {
        super(collection.s.db, options2, collection);
        this.collection = collection;
        this.indexName = indexName;
      }
      _buildCommand() {
        const collection = this.collection;
        const indexName = this.indexName;
        const options2 = this.options;
        let cmd = {dropIndexes: collection.collectionName, index: indexName};
        cmd = applyWriteConcern(cmd, {db: collection.s.db, collection}, options2);
        return cmd;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (typeof callback !== "function")
            return;
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(DropIndexOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/drop_indexes.js
var require_drop_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/drop_indexes.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DropIndexOperation = require_drop_index();
    var handleCallback = require_utils4().handleCallback;
    var DropIndexesOperation = class extends DropIndexOperation {
      constructor(collection, options2) {
        super(collection, "*", options2);
      }
      execute(callback) {
        super.execute((err) => {
          if (err)
            return handleCallback(callback, err, false);
          handleCallback(callback, null, true);
        });
      }
    };
    defineAspects(DropIndexesOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS({
  "node_modules/mongodb/lib/operations/estimated_document_count.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var EstimatedDocumentCountOperation = class extends CommandOperationV2 {
      constructor(collection, query, options2) {
        if (typeof options2 === "undefined") {
          options2 = query;
          query = void 0;
        }
        super(collection, options2);
        this.collectionName = collection.s.namespace.collection;
        if (query) {
          this.query = query;
        }
      }
      execute(server, callback) {
        const options2 = this.options;
        const cmd = {count: this.collectionName};
        if (this.query) {
          cmd.query = this.query;
        }
        if (typeof options2.skip === "number") {
          cmd.skip = options2.skip;
        }
        if (typeof options2.limit === "number") {
          cmd.limit = options2.limit;
        }
        if (options2.hint) {
          cmd.hint = options2.hint;
        }
        super.executeCommand(server, cmd, (err, response) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, response.n);
        });
      }
    };
    defineAspects(EstimatedDocumentCountOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = EstimatedDocumentCountOperation;
  }
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS({
  "node_modules/mongodb/lib/operations/find.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error().MongoError;
    var FindOperation = class extends OperationBase {
      constructor(collection, ns, command, options2) {
        super(options2);
        this.ns = ns;
        this.cmd = command;
        this.readPreference = ReadPreference.resolve(collection, this.options);
      }
      execute(server, callback) {
        this.server = server;
        this.readPreference = ReadPreference.resolve(this, this.options);
        if (typeof this.cmd.allowDiskUse !== "undefined" && maxWireVersion(server) < 4) {
          callback(new MongoError("The `allowDiskUse` option is not supported on MongoDB < 3.2"));
          return;
        }
        if (this.explain) {
          this.options.explain = this.explain.verbosity;
        }
        const cursorState = this.cursorState || {};
        server.query(this.ns.toString(), this.cmd, cursorState, this.options, callback);
      }
    };
    defineAspects(FindOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = FindOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one.js
var require_find_one = __commonJS({
  "node_modules/mongodb/lib/operations/find_one.js"(exports2, module2) {
    "use strict";
    var handleCallback = require_utils4().handleCallback;
    var OperationBase = require_operation().OperationBase;
    var toError = require_utils4().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var FindOneOperation = class extends OperationBase {
      constructor(collection, query, options2) {
        super(options2);
        this.collection = collection;
        this.query = query;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const options2 = this.options;
        try {
          const cursor = coll.find(query, options2).limit(-1).batchSize(1);
          cursor.next((err, item) => {
            if (err != null)
              return handleCallback(callback, toError(err), null);
            handleCallback(callback, null, item);
          });
        } catch (e) {
          callback(e);
        }
      }
    };
    defineAspects(FindOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindOneOperation;
  }
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS({
  "node_modules/mongodb/lib/operations/find_and_modify.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var FindAndModifyOperation = class extends OperationBase {
      constructor(collection, query, sort, doc, options2) {
        super(options2);
        this.collection = collection;
        this.query = query;
        this.sort = sort;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const sort = formattedOrderClause(this.sort);
        const doc = this.doc;
        let options2 = this.options;
        let queryObject = {
          findAndModify: coll.collectionName,
          query
        };
        if (sort) {
          queryObject.sort = sort;
        }
        queryObject.new = options2.new ? true : false;
        queryObject.remove = options2.remove ? true : false;
        queryObject.upsert = options2.upsert ? true : false;
        const projection = options2.projection || options2.fields;
        if (projection) {
          queryObject.fields = projection;
        }
        if (options2.arrayFilters) {
          queryObject.arrayFilters = options2.arrayFilters;
        }
        if (doc && !options2.remove) {
          queryObject.update = doc;
        }
        if (options2.maxTimeMS)
          queryObject.maxTimeMS = options2.maxTimeMS;
        options2.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
        options2.checkKeys = false;
        options2 = applyRetryableWrites(options2, coll.s.db);
        options2 = applyWriteConcern(options2, {db: coll.s.db, collection: coll}, options2);
        if (options2.writeConcern) {
          queryObject.writeConcern = options2.writeConcern;
        }
        if (options2.bypassDocumentValidation === true) {
          queryObject.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        options2.readPreference = ReadPreference.primary;
        try {
          decorateWithCollation(queryObject, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (options2.hint) {
          const unacknowledgedWrite = options2.writeConcern && options2.writeConcern.w === 0;
          if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {
            callback(new MongoError("The current topology does not support a hint on findAndModify commands"));
            return;
          }
          queryObject.hint = options2.hint;
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 4) {
            callback(new MongoError(`server does not support explain on findAndModify`));
            return;
          }
          queryObject = decorateWithExplain(queryObject, this.explain);
        }
        executeCommand(coll.s.db, queryObject, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          return handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(FindAndModifyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindAndModifyOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_delete.js
var require_find_one_and_delete = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_delete.js"(exports2, module2) {
    "use strict";
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, options2) {
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.remove = true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        super(collection, filter, finalOptions.sort, null, finalOptions);
      }
    };
    module2.exports = FindOneAndDeleteOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_replace.js
var require_find_one_and_replace = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_replace.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, replacement, options2) {
        if ("returnDocument" in options2 && "returnOriginal" in options2) {
          throw new MongoError("findOneAndReplace option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.update = true;
        finalOptions.new = options2.returnDocument === "after" || options2.returnOriginal === false;
        finalOptions.upsert = options2.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (replacement == null || typeof replacement !== "object") {
          throw new TypeError("Replacement parameter must be an object");
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        super(collection, filter, finalOptions.sort, replacement, finalOptions);
      }
    };
    module2.exports = FindOneAndReplaceOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_update.js
var require_find_one_and_update = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_update.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, update, options2) {
        if ("returnDocument" in options2 && "returnOriginal" in options2) {
          throw new MongoError("findOneAndUpdate option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.update = true;
        finalOptions.new = options2.returnDocument === "after" || options2.returnOriginal === false;
        finalOptions.upsert = options2.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (update == null || typeof update !== "object") {
          throw new TypeError("Update parameter must be an object");
        }
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        super(collection, filter, finalOptions.sort, update, finalOptions);
      }
    };
    module2.exports = FindOneAndUpdateOperation;
  }
});

// node_modules/mongodb/lib/operations/geo_haystack_search.js
var require_geo_haystack_search = __commonJS({
  "node_modules/mongodb/lib/operations/geo_haystack_search.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var OperationBase = require_operation().OperationBase;
    var decorateCommand = require_utils4().decorateCommand;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var GeoHaystackSearchOperation = class extends OperationBase {
      constructor(collection, x, y, options2) {
        super(options2);
        this.collection = collection;
        this.x = x;
        this.y = y;
      }
      execute(callback) {
        const coll = this.collection;
        const x = this.x;
        const y = this.y;
        let options2 = this.options;
        let commandObject = {
          geoSearch: coll.collectionName,
          near: [x, y]
        };
        commandObject = decorateCommand(commandObject, options2, ["readPreference", "session"]);
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        decorateWithReadConcern(commandObject, coll, options2);
        executeCommand(coll.s.db, commandObject, options2, (err, res) => {
          if (err)
            return handleCallback(callback, err);
          if (res.err || res.errmsg)
            handleCallback(callback, toError(res));
          handleCallback(callback, null, res);
        });
      }
    };
    defineAspects(GeoHaystackSearchOperation, Aspect.READ_OPERATION);
    module2.exports = GeoHaystackSearchOperation;
  }
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/indexes.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexesOperation = class extends OperationBase {
      constructor(collection, options2) {
        super(options2);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        let options2 = this.options;
        options2 = Object.assign({}, {full: true}, options2);
        indexInformation(coll.s.db, coll.collectionName, options2, callback);
      }
    };
    module2.exports = IndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/index_exists.js
var require_index_exists = __commonJS({
  "node_modules/mongodb/lib/operations/index_exists.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var IndexExistsOperation = class extends OperationBase {
      constructor(collection, indexes, options2) {
        super(options2);
        this.collection = collection;
        this.indexes = indexes;
      }
      execute(callback) {
        const coll = this.collection;
        const indexes = this.indexes;
        const options2 = this.options;
        indexInformationDb(coll.s.db, coll.collectionName, options2, (err, indexInformation) => {
          if (err != null)
            return handleCallback(callback, err, null);
          if (!Array.isArray(indexes))
            return handleCallback(callback, null, indexInformation[indexes] != null);
          for (let i = 0; i < indexes.length; i++) {
            if (indexInformation[indexes[i]] == null) {
              return handleCallback(callback, null, false);
            }
          }
          return handleCallback(callback, null, true);
        });
      }
    };
    module2.exports = IndexExistsOperation;
  }
});

// node_modules/mongodb/lib/operations/index_information.js
var require_index_information = __commonJS({
  "node_modules/mongodb/lib/operations/index_information.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexInformationOperation = class extends OperationBase {
      constructor(db, name, options2) {
        super(options2);
        this.db = db;
        this.name = name;
      }
      execute(callback) {
        const db = this.db;
        const name = this.name;
        const options2 = this.options;
        indexInformation(db, name, options2, callback);
      }
    };
    module2.exports = IndexInformationOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_many.js
var require_insert_many = __commonJS({
  "node_modules/mongodb/lib/operations/insert_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = require_bulk_write();
    var MongoError = require_core().MongoError;
    var prepareDocs = require_common_functions().prepareDocs;
    var InsertManyOperation = class extends OperationBase {
      constructor(collection, docs, options2) {
        super(options2);
        this.collection = collection;
        this.docs = docs;
      }
      execute(callback) {
        const coll = this.collection;
        let docs = this.docs;
        const options2 = this.options;
        if (!Array.isArray(docs)) {
          return callback(MongoError.create({message: "docs parameter must be an array of documents", driver: true}));
        }
        options2["serializeFunctions"] = options2["serializeFunctions"] || coll.s.serializeFunctions;
        docs = prepareDocs(coll, docs, options2);
        const operations = docs.map((document2) => ({insertOne: {document: document2}}));
        const bulkWriteOperation = new BulkWriteOperation(coll, operations, options2);
        bulkWriteOperation.execute((err, result) => {
          if (err)
            return callback(err, null);
          callback(null, mapInsertManyResults(docs, result));
        });
      }
    };
    function mapInsertManyResults(docs, r) {
      const finalResult = {
        result: {ok: 1, n: r.insertedCount},
        ops: docs,
        insertedCount: r.insertedCount,
        insertedIds: r.insertedIds
      };
      if (r.getLastOp()) {
        finalResult.result.opTime = r.getLastOp();
      }
      return finalResult;
    }
    module2.exports = InsertManyOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_one.js
var require_insert_one = __commonJS({
  "node_modules/mongodb/lib/operations/insert_one.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var insertDocuments = require_common_functions().insertDocuments;
    var InsertOneOperation = class extends OperationBase {
      constructor(collection, doc, options2) {
        super(options2);
        this.collection = collection;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const doc = this.doc;
        const options2 = this.options;
        if (Array.isArray(doc)) {
          return callback(MongoError.create({message: "doc parameter must be an object", driver: true}));
        }
        insertDocuments(coll, [doc], options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          r.insertedCount = r.result.n;
          r.insertedId = doc._id;
          if (callback)
            callback(null, r);
        });
      }
    };
    module2.exports = InsertOneOperation;
  }
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS({
  "node_modules/mongodb/lib/operations/options_operation.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var OptionsOperation = class extends OperationBase {
      constructor(collection, options2) {
        super(options2);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        const opts = this.options;
        coll.s.db.listCollections({name: coll.collectionName}, opts).toArray((err, collections) => {
          if (err)
            return handleCallback(callback, err);
          if (collections.length === 0) {
            return handleCallback(callback, MongoError.create({message: `collection ${coll.namespace} not found`, driver: true}));
          }
          handleCallback(callback, err, collections[0].options || null);
        });
      }
    };
    module2.exports = OptionsOperation;
  }
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS({
  "node_modules/mongodb/lib/operations/is_capped.js"(exports2, module2) {
    "use strict";
    var OptionsOperation = require_options_operation();
    var handleCallback = require_utils4().handleCallback;
    var IsCappedOperation = class extends OptionsOperation {
      constructor(collection, options2) {
        super(collection, options2);
      }
      execute(callback) {
        super.execute((err, document2) => {
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, !!(document2 && document2.capped));
        });
      }
    };
    module2.exports = IsCappedOperation;
  }
});

// node_modules/mongodb/lib/operations/list_indexes.js
var require_list_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/list_indexes.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils2().maxWireVersion;
    var LIST_INDEXES_WIRE_VERSION = 3;
    var ListIndexesOperation = class extends CommandOperationV2 {
      constructor(collection, options2) {
        super(collection, options2, {fullResponse: true});
        this.collectionNamespace = collection.s.namespace;
      }
      execute(server, callback) {
        const serverWireVersion = maxWireVersion(server);
        if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {
          const systemIndexesNS = this.collectionNamespace.withCollection("system.indexes").toString();
          const collectionNS = this.collectionNamespace.toString();
          server.query(systemIndexesNS, {query: {ns: collectionNS}}, {}, this.options, callback);
          return;
        }
        const cursor = this.options.batchSize ? {batchSize: this.options.batchSize} : {};
        super.executeCommand(server, {listIndexes: this.collectionNamespace.collection, cursor}, callback);
      }
    };
    defineAspects(ListIndexesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS({
  "node_modules/mongodb/lib/operations/add_user.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var crypto = require("crypto");
    var handleCallback = require_utils4().handleCallback;
    var toError = require_utils4().toError;
    var emitWarning = require_utils4().emitWarning;
    var AddUserOperation = class extends CommandOperation {
      constructor(db, username, password, options2) {
        super(db, options2);
        this.username = username;
        this.password = password;
      }
      _buildCommand() {
        const db = this.db;
        const username = this.username;
        const password = this.password;
        const options2 = this.options;
        let roles = [];
        if (Array.isArray(options2.roles))
          roles = options2.roles;
        if (typeof options2.roles === "string")
          roles = [options2.roles];
        if (roles.length === 0) {
          emitWarning("Creating a user without roles is deprecated in MongoDB >= 2.6");
        }
        if ((db.databaseName.toLowerCase() === "admin" || options2.dbName === "admin") && !Array.isArray(options2.roles)) {
          roles = ["root"];
        } else if (!Array.isArray(options2.roles)) {
          roles = ["dbOwner"];
        }
        const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;
        let userPassword = password;
        if (!digestPassword) {
          const md5 = crypto.createHash("md5");
          md5.update(username + ":mongo:" + password);
          userPassword = md5.digest("hex");
        }
        const command = {
          createUser: username,
          customData: options2.customData || {},
          roles,
          digestPassword
        };
        if (typeof password === "string") {
          command.pwd = userPassword;
        }
        return command;
      }
      execute(callback) {
        const options2 = this.options;
        if (options2.digestPassword != null) {
          return callback(toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."));
        }
        super.execute((err, r) => {
          if (!err) {
            return handleCallback(callback, err, r);
          }
          return handleCallback(callback, err, null);
        });
      }
    };
    defineAspects(AddUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = AddUserOperation;
  }
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS({
  "node_modules/mongodb/lib/operations/collections.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var collection;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    var CollectionsOperation = class extends OperationBase {
      constructor(db, options2) {
        super(options2);
        this.db = db;
      }
      execute(callback) {
        const db = this.db;
        let options2 = this.options;
        let Collection = loadCollection();
        options2 = Object.assign({}, options2, {nameOnly: true});
        db.listCollections({}, options2).toArray((err, documents) => {
          if (err != null)
            return handleCallback(callback, err, null);
          documents = documents.filter((doc) => {
            return doc.name.indexOf("$") === -1;
          });
          handleCallback(callback, null, documents.map((d) => {
            return new Collection(db, db.s.topology, db.databaseName, d.name, db.s.pkFactory, db.s.options);
          }));
        });
      }
    };
    module2.exports = CollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS({
  "node_modules/mongodb/lib/operations/run_command.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var defineAspects = require_operation().defineAspects;
    var Aspect = require_operation().Aspect;
    var RunCommandOperation = class extends CommandOperationV2 {
      constructor(parent, command, options2) {
        super(parent, options2);
        this.command = command;
      }
      execute(server, callback) {
        const command = this.command;
        this.executeCommand(server, command, callback);
      }
    };
    defineAspects(RunCommandOperation, [Aspect.EXECUTE_WITH_SELECTION, Aspect.NO_INHERIT_OPTIONS]);
    module2.exports = RunCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS({
  "node_modules/mongodb/lib/operations/create_collection.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var ILLEGAL_COMMAND_FIELDS = new Set([
      "w",
      "wtimeout",
      "j",
      "fsync",
      "autoIndexId",
      "strict",
      "serializeFunctions",
      "pkFactory",
      "raw",
      "readPreference",
      "session",
      "readConcern",
      "writeConcern"
    ]);
    var CreateCollectionOperation = class extends CommandOperation {
      constructor(db, name, options2) {
        super(db, options2);
        this.name = name;
      }
      _buildCommand() {
        const name = this.name;
        const options2 = this.options;
        const cmd = {create: name};
        for (let n in options2) {
          if (options2[n] != null && typeof options2[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options2[n];
          }
        }
        return cmd;
      }
      execute(callback) {
        const db = this.db;
        const name = this.name;
        const options2 = this.options;
        const Collection = loadCollection();
        let listCollectionOptions = Object.assign({nameOnly: true, strict: false}, options2);
        listCollectionOptions = applyWriteConcern(listCollectionOptions, {db}, listCollectionOptions);
        function done(err) {
          if (err) {
            return callback(err);
          }
          try {
            callback(null, new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options2));
          } catch (err2) {
            callback(err2);
          }
        }
        const strictMode = listCollectionOptions.strict;
        if (strictMode) {
          db.listCollections({name}, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {
            if (err) {
              return callback(err);
            }
            if (collections.length > 0) {
              return callback(new MongoError(`Collection ${name} already exists. Currently in strict mode.`));
            }
            super.execute(done);
          });
          return;
        }
        super.execute(done);
      }
    };
    defineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);
    module2.exports = CreateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/execute_db_admin_command.js
var require_execute_db_admin_command = __commonJS({
  "node_modules/mongodb/lib/operations/execute_db_admin_command.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ExecuteDbAdminCommandOperation = class extends OperationBase {
      constructor(db, selector, options2) {
        super(options2);
        this.db = db;
        this.selector = selector;
      }
      execute(callback) {
        const db = this.db;
        const selector = this.selector;
        const options2 = this.options;
        const namespace = new MongoDBNamespace("admin", "$cmd");
        db.s.topology.command(namespace, selector, options2, (err, result) => {
          if (db.serverConfig && db.serverConfig.isDestroyed()) {
            return callback(new MongoError("topology was destroyed"));
          }
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = ExecuteDbAdminCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS({
  "node_modules/mongodb/lib/operations/list_collections.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils2().maxWireVersion;
    var CONSTANTS = require_constants2();
    var LIST_COLLECTIONS_WIRE_VERSION = 3;
    function listCollectionsTransforms(databaseName) {
      const matching = `${databaseName}.`;
      return {
        doc: (doc) => {
          const index2 = doc.name.indexOf(matching);
          if (doc.name && index2 === 0) {
            doc.name = doc.name.substr(index2 + matching.length);
          }
          return doc;
        }
      };
    }
    var ListCollectionsOperation = class extends CommandOperationV2 {
      constructor(db, filter, options2) {
        super(db, options2, {fullResponse: true});
        this.db = db;
        this.filter = filter;
        this.nameOnly = !!this.options.nameOnly;
        if (typeof this.options.batchSize === "number") {
          this.batchSize = this.options.batchSize;
        }
      }
      execute(server, callback) {
        if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {
          let filter = this.filter;
          const databaseName = this.db.s.namespace.db;
          if (typeof filter.name === "string" && !new RegExp("^" + databaseName + "\\.").test(filter.name)) {
            filter = Object.assign({}, filter);
            filter.name = this.db.s.namespace.withCollection(filter.name).toString();
          }
          if (filter == null) {
            filter.name = `/${databaseName}/`;
          }
          if (filter.name) {
            filter = {$and: [{name: filter.name}, {name: /^((?!\$).)*$/}]};
          } else {
            filter = {name: /^((?!\$).)*$/};
          }
          const transforms = listCollectionsTransforms(databaseName);
          server.query(`${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`, {query: filter}, {batchSize: this.batchSize || 1e3}, {}, (err, result) => {
            if (result && result.message && result.message.documents && Array.isArray(result.message.documents)) {
              result.message.documents = result.message.documents.map(transforms.doc);
            }
            callback(err, result);
          });
          return;
        }
        const command = {
          listCollections: 1,
          filter: this.filter,
          cursor: this.batchSize ? {batchSize: this.batchSize} : {},
          nameOnly: this.nameOnly
        };
        return super.executeCommand(server, command, callback);
      }
    };
    defineAspects(ListCollectionsOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListCollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/profiling_level.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var ProfilingLevelOperation = class extends CommandOperation {
      constructor(db, command, options2) {
        super(db, options2);
      }
      _buildCommand() {
        const command = {profile: -1};
        return command;
      }
      execute(callback) {
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1) {
            const was = doc.was;
            if (was === 0)
              return callback(null, "off");
            if (was === 1)
              return callback(null, "slow_only");
            if (was === 2)
              return callback(null, "all");
            return callback(new Error("Error: illegal profiling level value " + was), null);
          } else {
            err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
          }
        });
      }
    };
    module2.exports = ProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS({
  "node_modules/mongodb/lib/operations/remove_user.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils4().handleCallback;
    var WriteConcern = require_write_concern();
    var RemoveUserOperation = class extends CommandOperation {
      constructor(db, username, options2) {
        const commandOptions = {};
        const writeConcern = WriteConcern.fromOptions(options2);
        if (writeConcern != null) {
          commandOptions.writeConcern = writeConcern;
        }
        if (options2.dbName) {
          commandOptions.dbName = options2.dbName;
        }
        if (typeof options2.maxTimeMS === "number") {
          commandOptions.maxTimeMS = options2.maxTimeMS;
        }
        super(db, commandOptions);
        this.username = username;
      }
      _buildCommand() {
        const username = this.username;
        const command = {dropUser: username};
        return command;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, err, result.ok ? true : false);
        });
      }
    };
    defineAspects(RemoveUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = RemoveUserOperation;
  }
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS({
  "node_modules/mongodb/lib/operations/rename.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var checkCollectionName = require_utils4().checkCollectionName;
    var executeDbAdminCommand = require_db_ops().executeDbAdminCommand;
    var handleCallback = require_utils4().handleCallback;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var toError = require_utils4().toError;
    var RenameOperation = class extends OperationBase {
      constructor(collection, newName, options2) {
        super(options2);
        this.collection = collection;
        this.newName = newName;
      }
      execute(callback) {
        const coll = this.collection;
        const newName = this.newName;
        const options2 = this.options;
        let Collection = loadCollection();
        checkCollectionName(newName);
        const renameCollection = coll.namespace;
        const toCollection = coll.s.namespace.withCollection(newName).toString();
        const dropTarget = typeof options2.dropTarget === "boolean" ? options2.dropTarget : false;
        const cmd = {renameCollection, to: toCollection, dropTarget};
        applyWriteConcern(cmd, {db: coll.s.db, collection: coll}, options2);
        executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options2, (err, doc) => {
          if (err)
            return handleCallback(callback, err, null);
          if (doc.errmsg)
            return handleCallback(callback, toError(doc), null);
          try {
            return handleCallback(callback, null, new Collection(coll.s.db, coll.s.topology, coll.s.namespace.db, newName, coll.s.pkFactory, coll.s.options));
          } catch (err2) {
            return handleCallback(callback, toError(err2), null);
          }
        });
      }
    };
    module2.exports = RenameOperation;
  }
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/set_profiling_level.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var levelValues = new Set(["off", "slow_only", "all"]);
    var SetProfilingLevelOperation = class extends CommandOperation {
      constructor(db, level, options2) {
        let profile = 0;
        if (level === "off") {
          profile = 0;
        } else if (level === "slow_only") {
          profile = 1;
        } else if (level === "all") {
          profile = 2;
        }
        super(db, options2);
        this.level = level;
        this.profile = profile;
      }
      _buildCommand() {
        const profile = this.profile;
        const command = {profile};
        return command;
      }
      execute(callback) {
        const level = this.level;
        if (!levelValues.has(level)) {
          return callback(new Error("Error: illegal profiling level value " + level));
        }
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1)
            return callback(null, level);
          return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
        });
      }
    };
    module2.exports = SetProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS({
  "node_modules/mongodb/lib/operations/validate_collection.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var ValidateCollectionOperation = class extends CommandOperation {
      constructor(admin, collectionName, options2) {
        let command = {validate: collectionName};
        const keys = Object.keys(options2);
        for (let i = 0; i < keys.length; i++) {
          if (Object.prototype.hasOwnProperty.call(options2, keys[i]) && keys[i] !== "session") {
            command[keys[i]] = options2[keys[i]];
          }
        }
        super(admin.s.db, options2, null, command);
        this.collectionName = collectionName;
      }
      execute(callback) {
        const collectionName = this.collectionName;
        super.execute((err, doc) => {
          if (err != null)
            return callback(err, null);
          if (doc.ok === 0)
            return callback(new Error("Error with validate command"), null);
          if (doc.result != null && doc.result.constructor !== String)
            return callback(new Error("Error with validation data"), null);
          if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          if (doc.valid != null && !doc.valid)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          return callback(null, doc);
        });
      }
    };
    module2.exports = ValidateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS({
  "node_modules/mongodb/lib/operations/list_databases.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ListDatabasesOperation = class extends CommandOperationV2 {
      constructor(db, options2) {
        super(db, options2);
        this.ns = new MongoDBNamespace("admin", "$cmd");
      }
      execute(server, callback) {
        const cmd = {listDatabases: 1};
        if (this.options.nameOnly) {
          cmd.nameOnly = Number(cmd.nameOnly);
        }
        if (this.options.filter) {
          cmd.filter = this.options.filter;
        }
        if (typeof this.options.authorizedDatabases === "boolean") {
          cmd.authorizedDatabases = this.options.authorizedDatabases;
        }
        super.executeCommand(server, cmd, callback);
      }
    };
    defineAspects(ListDatabasesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListDatabasesOperation;
  }
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS({
  "node_modules/mongodb/lib/admin.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var AddUserOperation = require_add_user();
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var RemoveUserOperation = require_remove_user();
    var ValidateCollectionOperation = require_validate_collection();
    var ListDatabasesOperation = require_list_databases();
    var executeOperation = require_execute_operation();
    function Admin(db, topology, promiseLibrary) {
      if (!(this instanceof Admin))
        return new Admin(db, topology);
      this.s = {
        db,
        topology,
        promiseLibrary
      };
    }
    Admin.prototype.command = function(command, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      const commandOperation = new ExecuteDbAdminCommandOperation(this.s.db, command, options2);
      return executeOperation(this.s.db.s.topology, commandOperation, callback);
    };
    Admin.prototype.buildInfo = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd = {buildinfo: 1};
      const buildInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options2);
      return executeOperation(this.s.db.s.topology, buildInfoOperation, callback);
    };
    Admin.prototype.serverInfo = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd = {buildinfo: 1};
      const serverInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options2);
      return executeOperation(this.s.db.s.topology, serverInfoOperation, callback);
    };
    Admin.prototype.serverStatus = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const serverStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, {serverStatus: 1}, options2);
      return executeOperation(this.s.db.s.topology, serverStatusOperation, callback);
    };
    Admin.prototype.ping = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd = {ping: 1};
      const pingOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options2);
      return executeOperation(this.s.db.s.topology, pingOperation, callback);
    };
    Admin.prototype.addUser = function(username, password, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      if (typeof username === "string" && password != null && typeof password === "object") {
        options2 = password;
        password = null;
      }
      options2 = args.length ? args.shift() : {};
      options2 = Object.assign({}, options2);
      options2 = applyWriteConcern(options2, {db: this.s.db});
      options2.dbName = "admin";
      const addUserOperation = new AddUserOperation(this.s.db, username, password, options2);
      return executeOperation(this.s.db.s.topology, addUserOperation, callback);
    };
    Admin.prototype.removeUser = function(username, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      options2 = Object.assign({}, options2);
      options2 = applyWriteConcern(options2, {db: this.s.db});
      options2.dbName = "admin";
      const removeUserOperation = new RemoveUserOperation(this.s.db, username, options2);
      return executeOperation(this.s.db.s.topology, removeUserOperation, callback);
    };
    Admin.prototype.validateCollection = function(collectionName, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const validateCollectionOperation = new ValidateCollectionOperation(this, collectionName, options2);
      return executeOperation(this.s.db.s.topology, validateCollectionOperation, callback);
    };
    Admin.prototype.listDatabases = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeOperation(this.s.db.s.topology, new ListDatabasesOperation(this.s.db, options2), callback);
    };
    Admin.prototype.replSetGetStatus = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const replSetGetStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, {replSetGetStatus: 1}, options2);
      return executeOperation(this.s.db.s.topology, replSetGetStatusOperation, callback);
    };
    module2.exports = Admin;
  }
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS({
  "node_modules/mongodb/lib/db.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var inherits = require("util").inherits;
    var getSingleProperty = require_utils4().getSingleProperty;
    var CommandCursor = require_command_cursor();
    var handleCallback = require_utils4().handleCallback;
    var filterOptions = require_utils4().filterOptions;
    var toError = require_utils4().toError;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().ObjectID;
    var Logger = require_core().Logger;
    var Collection = require_collection();
    var conditionallyMergeWriteConcern = require_utils4().conditionallyMergeWriteConcern;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var ChangeStream = require_change_stream();
    var deprecate = require("util").deprecate;
    var deprecateOptions = require_utils4().deprecateOptions;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var CONSTANTS = require_constants2();
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var AggregationCursor = require_aggregation_cursor();
    var createListener = require_db_ops().createListener;
    var ensureIndex = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var profilingInfo = require_db_ops().profilingInfo;
    var validateDatabaseName = require_db_ops().validateDatabaseName;
    var AggregateOperation = require_aggregate();
    var AddUserOperation = require_add_user();
    var CollectionsOperation = require_collections();
    var CommandOperation = require_command2();
    var RunCommandOperation = require_run_command();
    var CreateCollectionOperation = require_create_collection();
    var CreateIndexesOperation = require_create_indexes();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropDatabaseOperation = require_drop().DropDatabaseOperation;
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var IndexInformationOperation = require_index_information();
    var ListCollectionsOperation = require_list_collections();
    var ProfilingLevelOperation = require_profiling_level();
    var RemoveUserOperation = require_remove_user();
    var RenameOperation = require_rename();
    var SetProfilingLevelOperation = require_set_profiling_level();
    var executeOperation = require_execute_operation();
    var legalOptionNames = [
      "w",
      "wtimeout",
      "fsync",
      "j",
      "writeConcern",
      "readPreference",
      "readPreferenceTags",
      "native_parser",
      "forceServerObjectId",
      "pkFactory",
      "serializeFunctions",
      "raw",
      "bufferMaxEntries",
      "authSource",
      "ignoreUndefined",
      "promoteLongs",
      "promiseLibrary",
      "readConcern",
      "retryMiliSeconds",
      "numberOfRetries",
      "parentDb",
      "noListener",
      "loggerLevel",
      "logger",
      "promoteBuffers",
      "promoteLongs",
      "promoteValues",
      "compression",
      "retryWrites"
    ];
    function Db(databaseName, topology, options2) {
      options2 = options2 || {};
      if (!(this instanceof Db))
        return new Db(databaseName, topology, options2);
      EventEmitter.call(this);
      const promiseLibrary = options2.promiseLibrary || Promise;
      options2 = filterOptions(options2, legalOptionNames);
      options2.promiseLibrary = promiseLibrary;
      this.s = {
        dbCache: {},
        children: [],
        topology,
        options: options2,
        logger: Logger("Db", options2),
        bson: topology ? topology.bson : null,
        readPreference: ReadPreference.fromOptions(options2),
        bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : -1,
        parentDb: options2.parentDb || null,
        pkFactory: options2.pkFactory || ObjectID2,
        nativeParser: options2.nativeParser || options2.native_parser,
        promiseLibrary,
        noListener: typeof options2.noListener === "boolean" ? options2.noListener : false,
        readConcern: ReadConcern.fromOptions(options2),
        writeConcern: WriteConcern.fromOptions(options2),
        namespace: new MongoDBNamespace(databaseName)
      };
      validateDatabaseName(databaseName);
      getSingleProperty(this, "serverConfig", this.s.topology);
      getSingleProperty(this, "bufferMaxEntries", this.s.bufferMaxEntries);
      getSingleProperty(this, "databaseName", this.s.namespace.db);
      if (options2.parentDb)
        return;
      if (this.s.noListener)
        return;
      topology.on("error", createListener(this, "error", this));
      topology.on("timeout", createListener(this, "timeout", this));
      topology.on("close", createListener(this, "close", this));
      topology.on("parseError", createListener(this, "parseError", this));
      topology.once("open", createListener(this, "open", this));
      topology.once("fullsetup", createListener(this, "fullsetup", this));
      topology.once("all", createListener(this, "all", this));
      topology.on("reconnect", createListener(this, "reconnect", this));
    }
    inherits(Db, EventEmitter);
    Db.prototype.on = deprecate(function() {
      return Db.super_.prototype.on.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Db.prototype.once = deprecate(function() {
      return Db.super_.prototype.once.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Object.defineProperty(Db.prototype, "topology", {
      enumerable: true,
      get: function() {
        return this.s.topology;
      }
    });
    Object.defineProperty(Db.prototype, "options", {
      enumerable: true,
      get: function() {
        return this.s.options;
      }
    });
    Object.defineProperty(Db.prototype, "slaveOk", {
      enumerable: true,
      get: function() {
        if (this.s.options.readPreference != null && (this.s.options.readPreference !== "primary" || this.s.options.readPreference.mode !== "primary")) {
          return true;
        }
        return false;
      }
    });
    Object.defineProperty(Db.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Db.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return ReadPreference.primary;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Db.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Db.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Db.prototype.command = function(command, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      const commandOperation = new RunCommandOperation(this, command, options2);
      return executeOperation(this.s.topology, commandOperation, callback);
    };
    Db.prototype.aggregate = function(pipeline2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (options2 == null && callback == null) {
        options2 = {};
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline2, options2), options2);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Db.prototype.admin = function() {
      const Admin = require_admin();
      return new Admin(this, this.s.topology, this.s.promiseLibrary);
    };
    var COLLECTION_OPTION_KEYS = [
      "pkFactory",
      "readPreference",
      "serializeFunctions",
      "strict",
      "readConcern",
      "ignoreUndefined",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs"
    ];
    Db.prototype.collection = function(name, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2 = Object.assign({}, options2);
      options2.promiseLibrary = this.s.promiseLibrary;
      options2.readConcern = options2.readConcern ? new ReadConcern(options2.readConcern.level) : this.readConcern;
      if (this.s.options.ignoreUndefined) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      for (const collectionOptionKey of COLLECTION_OPTION_KEYS) {
        if (!(collectionOptionKey in options2) && this.s.options[collectionOptionKey] !== void 0) {
          options2[collectionOptionKey] = this.s.options[collectionOptionKey];
        }
      }
      options2 = conditionallyMergeWriteConcern(options2, this.s.options);
      if (options2 == null || !options2.strict) {
        try {
          const collection = new Collection(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options2);
          if (callback)
            callback(null, collection);
          return collection;
        } catch (err) {
          if (err instanceof MongoError && callback)
            return callback(err);
          throw err;
        }
      }
      if (typeof callback !== "function") {
        throw toError(`A callback is required in strict mode. While getting collection ${name}`);
      }
      if (this.serverConfig && this.serverConfig.isDestroyed()) {
        return callback(new MongoError("topology was destroyed"));
      }
      const listCollectionOptions = Object.assign({}, options2, {nameOnly: true});
      this.listCollections({name}, listCollectionOptions).toArray((err, collections) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (collections.length === 0)
          return handleCallback(callback, toError(`Collection ${name} does not exist. Currently in strict mode.`), null);
        try {
          return handleCallback(callback, null, new Collection(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options2));
        } catch (err2) {
          return handleCallback(callback, err2, null);
        }
      });
    };
    Db.prototype.createCollection = deprecateOptions({
      name: "Db.createCollection",
      deprecatedOptions: ["autoIndexId", "strict", "w", "wtimeout", "j"],
      optionsIndex: 1
    }, function(name, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2.promiseLibrary = options2.promiseLibrary || this.s.promiseLibrary;
      options2.readConcern = options2.readConcern ? new ReadConcern(options2.readConcern.level) : this.readConcern;
      const createCollectionOperation = new CreateCollectionOperation(this, name, options2);
      return executeOperation(this.s.topology, createCollectionOperation, callback);
    });
    Db.prototype.stats = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const commandObject = {dbStats: true};
      if (options2["scale"] != null)
        commandObject["scale"] = options2["scale"];
      if (options2.readPreference == null && this.s.readPreference) {
        options2.readPreference = this.s.readPreference;
      }
      const statsOperation = new CommandOperation(this, options2, null, commandObject);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Db.prototype.listCollections = function(filter, options2) {
      filter = filter || {};
      options2 = options2 || {};
      return new CommandCursor(this.s.topology, new ListCollectionsOperation(this, filter, options2), options2);
    };
    Db.prototype.eval = deprecate(function(code, parameters, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      parameters = args.length ? args.shift() : parameters;
      options2 = args.length ? args.shift() || {} : {};
      return executeLegacyOperation(this.s.topology, evaluate, [
        this,
        code,
        parameters,
        options2,
        callback
      ]);
    }, "Db.eval is deprecated as of MongoDB version 3.2");
    Db.prototype.renameCollection = function(fromCollection, toCollection, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2, {readPreference: ReadPreference.PRIMARY});
      options2.new_collection = true;
      const renameOperation = new RenameOperation(this.collection(fromCollection), toCollection, options2);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Db.prototype.dropCollection = function(name, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropCollectionOperation = new DropCollectionOperation(this, name, options2);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Db.prototype.dropDatabase = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropDatabaseOperation = new DropDatabaseOperation(this, options2);
      return executeOperation(this.s.topology, dropDatabaseOperation, callback);
    };
    Db.prototype.collections = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const collectionsOperation = new CollectionsOperation(this, options2);
      return executeOperation(this.s.topology, collectionsOperation, callback);
    };
    Db.prototype.executeDbAdminCommand = function(selector, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2.readPreference = ReadPreference.resolve(this, options2);
      const executeDbAdminCommandOperation = new ExecuteDbAdminCommandOperation(this, selector, options2);
      return executeOperation(this.s.topology, executeDbAdminCommandOperation, callback);
    };
    Db.prototype.createIndex = function(name, fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      const createIndexesOperation = new CreateIndexesOperation(this, name, fieldOrSpec, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Db.prototype.ensureIndex = deprecate(function(name, fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        name,
        fieldOrSpec,
        options2,
        callback
      ]);
    }, "Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0");
    Db.prototype.addChild = function(db) {
      if (this.s.parentDb)
        return this.s.parentDb.addChild(db);
      this.s.children.push(db);
    };
    Db.prototype.addUser = function(username, password, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (typeof username === "string" && password != null && typeof password === "object") {
        options2 = password;
        password = null;
      }
      const addUserOperation = new AddUserOperation(this, username, password, options2);
      return executeOperation(this.s.topology, addUserOperation, callback);
    };
    Db.prototype.removeUser = function(username, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const removeUserOperation = new RemoveUserOperation(this, username, options2);
      return executeOperation(this.s.topology, removeUserOperation, callback);
    };
    Db.prototype.setProfilingLevel = function(level, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const setProfilingLevelOperation = new SetProfilingLevelOperation(this, level, options2);
      return executeOperation(this.s.topology, setProfilingLevelOperation, callback);
    };
    Db.prototype.profilingInfo = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, profilingInfo, [this, options2, callback]);
    }, "Db.profilingInfo is deprecated. Query the system.profile collection directly.");
    Db.prototype.profilingLevel = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const profilingLevelOperation = new ProfilingLevelOperation(this, options2);
      return executeOperation(this.s.topology, profilingLevelOperation, callback);
    };
    Db.prototype.indexInformation = function(name, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexInformationOperation = new IndexInformationOperation(this, name, options2);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Db.prototype.unref = function() {
      this.s.topology.unref();
    };
    Db.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    Db.prototype.getLogger = function() {
      return this.s.logger;
    };
    Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
    module2.exports = Db;
  }
});

// node_modules/mongodb/lib/dynamic_loaders.js
var require_dynamic_loaders = __commonJS({
  "node_modules/mongodb/lib/dynamic_loaders.js"(exports2, module2) {
    "use strict";
    var collection;
    var cursor;
    var db;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    function loadCursor() {
      if (!cursor) {
        cursor = require_cursor2();
      }
      return cursor;
    }
    function loadDb() {
      if (!db) {
        db = require_db();
      }
      return db;
    }
    module2.exports = {
      loadCollection,
      loadCursor,
      loadDb
    };
  }
});

// node_modules/mongodb/lib/operations/map_reduce.js
var require_map_reduce = __commonJS({
  "node_modules/mongodb/lib/operations/map_reduce.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var isObject = require_utils4().isObject;
    var loadDb = require_dynamic_loaders().loadDb;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var exclusionList = [
      "explain",
      "readPreference",
      "session",
      "bypassDocumentValidation",
      "w",
      "wtimeout",
      "j",
      "writeConcern"
    ];
    var MapReduceOperation = class extends OperationBase {
      constructor(collection, map, reduce, options2) {
        super(options2);
        this.collection = collection;
        this.map = map;
        this.reduce = reduce;
      }
      execute(callback) {
        const coll = this.collection;
        const map = this.map;
        const reduce = this.reduce;
        let options2 = this.options;
        let mapCommandHash = {
          mapReduce: coll.collectionName,
          map,
          reduce
        };
        for (let n in options2) {
          if (n === "scope") {
            mapCommandHash[n] = processScope(options2[n]);
          } else {
            if (exclusionList.indexOf(n) === -1) {
              mapCommandHash[n] = options2[n];
            }
          }
        }
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        if (options2.readPreference !== false && options2.readPreference !== "primary" && options2["out"] && options2["out"].inline !== 1 && options2["out"] !== "inline") {
          options2.readPreference = "primary";
          applyWriteConcern(mapCommandHash, {db: coll.s.db, collection: coll}, options2);
        } else {
          decorateWithReadConcern(mapCommandHash, coll, options2);
        }
        if (options2.bypassDocumentValidation === true) {
          mapCommandHash.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        try {
          decorateWithCollation(mapCommandHash, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 9) {
            callback(new MongoError(`server does not support explain on mapReduce`));
            return;
          }
          mapCommandHash = decorateWithExplain(mapCommandHash, this.explain);
        }
        executeCommand(coll.s.db, mapCommandHash, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok !== 1 || result.err || result.errmsg) {
            return handleCallback(callback, toError(result));
          }
          if (this.explain)
            return callback(void 0, result);
          const stats = {};
          if (result.timeMillis)
            stats["processtime"] = result.timeMillis;
          if (result.counts)
            stats["counts"] = result.counts;
          if (result.timing)
            stats["timing"] = result.timing;
          if (result.results) {
            if (options2["verbose"] == null || !options2["verbose"]) {
              return handleCallback(callback, null, result.results);
            }
            return handleCallback(callback, null, {results: result.results, stats});
          }
          let collection = null;
          if (result.result != null && typeof result.result === "object") {
            const doc = result.result;
            let Db = loadDb();
            collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(doc.collection);
          } else {
            collection = coll.s.db.collection(result.result);
          }
          if (options2["verbose"] == null || !options2["verbose"]) {
            return handleCallback(callback, err, collection);
          }
          handleCallback(callback, err, {collection, stats});
        });
      }
    };
    function processScope(scope) {
      if (!isObject(scope) || scope._bsontype === "ObjectID") {
        return scope;
      }
      const keys = Object.keys(scope);
      let key;
      const new_scope = {};
      for (let i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        if (typeof scope[key] === "function") {
          new_scope[key] = new Code2(String(scope[key]));
        } else {
          new_scope[key] = processScope(scope[key]);
        }
      }
      return new_scope;
    }
    defineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);
    module2.exports = MapReduceOperation;
  }
});

// node_modules/mongodb/lib/operations/re_index.js
var require_re_index = __commonJS({
  "node_modules/mongodb/lib/operations/re_index.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var serverType = require_common().serverType;
    var ServerType = require_common().ServerType;
    var MongoError = require_core().MongoError;
    var ReIndexOperation = class extends CommandOperationV2 {
      constructor(collection, options2) {
        super(collection, options2);
        this.collectionName = collection.collectionName;
      }
      execute(server, callback) {
        if (serverType(server) !== ServerType.Standalone) {
          callback(new MongoError(`reIndex can only be executed on standalone servers.`));
          return;
        }
        super.executeCommand(server, {reIndex: this.collectionName}, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, !!result.ok);
        });
      }
    };
    defineAspects(ReIndexOperation, [Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = ReIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/replace_one.js
var require_replace_one = __commonJS({
  "node_modules/mongodb/lib/operations/replace_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var ReplaceOneOperation = class extends OperationBase {
      constructor(collection, filter, replacement, options2) {
        super(options2);
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.replacement = replacement;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const replacement = this.replacement;
        const options2 = this.options;
        options2.multi = false;
        updateDocuments(coll, filter, replacement, options2, (err, r) => replaceCallback(err, r, replacement, callback));
      }
    };
    function replaceCallback(err, r, doc, callback) {
      if (callback == null)
        return;
      if (err && callback)
        return callback(err);
      if (r == null)
        return callback(null, {result: {ok: 1}});
      r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
      r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
      r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
      r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
      r.ops = [doc];
      if (callback)
        callback(null, r);
    }
    module2.exports = ReplaceOneOperation;
  }
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS({
  "node_modules/mongodb/lib/operations/stats.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var StatsOperation = class extends CommandOperation {
      constructor(collection, options2) {
        super(collection.s.db, options2, collection);
      }
      _buildCommand() {
        const collection = this.collection;
        const options2 = this.options;
        const command = {
          collStats: collection.collectionName
        };
        if (options2["scale"] != null) {
          command["scale"] = options2["scale"];
        }
        return command;
      }
    };
    defineAspects(StatsOperation, Aspect.READ_OPERATION);
    module2.exports = StatsOperation;
  }
});

// node_modules/mongodb/lib/operations/update_many.js
var require_update_many = __commonJS({
  "node_modules/mongodb/lib/operations/update_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateManyOperation = class extends OperationBase {
      constructor(collection, filter, update, options2) {
        super(options2);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options2 = this.options;
        options2.multi = true;
        updateDocuments(coll, filter, update, options2, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateManyOperation;
  }
});

// node_modules/mongodb/lib/operations/update_one.js
var require_update_one = __commonJS({
  "node_modules/mongodb/lib/operations/update_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateOneOperation = class extends OperationBase {
      constructor(collection, filter, update, options2) {
        super(options2);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options2 = this.options;
        options2.multi = false;
        updateDocuments(coll, filter, update, options2, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, {result: {ok: 1}});
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateOneOperation;
  }
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS({
  "node_modules/mongodb/lib/collection.js"(exports2, module2) {
    "use strict";
    var deprecate = require("util").deprecate;
    var deprecateOptions = require_utils4().deprecateOptions;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var checkCollectionName = require_utils4().checkCollectionName;
    var ObjectID2 = require_core().BSON.ObjectID;
    var MongoError = require_core().MongoError;
    var normalizeHintField = require_utils4().normalizeHintField;
    var decorateCommand = require_utils4().decorateCommand;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var ReadPreference = require_core().ReadPreference;
    var unordered = require_unordered();
    var ordered = require_ordered();
    var ChangeStream = require_change_stream();
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var AggregationCursor = require_aggregation_cursor();
    var CommandCursor = require_command_cursor();
    var ensureIndex = require_collection_ops().ensureIndex;
    var group = require_collection_ops().group;
    var parallelCollectionScan = require_collection_ops().parallelCollectionScan;
    var removeDocuments = require_common_functions().removeDocuments;
    var save = require_collection_ops().save;
    var updateDocuments = require_common_functions().updateDocuments;
    var AggregateOperation = require_aggregate();
    var BulkWriteOperation = require_bulk_write();
    var CountDocumentsOperation = require_count_documents();
    var CreateIndexesOperation = require_create_indexes();
    var DeleteManyOperation = require_delete_many();
    var DeleteOneOperation = require_delete_one();
    var DistinctOperation = require_distinct();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropIndexOperation = require_drop_index();
    var DropIndexesOperation = require_drop_indexes();
    var EstimatedDocumentCountOperation = require_estimated_document_count();
    var FindOperation = require_find();
    var FindOneOperation = require_find_one();
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = require_find_one_and_delete();
    var FindOneAndReplaceOperation = require_find_one_and_replace();
    var FindOneAndUpdateOperation = require_find_one_and_update();
    var GeoHaystackSearchOperation = require_geo_haystack_search();
    var IndexesOperation = require_indexes();
    var IndexExistsOperation = require_index_exists();
    var IndexInformationOperation = require_index_information();
    var InsertManyOperation = require_insert_many();
    var InsertOneOperation = require_insert_one();
    var IsCappedOperation = require_is_capped();
    var ListIndexesOperation = require_list_indexes();
    var MapReduceOperation = require_map_reduce();
    var OptionsOperation = require_options_operation();
    var RenameOperation = require_rename();
    var ReIndexOperation = require_re_index();
    var ReplaceOneOperation = require_replace_one();
    var StatsOperation = require_stats();
    var UpdateManyOperation = require_update_many();
    var UpdateOneOperation = require_update_one();
    var executeOperation = require_execute_operation();
    var mergeKeys = ["ignoreUndefined"];
    function Collection(db, topology, dbName, name, pkFactory, options2) {
      checkCollectionName(name);
      const internalHint = null;
      const slaveOk = options2 == null || options2.slaveOk == null ? db.slaveOk : options2.slaveOk;
      const serializeFunctions = options2 == null || options2.serializeFunctions == null ? db.s.options.serializeFunctions : options2.serializeFunctions;
      const raw = options2 == null || options2.raw == null ? db.s.options.raw : options2.raw;
      const promoteLongs = options2 == null || options2.promoteLongs == null ? db.s.options.promoteLongs : options2.promoteLongs;
      const promoteValues = options2 == null || options2.promoteValues == null ? db.s.options.promoteValues : options2.promoteValues;
      const promoteBuffers = options2 == null || options2.promoteBuffers == null ? db.s.options.promoteBuffers : options2.promoteBuffers;
      const collectionHint = null;
      const namespace = new MongoDBNamespace(dbName, name);
      const promiseLibrary = options2.promiseLibrary || Promise;
      pkFactory = pkFactory == null ? ObjectID2 : pkFactory;
      this.s = {
        pkFactory,
        db,
        topology,
        options: options2,
        namespace,
        readPreference: ReadPreference.fromOptions(options2),
        slaveOk,
        serializeFunctions,
        raw,
        promoteLongs,
        promoteValues,
        promoteBuffers,
        internalHint,
        collectionHint,
        promiseLibrary,
        readConcern: ReadConcern.fromOptions(options2),
        writeConcern: WriteConcern.fromOptions(options2)
      };
    }
    Object.defineProperty(Collection.prototype, "dbName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.db;
      }
    });
    Object.defineProperty(Collection.prototype, "collectionName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.collection;
      }
    });
    Object.defineProperty(Collection.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Object.defineProperty(Collection.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        if (this.s.readConcern == null) {
          return this.s.db.readConcern;
        }
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return this.s.db.readPreference;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Collection.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        if (this.s.writeConcern == null) {
          return this.s.db.writeConcern;
        }
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "hint", {
      enumerable: true,
      get: function() {
        return this.s.collectionHint;
      },
      set: function(v) {
        this.s.collectionHint = normalizeHintField(v);
      }
    });
    var DEPRECATED_FIND_OPTIONS = ["maxScan", "fields", "snapshot", "oplogReplay"];
    Collection.prototype.find = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options2, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `find()` must be a callback or undefined");
      }
      let selector = query;
      if (typeof callback !== "function") {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = void 0;
        } else if (options2 == null) {
          callback = typeof selector === "function" ? selector : void 0;
          selector = typeof selector === "object" ? selector : void 0;
        }
      }
      selector = selector == null ? {} : selector;
      const object = selector;
      if (Buffer.isBuffer(object)) {
        const object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
        if (object_size !== object.length) {
          const error3 = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
          error3.name = "MongoError";
          throw error3;
        }
      }
      if (selector != null && selector._bsontype === "ObjectID") {
        selector = {_id: selector};
      }
      if (!options2)
        options2 = {};
      let projection = options2.projection || options2.fields;
      if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
        projection = projection.length ? projection.reduce((result, field) => {
          result[field] = 1;
          return result;
        }, {}) : {_id: 1};
      }
      let newOptions = Object.assign({}, options2);
      for (let key in this.s.options) {
        if (mergeKeys.indexOf(key) !== -1) {
          newOptions[key] = this.s.options[key];
        }
      }
      newOptions.skip = options2.skip ? options2.skip : 0;
      newOptions.limit = options2.limit ? options2.limit : 0;
      newOptions.raw = typeof options2.raw === "boolean" ? options2.raw : this.s.raw;
      newOptions.hint = options2.hint != null ? normalizeHintField(options2.hint) : this.s.collectionHint;
      newOptions.timeout = typeof options2.timeout === "undefined" ? void 0 : options2.timeout;
      newOptions.slaveOk = options2.slaveOk != null ? options2.slaveOk : this.s.db.slaveOk;
      newOptions.readPreference = ReadPreference.resolve(this, newOptions);
      if (newOptions.readPreference != null && (newOptions.readPreference !== "primary" || newOptions.readPreference.mode !== "primary")) {
        newOptions.slaveOk = true;
      }
      if (selector != null && typeof selector !== "object") {
        throw MongoError.create({message: "query selector must be an object", driver: true});
      }
      const findCommand = {
        find: this.s.namespace.toString(),
        limit: newOptions.limit,
        skip: newOptions.skip,
        query: selector
      };
      if (typeof options2.allowDiskUse === "boolean") {
        findCommand.allowDiskUse = options2.allowDiskUse;
      }
      if (typeof newOptions.awaitdata === "boolean") {
        newOptions.awaitData = newOptions.awaitdata;
      }
      if (typeof newOptions.timeout === "boolean")
        newOptions.noCursorTimeout = !newOptions.timeout;
      decorateCommand(findCommand, newOptions, ["session", "collation"]);
      if (projection)
        findCommand.fields = projection;
      newOptions.db = this.s.db;
      newOptions.promiseLibrary = this.s.promiseLibrary;
      if (newOptions.raw == null && typeof this.s.raw === "boolean")
        newOptions.raw = this.s.raw;
      if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === "boolean")
        newOptions.promoteLongs = this.s.promoteLongs;
      if (newOptions.promoteValues == null && typeof this.s.promoteValues === "boolean")
        newOptions.promoteValues = this.s.promoteValues;
      if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === "boolean")
        newOptions.promoteBuffers = this.s.promoteBuffers;
      if (findCommand.sort) {
        findCommand.sort = formattedOrderClause(findCommand.sort);
      }
      decorateWithReadConcern(findCommand, this, options2);
      try {
        decorateWithCollation(findCommand, this, options2);
      } catch (err) {
        if (typeof callback === "function")
          return callback(err, null);
        throw err;
      }
      const cursor = this.s.topology.cursor(new FindOperation(this, this.s.namespace, findCommand, newOptions), newOptions);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    });
    Collection.prototype.insertOne = function(doc, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const insertOneOperation = new InsertOneOperation(this, doc, options2);
      return executeOperation(this.s.topology, insertOneOperation, callback);
    };
    Collection.prototype.insertMany = function(docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {ordered: true};
      const insertManyOperation = new InsertManyOperation(this, docs, options2);
      return executeOperation(this.s.topology, insertManyOperation, callback);
    };
    Collection.prototype.bulkWrite = function(operations, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {ordered: true};
      if (!Array.isArray(operations)) {
        throw MongoError.create({message: "operations must be an array of documents", driver: true});
      }
      const bulkWriteOperation = new BulkWriteOperation(this, operations, options2);
      return executeOperation(this.s.topology, bulkWriteOperation, callback);
    };
    Collection.prototype.insert = deprecate(function(docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {ordered: false};
      docs = !Array.isArray(docs) ? [docs] : docs;
      if (options2.keepGoing === true) {
        options2.ordered = false;
      }
      return this.insertMany(docs, options2, callback);
    }, "collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.");
    Collection.prototype.updateOne = function(filter, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateOneOperation(this, filter, update, options2), callback);
    };
    Collection.prototype.replaceOne = function(filter, doc, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new ReplaceOneOperation(this, filter, doc, options2), callback);
    };
    Collection.prototype.updateMany = function(filter, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateManyOperation(this, filter, update, options2), callback);
    };
    Collection.prototype.update = deprecate(function(selector, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, updateDocuments, [
        this,
        selector,
        update,
        options2,
        callback
      ]);
    }, "collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.");
    Collection.prototype.deleteOne = function(filter, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteOneOperation = new DeleteOneOperation(this, filter, options2);
      return executeOperation(this.s.topology, deleteOneOperation, callback);
    };
    Collection.prototype.removeOne = Collection.prototype.deleteOne;
    Collection.prototype.deleteMany = function(filter, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteManyOperation = new DeleteManyOperation(this, filter, options2);
      return executeOperation(this.s.topology, deleteManyOperation, callback);
    };
    Collection.prototype.removeMany = Collection.prototype.deleteMany;
    Collection.prototype.remove = deprecate(function(selector, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, removeDocuments, [
        this,
        selector,
        options2,
        callback
      ]);
    }, "collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.");
    Collection.prototype.save = deprecate(function(doc, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, save, [this, doc, options2, callback]);
    }, "collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.");
    Collection.prototype.findOne = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options2, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `findOne()` must be a callback or undefined");
      }
      if (typeof query === "function")
        callback = query, query = {}, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      query = query || {};
      options2 = options2 || {};
      const findOneOperation = new FindOneOperation(this, query, options2);
      return executeOperation(this.s.topology, findOneOperation, callback);
    });
    Collection.prototype.rename = function(newName, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2, {readPreference: ReadPreference.PRIMARY});
      const renameOperation = new RenameOperation(this, newName, options2);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Collection.prototype.drop = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropCollectionOperation = new DropCollectionOperation(this.s.db, this.collectionName, options2);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Collection.prototype.options = function(opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      opts = opts || {};
      const optionsOperation = new OptionsOperation(this, opts);
      return executeOperation(this.s.topology, optionsOperation, callback);
    };
    Collection.prototype.isCapped = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const isCappedOperation = new IsCappedOperation(this, options2);
      return executeOperation(this.s.topology, isCappedOperation, callback);
    };
    Collection.prototype.createIndex = function(fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, fieldOrSpec, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.createIndexes = function(indexSpecs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      if (typeof options2.maxTimeMS !== "number")
        delete options2.maxTimeMS;
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, indexSpecs, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.dropIndex = function(indexName, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      options2.readPreference = ReadPreference.PRIMARY;
      const dropIndexOperation = new DropIndexOperation(this, indexName, options2);
      return executeOperation(this.s.topology, dropIndexOperation, callback);
    };
    Collection.prototype.dropIndexes = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      if (typeof options2.maxTimeMS !== "number")
        delete options2.maxTimeMS;
      const dropIndexesOperation = new DropIndexesOperation(this, options2);
      return executeOperation(this.s.topology, dropIndexesOperation, callback);
    };
    Collection.prototype.dropAllIndexes = deprecate(Collection.prototype.dropIndexes, "collection.dropAllIndexes is deprecated. Use dropIndexes instead.");
    Collection.prototype.reIndex = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const reIndexOperation = new ReIndexOperation(this, options2);
      return executeOperation(this.s.topology, reIndexOperation, callback);
    }, "collection.reIndex is deprecated. Use db.command instead.");
    Collection.prototype.listIndexes = function(options2) {
      const cursor = new CommandCursor(this.s.topology, new ListIndexesOperation(this, options2), options2);
      return cursor;
    };
    Collection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        fieldOrSpec,
        options2,
        callback
      ]);
    }, "collection.ensureIndex is deprecated. Use createIndexes instead.");
    Collection.prototype.indexExists = function(indexes, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexExistsOperation = new IndexExistsOperation(this, indexes, options2);
      return executeOperation(this.s.topology, indexExistsOperation, callback);
    };
    Collection.prototype.indexInformation = function(options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const indexInformationOperation = new IndexInformationOperation(this.s.db, this.collectionName, options2);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Collection.prototype.count = deprecate(function(query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options2 = args.length ? args.shift() || {} : {};
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeOperation(this.s.topology, new EstimatedDocumentCountOperation(this, query, options2), callback);
    }, "collection.count is deprecated, and will be removed in a future version. Use Collection.countDocuments or Collection.estimatedDocumentCount instead");
    Collection.prototype.estimatedDocumentCount = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options2);
      return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);
    };
    Collection.prototype.countDocuments = function(query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options2 = args.length ? args.shift() || {} : {};
      const countDocumentsOperation = new CountDocumentsOperation(this, query, options2);
      return executeOperation(this.s.topology, countDocumentsOperation, callback);
    };
    Collection.prototype.distinct = function(key, query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      const queryOption = args.length ? args.shift() || {} : {};
      const optionsOption = args.length ? args.shift() || {} : {};
      const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);
      return executeOperation(this.s.topology, distinctOperation, callback);
    };
    Collection.prototype.indexes = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexesOperation = new IndexesOperation(this, options2);
      return executeOperation(this.s.topology, indexesOperation, callback);
    };
    Collection.prototype.stats = function(options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const statsOperation = new StatsOperation(this, options2);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Collection.prototype.findOneAndDelete = function(filter, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndDeleteOperation(this, filter, options2), callback);
    };
    Collection.prototype.findOneAndReplace = deprecateOptions({
      name: "collection.findOneAndReplace",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter, replacement, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndReplaceOperation(this, filter, replacement, options2), callback);
    });
    Collection.prototype.findOneAndUpdate = deprecateOptions({
      name: "collection.findOneAndUpdate",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndUpdateOperation(this, filter, update, options2), callback);
    });
    Collection.prototype.findAndModify = deprecate(_findAndModify, "collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.");
    Collection.prototype._findAndModify = _findAndModify;
    function _findAndModify(query, sort, doc, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      doc = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() || {} : {};
      options2 = Object.assign({}, options2);
      options2.readPreference = ReadPreference.PRIMARY;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, doc, options2), callback);
    }
    Collection.prototype.findAndRemove = deprecate(function(query, sort, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      options2 = args.length ? args.shift() || {} : {};
      options2.remove = true;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, null, options2), callback);
    }, "collection.findAndRemove is deprecated. Use findOneAndDelete instead.");
    Collection.prototype.aggregate = function(pipeline2, options2, callback) {
      if (Array.isArray(pipeline2)) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        if (options2 == null && callback == null) {
          options2 = {};
        }
      } else {
        const args = Array.prototype.slice.call(arguments, 0);
        callback = args.pop();
        const opts = args[args.length - 1];
        options2 = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.hint || opts.allowDiskUse) ? args.pop() : {};
        pipeline2 = args;
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline2, options2), options2);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Collection.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    Collection.prototype.parallelCollectionScan = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {numCursors: 1};
      options2.numCursors = options2.numCursors || 1;
      options2.batchSize = options2.batchSize || 1e3;
      options2 = Object.assign({}, options2);
      options2.readPreference = ReadPreference.resolve(this, options2);
      options2.promiseLibrary = this.s.promiseLibrary;
      if (options2.session) {
        options2.session = void 0;
      }
      return executeLegacyOperation(this.s.topology, parallelCollectionScan, [this, options2, callback], {skipSessions: true});
    }, "parallelCollectionScan is deprecated in MongoDB v4.1");
    Collection.prototype.geoHaystackSearch = deprecate(function(x, y, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y, options2);
      return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);
    }, "geoHaystackSearch is deprecated, and will be removed in a future version.");
    Collection.prototype.group = deprecate(function(keys, condition, initial, reduce, finalize, command, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 3);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      reduce = args.length ? args.shift() : null;
      finalize = args.length ? args.shift() : null;
      command = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() || {} : {};
      if (!(typeof finalize === "function")) {
        command = finalize;
        finalize = null;
      }
      if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== "function" && !(keys._bsontype === "Code")) {
        keys = Object.keys(keys);
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof finalize === "function") {
        finalize = finalize.toString();
      }
      command = command == null ? true : command;
      return executeLegacyOperation(this.s.topology, group, [
        this,
        keys,
        condition,
        initial,
        reduce,
        finalize,
        command,
        options2,
        callback
      ]);
    }, "MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.");
    Collection.prototype.mapReduce = function(map, reduce, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      if (options2.out == null) {
        throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
      }
      if (typeof map === "function") {
        map = map.toString();
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof options2.finalize === "function") {
        options2.finalize = options2.finalize.toString();
      }
      const mapReduceOperation = new MapReduceOperation(this, map, reduce, options2);
      return executeOperation(this.s.topology, mapReduceOperation, callback);
    };
    Collection.prototype.initializeUnorderedBulkOp = function(options2) {
      options2 = options2 || {};
      if (options2.ignoreUndefined == null) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options2.promiseLibrary = this.s.promiseLibrary;
      return unordered(this.s.topology, this, options2);
    };
    Collection.prototype.initializeOrderedBulkOp = function(options2) {
      options2 = options2 || {};
      if (options2.ignoreUndefined == null) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options2.promiseLibrary = this.s.promiseLibrary;
      return ordered(this.s.topology, this, options2);
    };
    Collection.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    module2.exports = Collection;
  }
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS({
  "node_modules/mongodb/lib/change_stream.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events");
    var isResumableError = require_error2().isResumableError;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var relayEvents = require_utils2().relayEvents;
    var maxWireVersion = require_utils2().maxWireVersion;
    var maybePromise = require_utils4().maybePromise;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var AggregateOperation = require_aggregate();
    var kResumeQueue = Symbol("resumeQueue");
    var CHANGE_STREAM_OPTIONS = ["resumeAfter", "startAfter", "startAtOperationTime", "fullDocument"];
    var CURSOR_OPTIONS = ["batchSize", "maxAwaitTimeMS", "collation", "readPreference"].concat(CHANGE_STREAM_OPTIONS);
    var CHANGE_DOMAIN_TYPES = {
      COLLECTION: Symbol("Collection"),
      DATABASE: Symbol("Database"),
      CLUSTER: Symbol("Cluster")
    };
    var ChangeStream = class extends EventEmitter {
      constructor(parent, pipeline2, options2) {
        super();
        const Collection = require_collection();
        const Db = require_db();
        const MongoClient2 = require_mongo_client();
        this.pipeline = pipeline2 || [];
        this.options = options2 || {};
        this.parent = parent;
        this.namespace = parent.s.namespace;
        if (parent instanceof Collection) {
          this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
          this.topology = parent.s.db.serverConfig;
        } else if (parent instanceof Db) {
          this.type = CHANGE_DOMAIN_TYPES.DATABASE;
          this.topology = parent.serverConfig;
        } else if (parent instanceof MongoClient2) {
          this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
          this.topology = parent.topology;
        } else {
          throw new TypeError("parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient");
        }
        this.promiseLibrary = parent.s.promiseLibrary;
        if (!this.options.readPreference && parent.s.readPreference) {
          this.options.readPreference = parent.s.readPreference;
        }
        this[kResumeQueue] = new Denque();
        this.cursor = createChangeStreamCursor(this, options2);
        this.closed = false;
        this.on("newListener", (eventName) => {
          if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
            this.cursor.on("data", (change) => processNewChange(this, change));
          }
        });
        this.on("removeListener", (eventName) => {
          if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
            this.cursor.removeAllListeners("data");
          }
        });
      }
      get resumeToken() {
        return this.cursor.resumeToken;
      }
      hasNext(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.hasNext(cb);
          });
        });
      }
      next(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.next((error3, change) => {
              if (error3) {
                this[kResumeQueue].push(() => this.next(cb));
                processError(this, error3, cb);
                return;
              }
              processNewChange(this, change, cb);
            });
          });
        });
      }
      isClosed() {
        return this.closed || this.cursor && this.cursor.isClosed();
      }
      close(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          if (this.closed)
            return cb();
          this.closed = true;
          if (!this.cursor)
            return cb();
          const cursor = this.cursor;
          return cursor.close((err) => {
            ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
            this.cursor = void 0;
            return cb(err);
          });
        });
      }
      pipe(destination, options2) {
        if (!this.pipeDestinations) {
          this.pipeDestinations = [];
        }
        this.pipeDestinations.push(destination);
        return this.cursor.pipe(destination, options2);
      }
      unpipe(destination) {
        if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {
          this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
        }
        return this.cursor.unpipe(destination);
      }
      stream(options2) {
        this.streamOptions = options2;
        return this.cursor.stream(options2);
      }
      pause() {
        return this.cursor.pause();
      }
      resume() {
        return this.cursor.resume();
      }
    };
    var ChangeStreamCursor = class extends Cursor {
      constructor(topology, operation, options2) {
        super(topology, operation, options2);
        options2 = options2 || {};
        this._resumeToken = null;
        this.startAtOperationTime = options2.startAtOperationTime;
        if (options2.startAfter) {
          this.resumeToken = options2.startAfter;
        } else if (options2.resumeAfter) {
          this.resumeToken = options2.resumeAfter;
        }
      }
      set resumeToken(token) {
        this._resumeToken = token;
        this.emit("resumeTokenChanged", token);
      }
      get resumeToken() {
        return this._resumeToken;
      }
      get resumeOptions() {
        const result = {};
        for (const optionName of CURSOR_OPTIONS) {
          if (this.options[optionName])
            result[optionName] = this.options[optionName];
        }
        if (this.resumeToken || this.startAtOperationTime) {
          ["resumeAfter", "startAfter", "startAtOperationTime"].forEach((key) => delete result[key]);
          if (this.resumeToken) {
            const resumeKey = this.options.startAfter && !this.hasReceived ? "startAfter" : "resumeAfter";
            result[resumeKey] = this.resumeToken;
          } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {
            result.startAtOperationTime = this.startAtOperationTime;
          }
        }
        return result;
      }
      cacheResumeToken(resumeToken) {
        if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {
          this.resumeToken = this.cursorState.postBatchResumeToken;
        } else {
          this.resumeToken = resumeToken;
        }
        this.hasReceived = true;
      }
      _processBatch(batchName, response) {
        const cursor = response.cursor;
        if (cursor.postBatchResumeToken) {
          this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;
          if (cursor[batchName].length === 0) {
            this.resumeToken = cursor.postBatchResumeToken;
          }
        }
      }
      _initializeCursor(callback) {
        super._initializeCursor((err, result) => {
          if (err || result == null) {
            callback(err, result);
            return;
          }
          const response = result.documents[0];
          if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {
            this.startAtOperationTime = response.operationTime;
          }
          this._processBatch("firstBatch", response);
          this.emit("init", result);
          this.emit("response");
          callback(err, result);
        });
      }
      _getMore(callback) {
        super._getMore((err, response) => {
          if (err) {
            callback(err);
            return;
          }
          this._processBatch("nextBatch", response);
          this.emit("more", response);
          this.emit("response");
          callback(err, response);
        });
      }
    };
    function createChangeStreamCursor(self, options2) {
      const changeStreamStageOptions = {fullDocument: options2.fullDocument || "default"};
      applyKnownOptions(changeStreamStageOptions, options2, CHANGE_STREAM_OPTIONS);
      if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline2 = [{$changeStream: changeStreamStageOptions}].concat(self.pipeline);
      const cursorOptions = applyKnownOptions({}, options2, CURSOR_OPTIONS);
      const changeStreamCursor = new ChangeStreamCursor(self.topology, new AggregateOperation(self.parent, pipeline2, options2), cursorOptions);
      relayEvents(changeStreamCursor, self, ["resumeTokenChanged", "end", "close"]);
      if (self.listenerCount("change") > 0) {
        changeStreamCursor.on("data", function(change) {
          processNewChange(self, change);
        });
      }
      changeStreamCursor.on("error", function(error3) {
        processError(self, error3);
      });
      if (self.pipeDestinations) {
        const cursorStream = changeStreamCursor.stream(self.streamOptions);
        for (let pipeDestination of self.pipeDestinations) {
          cursorStream.pipe(pipeDestination);
        }
      }
      return changeStreamCursor;
    }
    function applyKnownOptions(target, source, optionNames) {
      optionNames.forEach((name) => {
        if (source[name]) {
          target[name] = source[name];
        }
      });
      return target;
    }
    var SELECTION_TIMEOUT = 3e4;
    function waitForTopologyConnected(topology, options2, callback) {
      setTimeout(() => {
        if (options2 && options2.start == null) {
          options2.start = now();
        }
        const start = options2.start || now();
        const timeout = options2.timeout || SELECTION_TIMEOUT;
        const readPreference = options2.readPreference;
        if (topology.isConnected({readPreference})) {
          return callback();
        }
        if (calculateDurationInMs(start) > timeout) {
          return callback(new MongoError("Timed out waiting for connection"));
        }
        waitForTopologyConnected(topology, options2, callback);
      }, 500);
    }
    function processNewChange(changeStream, change, callback) {
      const cursor = changeStream.cursor;
      if (change == null) {
        changeStream.closed = true;
      }
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      if (change && !change._id) {
        const noResumeTokenError = new Error("A change stream document has been received that lacks a resume token (_id).");
        if (!callback)
          return changeStream.emit("error", noResumeTokenError);
        return callback(noResumeTokenError);
      }
      cursor.cacheResumeToken(change._id);
      changeStream.options.startAtOperationTime = void 0;
      if (!callback)
        return changeStream.emit("change", change);
      return callback(void 0, change);
    }
    function processError(changeStream, error3, callback) {
      const topology = changeStream.topology;
      const cursor = changeStream.cursor;
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      function resumeWithCursor(newCursor) {
        changeStream.cursor = newCursor;
        processResumeQueue(changeStream);
      }
      function unresumableError(err) {
        if (!callback) {
          changeStream.emit("error", err);
          changeStream.emit("close");
        }
        processResumeQueue(changeStream, err);
        changeStream.closed = true;
      }
      if (cursor && isResumableError(error3, maxWireVersion(cursor.server))) {
        changeStream.cursor = void 0;
        ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
        cursor.close();
        waitForTopologyConnected(topology, {readPreference: cursor.options.readPreference}, (err) => {
          if (err)
            return unresumableError(err);
          const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);
          if (!callback)
            return resumeWithCursor(newCursor);
          newCursor.hasNext((err2) => {
            if (err2)
              return unresumableError(err2);
            resumeWithCursor(newCursor);
          });
        });
        return;
      }
      if (!callback)
        return changeStream.emit("error", error3);
      return callback(error3);
    }
    function getCursor(changeStream, callback) {
      if (changeStream.isClosed()) {
        callback(new MongoError("ChangeStream is closed."));
        return;
      }
      if (changeStream.cursor) {
        callback(void 0, changeStream.cursor);
        return;
      }
      changeStream[kResumeQueue].push(callback);
    }
    function processResumeQueue(changeStream, err) {
      while (changeStream[kResumeQueue].length) {
        const request = changeStream[kResumeQueue].pop();
        if (changeStream.isClosed() && !err) {
          request(new MongoError("Change Stream is not open."));
          return;
        }
        request(err, changeStream.cursor);
      }
    }
    module2.exports = ChangeStream;
  }
});

// node_modules/mongodb/lib/topologies/topology_base.js
var require_topology_base = __commonJS({
  "node_modules/mongodb/lib/topologies/topology_base.js"(exports2) {
    "use strict";
    var EventEmitter = require("events");
    var MongoError = require_core().MongoError;
    var f = require("util").format;
    var ReadPreference = require_core().ReadPreference;
    var ClientSession = require_core().Sessions.ClientSession;
    var Store = function(topology, storeOptions) {
      var self = this;
      var storedOps = [];
      storeOptions = storeOptions || {force: false, bufferMaxEntries: -1};
      this.s = {
        storedOps,
        storeOptions,
        topology
      };
      Object.defineProperty(this, "length", {
        enumerable: true,
        get: function() {
          return self.s.storedOps.length;
        }
      });
    };
    Store.prototype.add = function(opType, ns, ops, options2, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({message: "db closed by application", driver: true}));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({t: opType, n: ns, o: ops, op: options2, c: callback});
    };
    Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({message: "db closed by application", driver: true}));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({t: opType, m: method, o: object, p: params, c: callback});
    };
    Store.prototype.flush = function(err) {
      while (this.s.storedOps.length > 0) {
        this.s.storedOps.shift().c(err || MongoError.create({message: f("no connection available for operation"), driver: true}));
      }
    };
    var primaryOptions = ["primary", "primaryPreferred", "nearest", "secondaryPreferred"];
    var secondaryOptions = ["secondary", "secondaryPreferred"];
    Store.prototype.execute = function(options2) {
      options2 = options2 || {};
      var ops = this.s.storedOps;
      this.s.storedOps = [];
      var executePrimary = typeof options2.executePrimary === "boolean" ? options2.executePrimary : true;
      var executeSecondary = typeof options2.executeSecondary === "boolean" ? options2.executeSecondary : true;
      while (ops.length > 0) {
        var op = ops.shift();
        if (op.t === "cursor") {
          if (executePrimary && executeSecondary) {
            op.o[op.m].apply(op.o, op.p);
          } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          }
        } else if (op.t === "auth") {
          this.s.topology[op.t].apply(this.s.topology, op.o);
        } else {
          if (executePrimary && executeSecondary) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          }
        }
      }
    };
    Store.prototype.all = function() {
      return this.s.storedOps;
    };
    var ServerCapabilities = function(ismaster) {
      var setup_get_property = function(object, name, value) {
        Object.defineProperty(object, name, {
          enumerable: true,
          get: function() {
            return value;
          }
        });
      };
      var aggregationCursor = false;
      var writeCommands = false;
      var textSearch = false;
      var authCommands = false;
      var listCollections = false;
      var listIndexes = false;
      var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1e3;
      var commandsTakeWriteConcern = false;
      var commandsTakeCollation = false;
      if (ismaster.minWireVersion >= 0) {
        textSearch = true;
      }
      if (ismaster.maxWireVersion >= 1) {
        aggregationCursor = true;
        authCommands = true;
      }
      if (ismaster.maxWireVersion >= 2) {
        writeCommands = true;
      }
      if (ismaster.maxWireVersion >= 3) {
        listCollections = true;
        listIndexes = true;
      }
      if (ismaster.maxWireVersion >= 5) {
        commandsTakeWriteConcern = true;
        commandsTakeCollation = true;
      }
      if (ismaster.minWireVersion == null) {
        ismaster.minWireVersion = 0;
      }
      if (ismaster.maxWireVersion == null) {
        ismaster.maxWireVersion = 0;
      }
      setup_get_property(this, "hasAggregationCursor", aggregationCursor);
      setup_get_property(this, "hasWriteCommands", writeCommands);
      setup_get_property(this, "hasTextSearch", textSearch);
      setup_get_property(this, "hasAuthCommands", authCommands);
      setup_get_property(this, "hasListCollectionsCommand", listCollections);
      setup_get_property(this, "hasListIndexesCommand", listIndexes);
      setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
      setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
      setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
      setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
      setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
    };
    var TopologyBase = class extends EventEmitter {
      constructor() {
        super();
        this.setMaxListeners(Infinity);
      }
      hasSessionSupport() {
        return this.logicalSessionTimeoutMinutes != null;
      }
      startSession(options2, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options2, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        return this.s.coreTopology.endSessions(sessions, callback);
      }
      get clientMetadata() {
        return this.s.coreTopology.s.options.metadata;
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.s.coreTopology.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd, options2, callback) {
        this.s.coreTopology.command(ns.toString(), cmd, ReadPreference.translate(options2), callback);
      }
      insert(ns, ops, options2, callback) {
        this.s.coreTopology.insert(ns.toString(), ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        this.s.coreTopology.update(ns.toString(), ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        this.s.coreTopology.remove(ns.toString(), ops, options2, callback);
      }
      isConnected(options2) {
        options2 = options2 || {};
        options2 = ReadPreference.translate(options2);
        return this.s.coreTopology.isConnected(options2);
      }
      isDestroyed() {
        return this.s.coreTopology.isDestroyed();
      }
      cursor(ns, cmd, options2) {
        options2 = options2 || {};
        options2 = ReadPreference.translate(options2);
        options2.disconnectHandler = this.s.store;
        options2.topology = this;
        return this.s.coreTopology.cursor(ns, cmd, options2);
      }
      lastIsMaster() {
        return this.s.coreTopology.lastIsMaster();
      }
      selectServer(selector, options2, callback) {
        return this.s.coreTopology.selectServer(selector, options2, callback);
      }
      unref() {
        return this.s.coreTopology.unref();
      }
      connections() {
        return this.s.coreTopology.connections();
      }
      close(forceClosed, callback) {
        this.s.sessions.forEach((session) => session.endSession());
        if (this.s.sessionPool) {
          this.s.sessionPool.endAllPooledSessions();
        }
        if (forceClosed === true) {
          this.s.storeOptions.force = forceClosed;
          this.s.store.flush();
        }
        this.s.coreTopology.destroy({
          force: typeof forceClosed === "boolean" ? forceClosed : false
        }, callback);
      }
    };
    Object.defineProperty(TopologyBase.prototype, "bson", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.bson;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.parserType;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.logicalSessionTimeoutMinutes;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "type", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.type;
      }
    });
    exports2.Store = Store;
    exports2.ServerCapabilities = ServerCapabilities;
    exports2.TopologyBase = TopologyBase;
  }
});

// node_modules/mongodb/lib/topologies/native_topology.js
var require_native_topology = __commonJS({
  "node_modules/mongodb/lib/topologies/native_topology.js"(exports2, module2) {
    "use strict";
    var Topology = require_core().Topology;
    var ServerCapabilities = require_topology_base().ServerCapabilities;
    var Cursor = require_cursor2();
    var translateOptions = require_utils4().translateOptions;
    var NativeTopology = class extends Topology {
      constructor(servers, options2) {
        options2 = options2 || {};
        let clonedOptions = Object.assign({}, {
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          maxPoolSize: typeof options2.maxPoolSize === "number" ? options2.maxPoolSize : typeof options2.poolSize === "number" ? options2.poolSize : 10,
          minPoolSize: typeof options2.minPoolSize === "number" ? options2.minPoolSize : typeof options2.minSize === "number" ? options2.minSize : 0,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        super(servers, clonedOptions);
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd, options2, callback) {
        super.command(ns.toString(), cmd, options2, callback);
      }
      insert(ns, ops, options2, callback) {
        super.insert(ns.toString(), ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        super.update(ns.toString(), ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        super.remove(ns.toString(), ops, options2, callback);
      }
    };
    module2.exports = NativeTopology;
  }
});

// node_modules/mongodb/lib/topologies/server.js
var require_server3 = __commonJS({
  "node_modules/mongodb/lib/topologies/server.js"(exports2, module2) {
    "use strict";
    var CServer = require_core().Server;
    var Cursor = require_cursor2();
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var MongoError = require_core().MongoError;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "reconnectInterval",
      "monitoring",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "compression",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Server = class extends TopologyBase {
      constructor(host, port, options2) {
        super();
        var self = this;
        options2 = filterOptions(options2, legalOptionNames);
        const promiseLibrary = options2.promiseLibrary;
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self, storeOptions);
        if (host.indexOf("/") !== -1) {
          if (port != null && typeof port === "object") {
            options2 = port;
            port = null;
          }
        } else if (port == null) {
          throw MongoError.create({message: "port must be specified", driver: true});
        }
        var reconnect = typeof options2.auto_reconnect === "boolean" ? options2.auto_reconnect : true;
        reconnect = typeof options2.autoReconnect === "boolean" ? options2.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          host,
          port,
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CServer(clonedOptions),
          sCapabilities: null,
          clonedOptions,
          reconnect: clonedOptions.reconnect,
          emitError: clonedOptions.emitError,
          poolSize: clonedOptions.size,
          storeOptions,
          store,
          host,
          port,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = this.s.clonedOptions;
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self.s.options = _options;
        self.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events = ["timeout", "error", "close"];
            events.forEach(function(e) {
              self.s.coreTopology.removeListener(e, connectHandlers[e]);
            });
            self.s.coreTopology.removeListener("connect", connectErrorHandler);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self.emit("reconnect", self);
          self.s.store.execute();
        };
        var reconnectFailedHandler = function(err) {
          self.emit("reconnectFailed", err);
          self.s.store.flush(err);
        };
        var destroyHandler = function() {
          self.s.store.flush();
        };
        var relay = function(event) {
          return function(t, server) {
            self.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          ["timeout", "error", "close", "destroy"].forEach(function(e) {
            self.s.coreTopology.removeAllListeners(e);
          });
          self.s.coreTopology.on("timeout", errorHandler("timeout"));
          self.s.coreTopology.once("error", errorHandler("error"));
          self.s.coreTopology.on("close", errorHandler("close"));
          self.s.coreTopology.on("destroy", destroyHandler);
          self.emit("open", null, self);
          try {
            callback(null, self);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectHandlers = {
          timeout: connectErrorHandler("timeout"),
          error: connectErrorHandler("error"),
          close: connectErrorHandler("close")
        };
        [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ].forEach(function(e) {
          self.s.coreTopology.removeAllListeners(e);
        });
        self.s.coreTopology.once("timeout", connectHandlers.timeout);
        self.s.coreTopology.once("error", connectHandlers.error);
        self.s.coreTopology.once("close", connectHandlers.close);
        self.s.coreTopology.once("connect", connectHandler);
        self.s.coreTopology.on("reconnect", reconnectHandler);
        self.s.coreTopology.on("reconnectFailed", reconnectFailedHandler);
        self.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self.s.coreTopology.on("attemptReconnect", relay("attemptReconnect"));
        self.s.coreTopology.on("monitoring", relay("monitoring"));
        self.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Server.prototype, "poolSize", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.connections().length;
      }
    });
    Object.defineProperty(Server.prototype, "autoReconnect", {
      enumerable: true,
      get: function() {
        return this.s.reconnect;
      }
    });
    Object.defineProperty(Server.prototype, "host", {
      enumerable: true,
      get: function() {
        return this.s.host;
      }
    });
    Object.defineProperty(Server.prototype, "port", {
      enumerable: true,
      get: function() {
        return this.s.port;
      }
    });
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/topologies/mongos.js
var require_mongos2 = __commonJS({
  "node_modules/mongodb/lib/topologies/mongos.js"(exports2, module2) {
    "use strict";
    var TopologyBase = require_topology_base().TopologyBase;
    var MongoError = require_core().MongoError;
    var CMongos = require_core().Mongos;
    var Cursor = require_cursor2();
    var Server = require_server3();
    var Store = require_topology_base().Store;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Mongos = class extends TopologyBase {
      constructor(servers, options2) {
        super();
        options2 = options2 || {};
        var self = this;
        options2 = filterOptions(options2, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self, storeOptions);
        var seedlist = servers.map(function(x) {
          return {host: x.host, port: x.port};
        });
        var reconnect = typeof options2.auto_reconnect === "boolean" ? options2.auto_reconnect : true;
        reconnect = typeof options2.autoReconnect === "boolean" ? options2.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CMongos(seedlist, clonedOptions),
          sCapabilities: null,
          debug: clonedOptions.debug,
          storeOptions,
          clonedOptions,
          store,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self.s.options = _options;
        self.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events2 = ["timeout", "error", "close"];
            events2.forEach(function(e) {
              self.removeListener(e, connectErrorHandler);
            });
            self.s.coreTopology.removeListener("connect", connectErrorHandler);
            self.close(true);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self.emit("reconnect");
          self.s.store.execute();
        };
        var relay = function(event) {
          return function(t, server) {
            self.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          var events2 = ["timeout", "error", "close", "fullsetup"];
          events2.forEach(function(e) {
            self.s.coreTopology.removeAllListeners(e);
          });
          self.s.coreTopology.on("timeout", errorHandler("timeout"));
          self.s.coreTopology.on("error", errorHandler("error"));
          self.s.coreTopology.on("close", errorHandler("close"));
          self.s.coreTopology.on("fullsetup", function() {
            self.emit("fullsetup", self);
          });
          self.emit("open", null, self);
          try {
            callback(null, self);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ];
        events.forEach(function(e) {
          self.s.coreTopology.removeAllListeners(e);
        });
        self.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self.s.coreTopology.once("error", connectErrorHandler("error"));
        self.s.coreTopology.once("close", connectErrorHandler("close"));
        self.s.coreTopology.once("connect", connectHandler);
        self.s.coreTopology.on("joined", relay("joined"));
        self.s.coreTopology.on("left", relay("left"));
        self.s.coreTopology.on("reconnect", reconnectHandler);
        self.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Mongos.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = Mongos;
  }
});

// node_modules/mongodb/lib/topologies/replset.js
var require_replset2 = __commonJS({
  "node_modules/mongodb/lib/topologies/replset.js"(exports2, module2) {
    "use strict";
    var Server = require_server3();
    var Cursor = require_cursor2();
    var MongoError = require_core().MongoError;
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var CReplSet = require_core().ReplSet;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "replicaSet",
      "rs_name",
      "secondaryAcceptableLatencyMS",
      "connectWithNoPrimary",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslCRL",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "strategy",
      "debug",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "maxStalenessSeconds",
      "promiseLibrary",
      "minSize",
      "monitorCommands"
    ];
    var ReplSet = class extends TopologyBase {
      constructor(servers, options2) {
        super();
        options2 = options2 || {};
        var self = this;
        options2 = filterOptions(options2, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self, storeOptions);
        var seedlist = servers.map(function(x) {
          return {host: x.host, port: x.port};
        });
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        var coreTopology = new CReplSet(seedlist, clonedOptions);
        coreTopology.on("reconnect", function() {
          self.emit("reconnect");
          store.execute();
        });
        this.s = {
          coreTopology,
          sCapabilities: null,
          tag: options2.tag,
          storeOptions,
          clonedOptions,
          store,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise
        };
        if (clonedOptions.debug) {
          Object.defineProperty(this, "replset", {
            enumerable: true,
            get: function() {
              return coreTopology;
            }
          });
        }
      }
      connect(_options, callback) {
        var self = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self.s.options = _options;
        self.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self.emit(event, err);
            }
          };
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed",
          "joined",
          "left",
          "ping",
          "ha"
        ];
        events.forEach(function(e) {
          self.s.coreTopology.removeAllListeners(e);
        });
        var relay = function(event) {
          return function(t, server) {
            self.emit(event, t, server);
          };
        };
        var replsetRelay = function(event) {
          return function(t, server) {
            self.emit(event, t, server.lastIsMaster(), server);
          };
        };
        var relayHa = function(t, state) {
          self.emit("ha", t, state);
          if (t === "start") {
            self.emit("ha_connect", t, state);
          } else if (t === "end") {
            self.emit("ha_ismaster", t, state);
          }
        };
        self.s.coreTopology.on("joined", replsetRelay("joined"));
        self.s.coreTopology.on("left", relay("left"));
        self.s.coreTopology.on("ping", relay("ping"));
        self.s.coreTopology.on("ha", relayHa);
        self.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self.s.coreTopology.on("fullsetup", function() {
          self.emit("fullsetup", self, self);
        });
        self.s.coreTopology.on("all", function() {
          self.emit("all", null, self);
        });
        var connectHandler = function() {
          self.s.coreTopology.once("timeout", errorHandler("timeout"));
          self.s.coreTopology.once("error", errorHandler("error"));
          self.s.coreTopology.once("close", errorHandler("close"));
          self.emit("open", null, self);
          try {
            callback(null, self);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectErrorHandler = function() {
          return function(err) {
            ["timeout", "error", "close"].forEach(function(e) {
              self.s.coreTopology.removeListener(e, connectErrorHandler);
            });
            self.s.coreTopology.removeListener("connect", connectErrorHandler);
            self.s.coreTopology.destroy();
            try {
              callback(err);
            } catch (err2) {
              if (!self.s.coreTopology.isConnected())
                process.nextTick(function() {
                  throw err2;
                });
            }
          };
        };
        self.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self.s.coreTopology.once("error", connectErrorHandler("error"));
        self.s.coreTopology.once("close", connectErrorHandler("close"));
        self.s.coreTopology.once("connect", connectHandler);
        self.s.coreTopology.connect(_options);
      }
      close(forceClosed, callback) {
        ["timeout", "error", "close", "joined", "left"].forEach((e) => this.removeAllListeners(e));
        super.close(forceClosed, callback);
      }
    };
    Object.defineProperty(ReplSet.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/url_parser.js
var require_url_parser = __commonJS({
  "node_modules/mongodb/lib/url_parser.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var parser = require("url");
    var f = require("util").format;
    var Logger = require_core().Logger;
    var dns = require("dns");
    var ReadConcern = require_read_concern();
    var qs = require("querystring");
    var MongoParseError = require_error().MongoParseError;
    module2.exports = function(url, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      let result;
      try {
        result = parser.parse(url, true);
      } catch (e) {
        return callback(new Error("URL malformed, cannot be parsed"));
      }
      if (result.protocol !== "mongodb:" && result.protocol !== "mongodb+srv:") {
        return callback(new Error("Invalid schema, expected `mongodb` or `mongodb+srv`"));
      }
      if (result.protocol === "mongodb:") {
        return parseHandler(url, options2, callback);
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new Error("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = url.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new Error("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new Error("Ports not accepted with `mongodb+srv` URIs"));
      }
      let srvAddress = `_mongodb._tcp.${result.host}`;
      dns.resolveSrv(srvAddress, function(err, addresses) {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new Error("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new Error("Server record does not share hostname with parent URI"));
          }
        }
        let base = result.auth ? `mongodb://${result.auth}@` : `mongodb://`;
        let connectionStrings = addresses.map(function(address, i) {
          if (i === 0)
            return `${base}${address.name}:${address.port}`;
          else
            return `${address.name}:${address.port}`;
        });
        let connectionString = connectionStrings.join(",") + "/";
        let connectionStringOptions = [];
        if (result.path) {
          let defaultDb = result.path.slice(1);
          if (defaultDb.indexOf("?") !== -1) {
            defaultDb = defaultDb.slice(0, defaultDb.indexOf("?"));
          }
          connectionString += defaultDb;
        }
        if (!options2.ssl && !result.search) {
          connectionStringOptions.push("ssl=true");
        } else if (!options2.ssl && result.search && !result.search.match("ssl")) {
          connectionStringOptions.push("ssl=true");
        }
        if (result.search) {
          connectionStringOptions.push(result.search.replace("?", ""));
        }
        dns.resolveTxt(result.host, function(err2, record) {
          if (err2 && err2.code !== "ENODATA" && err2.code !== "ENOTFOUND")
            return callback(err2);
          if (err2 && err2.code === "ENODATA")
            record = null;
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = record[0].join("");
            const parsedRecord = qs.parse(record);
            const items = Object.keys(parsedRecord);
            if (items.some((item) => item !== "authSource" && item !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            if (items.length > 0) {
              connectionStringOptions.push(record);
            }
          }
          if (connectionStringOptions.length) {
            connectionString += `?${connectionStringOptions.join("&")}`;
          }
          parseHandler(connectionString, options2, callback);
        });
      });
    };
    function matchesParentDomain(srvAddress, parentDomain) {
      let regex = /^.*?\./;
      let srv = `.${srvAddress.replace(regex, "")}`;
      let parent = `.${parentDomain.replace(regex, "")}`;
      if (srv.endsWith(parent))
        return true;
      else
        return false;
    }
    function parseHandler(address, options2, callback) {
      let result, err;
      try {
        result = parseConnectionString(address, options2);
      } catch (e) {
        err = e;
      }
      return err ? callback(err, null) : callback(null, result);
    }
    function parseConnectionString(url, options2) {
      let connection_part = "";
      let auth_part = "";
      let query_string_part = "";
      let dbName = "admin";
      let result = parser.parse(url, true);
      if ((result.hostname == null || result.hostname === "") && url.indexOf(".sock") === -1) {
        throw new Error("No hostname or hostnames provided in connection string");
      }
      if (result.port === "0") {
        throw new Error("Invalid port (zero) with hostname");
      }
      if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
        throw new Error("Invalid port (larger than 65535) with hostname");
      }
      if (result.path && result.path.length > 0 && result.path[0] !== "/" && url.indexOf(".sock") === -1) {
        throw new Error("Missing delimiting slash between hosts and options");
      }
      if (result.query) {
        for (let name in result.query) {
          if (name.indexOf("::") !== -1) {
            throw new Error("Double colon in host identifier");
          }
          if (result.query[name] === "") {
            throw new Error("Query parameter " + name + " is an incomplete value pair");
          }
        }
      }
      if (result.auth) {
        let parts = result.auth.split(":");
        if (url.indexOf(result.auth) !== -1 && parts.length > 2) {
          throw new Error("Username with password containing an unescaped colon");
        }
        if (url.indexOf(result.auth) !== -1 && result.auth.indexOf("@") !== -1) {
          throw new Error("Username containing an unescaped at-sign");
        }
      }
      let clean = url.split("?").shift();
      let strings = clean.split(",");
      let hosts = [];
      for (let i = 0; i < strings.length; i++) {
        let hostString = strings[i];
        if (hostString.indexOf("mongodb") !== -1) {
          if (hostString.indexOf("@") !== -1) {
            hosts.push(hostString.split("@").pop());
          } else {
            hosts.push(hostString.substr("mongodb://".length));
          }
        } else if (hostString.indexOf("/") !== -1) {
          hosts.push(hostString.split("/").shift());
        } else if (hostString.indexOf("/") === -1) {
          hosts.push(hostString.trim());
        }
      }
      for (let i = 0; i < hosts.length; i++) {
        let r = parser.parse(f("mongodb://%s", hosts[i].trim()));
        if (r.path && r.path.indexOf(".sock") !== -1)
          continue;
        if (r.path && r.path.indexOf(":") !== -1) {
          if (r.path.split("/").length > 1 && r.path.indexOf("::") === -1) {
            throw new Error("Slash in host identifier");
          } else {
            throw new Error("Double colon in host identifier");
          }
        }
      }
      if (url.indexOf("?") !== -1) {
        query_string_part = url.substr(url.indexOf("?") + 1);
        connection_part = url.substring("mongodb://".length, url.indexOf("?"));
      } else {
        connection_part = url.substring("mongodb://".length);
      }
      if (connection_part.indexOf("@") !== -1) {
        auth_part = connection_part.split("@")[0];
        connection_part = connection_part.split("@")[1];
      }
      if (connection_part.split("/").length > 2) {
        throw new Error("Unsupported host '" + connection_part.split("?")[0] + "', hosts must be URL encoded and contain at most one unencoded slash");
      }
      if (connection_part.indexOf(".sock") !== -1) {
        if (connection_part.indexOf(".sock/") !== -1) {
          dbName = connection_part.split(".sock/")[1];
          if (dbName.indexOf("/") !== -1) {
            if (dbName.split("/").length === 2 && dbName.split("/")[1].length === 0) {
              throw new Error("Illegal trailing backslash after database name");
            }
            throw new Error("More than 1 database name in URL");
          }
          connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
        }
      } else if (connection_part.indexOf("/") !== -1) {
        if (connection_part.split("/").length > 2) {
          if (connection_part.split("/")[2].length === 0) {
            throw new Error("Illegal trailing backslash after database name");
          }
          throw new Error("More than 1 database name in URL");
        }
        dbName = connection_part.split("/")[1];
        connection_part = connection_part.split("/")[0];
      }
      connection_part = decodeURIComponent(connection_part);
      let object = {};
      let authPart = auth_part || "";
      let auth = authPart.split(":", 2);
      let user = decodeURIComponent(auth[0]);
      if (auth[0] !== encodeURIComponent(user)) {
        throw new Error("Username contains an illegal unescaped character");
      }
      auth[0] = user;
      if (auth[1]) {
        let pass = decodeURIComponent(auth[1]);
        if (auth[1] !== encodeURIComponent(pass)) {
          throw new Error("Password contains an illegal unescaped character");
        }
        auth[1] = pass;
      }
      if (auth.length === 2)
        object.auth = {user: auth[0], password: auth[1]};
      if (options2 && options2.auth != null)
        object.auth = options2.auth;
      let hostPart;
      let urlOptions;
      let servers;
      let compression;
      let serverOptions = {socketOptions: {}};
      let dbOptions = {read_preference_tags: []};
      let replSetServersOptions = {socketOptions: {}};
      let mongosOptions = {socketOptions: {}};
      object.server_options = serverOptions;
      object.db_options = dbOptions;
      object.rs_options = replSetServersOptions;
      object.mongos_options = mongosOptions;
      if (url.match(/\.sock/)) {
        let domainSocket = url.substring(url.indexOf("mongodb://") + "mongodb://".length, url.lastIndexOf(".sock") + ".sock".length);
        if (domainSocket.indexOf("@") !== -1)
          domainSocket = domainSocket.split("@")[1];
        domainSocket = decodeURIComponent(domainSocket);
        servers = [{domain_socket: domainSocket}];
      } else {
        hostPart = connection_part;
        let deduplicatedServers = {};
        servers = hostPart.split(",").map(function(h) {
          let _host, _port, ipv6match;
          if (ipv6match = /\[([^\]]+)\](?::(.+))?/.exec(h)) {
            _host = ipv6match[1];
            _port = parseInt(ipv6match[2], 10) || 27017;
          } else {
            let hostPort = h.split(":", 2);
            _host = hostPort[0] || "localhost";
            _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
            if (_host.indexOf("?") !== -1)
              _host = _host.split(/\?/)[0];
          }
          if (deduplicatedServers[_host + "_" + _port])
            return null;
          deduplicatedServers[_host + "_" + _port] = 1;
          return {host: _host, port: _port};
        }).filter(function(x) {
          return x != null;
        });
      }
      object.dbName = dbName || "admin";
      urlOptions = (query_string_part || "").split(/[&;]/);
      urlOptions.forEach(function(opt) {
        if (!opt)
          return;
        var splitOpt = opt.split("="), name = splitOpt[0], value = splitOpt[1];
        switch (name) {
          case "slaveOk":
          case "slave_ok":
            serverOptions.slave_ok = value === "true";
            dbOptions.slaveOk = value === "true";
            break;
          case "maxPoolSize":
          case "poolSize":
            serverOptions.poolSize = parseInt(value, 10);
            replSetServersOptions.poolSize = parseInt(value, 10);
            break;
          case "appname":
            object.appname = decodeURIComponent(value);
            break;
          case "autoReconnect":
          case "auto_reconnect":
            serverOptions.auto_reconnect = value === "true";
            break;
          case "ssl":
            if (value === "prefer") {
              serverOptions.ssl = value;
              replSetServersOptions.ssl = value;
              mongosOptions.ssl = value;
              break;
            }
            serverOptions.ssl = value === "true";
            replSetServersOptions.ssl = value === "true";
            mongosOptions.ssl = value === "true";
            break;
          case "sslValidate":
            serverOptions.sslValidate = value === "true";
            replSetServersOptions.sslValidate = value === "true";
            mongosOptions.sslValidate = value === "true";
            break;
          case "replicaSet":
          case "rs_name":
            replSetServersOptions.rs_name = value;
            break;
          case "reconnectWait":
            replSetServersOptions.reconnectWait = parseInt(value, 10);
            break;
          case "retries":
            replSetServersOptions.retries = parseInt(value, 10);
            break;
          case "readSecondary":
          case "read_secondary":
            replSetServersOptions.read_secondary = value === "true";
            break;
          case "fsync":
            dbOptions.fsync = value === "true";
            break;
          case "journal":
            dbOptions.j = value === "true";
            break;
          case "safe":
            dbOptions.safe = value === "true";
            break;
          case "nativeParser":
          case "native_parser":
            dbOptions.native_parser = value === "true";
            break;
          case "readConcernLevel":
            dbOptions.readConcern = new ReadConcern(value);
            break;
          case "connectTimeoutMS":
            serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            break;
          case "socketTimeoutMS":
            serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            break;
          case "w":
            dbOptions.w = parseInt(value, 10);
            if (isNaN(dbOptions.w))
              dbOptions.w = value;
            break;
          case "authSource":
            dbOptions.authSource = value;
            break;
          case "gssapiServiceName":
            dbOptions.gssapiServiceName = value;
            break;
          case "authMechanism":
            if (value === "GSSAPI") {
              if (object.auth == null) {
                let urlDecodeAuthPart = decodeURIComponent(authPart);
                if (urlDecodeAuthPart.indexOf("@") === -1)
                  throw new Error("GSSAPI requires a provided principal");
                object.auth = {user: urlDecodeAuthPart, password: null};
              } else {
                object.auth.user = decodeURIComponent(object.auth.user);
              }
            } else if (value === "MONGODB-X509") {
              object.auth = {user: decodeURIComponent(authPart)};
            }
            if (value !== "GSSAPI" && value !== "MONGODB-X509" && value !== "MONGODB-CR" && value !== "DEFAULT" && value !== "SCRAM-SHA-1" && value !== "SCRAM-SHA-256" && value !== "PLAIN")
              throw new Error("Only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, or SCRAM-SHA-1 is supported by authMechanism");
            dbOptions.authMechanism = value;
            break;
          case "authMechanismProperties":
            {
              let values = value.split(",");
              let o = {};
              values.forEach(function(x) {
                let v = x.split(":");
                o[v[0]] = v[1];
              });
              dbOptions.authMechanismProperties = o;
              if (typeof o.SERVICE_NAME === "string")
                dbOptions.gssapiServiceName = o.SERVICE_NAME;
              if (typeof o.SERVICE_REALM === "string")
                dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
              if (typeof o.CANONICALIZE_HOST_NAME === "string")
                dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME === "true" ? true : false;
            }
            break;
          case "wtimeoutMS":
            dbOptions.wtimeout = parseInt(value, 10);
            break;
          case "readPreference":
            if (!ReadPreference.isValid(value))
              throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
            dbOptions.readPreference = value;
            break;
          case "maxStalenessSeconds":
            dbOptions.maxStalenessSeconds = parseInt(value, 10);
            break;
          case "readPreferenceTags":
            {
              value = decodeURIComponent(value);
              let tagObject = {};
              if (value == null || value === "") {
                dbOptions.read_preference_tags.push(tagObject);
                break;
              }
              let tags = value.split(/,/);
              for (let i = 0; i < tags.length; i++) {
                let parts = tags[i].trim().split(/:/);
                tagObject[parts[0]] = parts[1];
              }
              dbOptions.read_preference_tags.push(tagObject);
            }
            break;
          case "compressors":
            {
              compression = serverOptions.compression || {};
              let compressors = value.split(",");
              if (!compressors.every(function(compressor) {
                return compressor === "snappy" || compressor === "zlib";
              })) {
                throw new Error("Compressors must be at least one of snappy or zlib");
              }
              compression.compressors = compressors;
              serverOptions.compression = compression;
            }
            break;
          case "zlibCompressionLevel":
            {
              compression = serverOptions.compression || {};
              let zlibCompressionLevel = parseInt(value, 10);
              if (zlibCompressionLevel < -1 || zlibCompressionLevel > 9) {
                throw new Error("zlibCompressionLevel must be an integer between -1 and 9");
              }
              compression.zlibCompressionLevel = zlibCompressionLevel;
              serverOptions.compression = compression;
            }
            break;
          case "retryWrites":
            dbOptions.retryWrites = value === "true";
            break;
          case "minSize":
            dbOptions.minSize = parseInt(value, 10);
            break;
          default:
            {
              let logger = Logger("URL Parser");
              logger.warn(`${name} is not supported as a connection string option`);
            }
            break;
        }
      });
      if (dbOptions.read_preference_tags.length === 0) {
        dbOptions.read_preference_tags = null;
      }
      if ((dbOptions.w === -1 || dbOptions.w === 0) && (dbOptions.journal === true || dbOptions.fsync === true || dbOptions.safe === true))
        throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync");
      if (!dbOptions.readPreference) {
        dbOptions.readPreference = "primary";
      }
      dbOptions = Object.assign(dbOptions, options2);
      object.servers = servers;
      return object;
    }
  }
});

// node_modules/mongodb-client-encryption/lib/common.js
var require_common3 = __commonJS({
  "node_modules/mongodb-client-encryption/lib/common.js"(exports2, module2) {
    "use strict";
    function debug(msg) {
      if (process.env.MONGODB_CRYPT_DEBUG) {
        console.log(msg);
      }
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    var MongoCryptError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "MongoCryptError";
        Error.captureStackTrace(this, this.constructor);
      }
    };
    function promiseOrCallback(callback, fn) {
      if (typeof callback === "function") {
        fn(function(err) {
          if (err != null) {
            try {
              callback(err);
            } catch (error3) {
              return process.nextTick(() => {
                throw error3;
              });
            }
            return;
          }
          callback.apply(this, arguments);
        });
        return;
      }
      return new Promise((resolve2, reject) => {
        fn(function(err, res) {
          if (err != null) {
            return reject(err);
          }
          if (arguments.length > 2) {
            return resolve2(Array.prototype.slice.call(arguments, 1));
          }
          resolve2(res);
        });
      });
    }
    module2.exports = {
      debug,
      databaseNamespace,
      collectionNamespace,
      MongoCryptError,
      promiseOrCallback
    };
  }
});

// node_modules/mongodb-client-encryption/lib/stateMachine.js
var require_stateMachine = __commonJS({
  "node_modules/mongodb-client-encryption/lib/stateMachine.js"(exports2, module2) {
    "use strict";
    module2.exports = function(modules) {
      const tls = require("tls");
      const MongoTimeoutError = modules.mongodb.MongoTimeoutError;
      const common = require_common3();
      const debug = common.debug;
      const databaseNamespace = common.databaseNamespace;
      const collectionNamespace = common.collectionNamespace;
      const MongoCryptError = common.MongoCryptError;
      const BufferList = require_bl();
      const MONGOCRYPT_CTX_ERROR = 0;
      const MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
      const MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
      const MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
      const MONGOCRYPT_CTX_NEED_KMS = 4;
      const MONGOCRYPT_CTX_READY = 5;
      const MONGOCRYPT_CTX_DONE = 6;
      const HTTPS_PORT = 443;
      const stateToString = new Map([
        [MONGOCRYPT_CTX_ERROR, "MONGOCRYPT_CTX_ERROR"],
        [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, "MONGOCRYPT_CTX_NEED_MONGO_COLLINFO"],
        [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, "MONGOCRYPT_CTX_NEED_MONGO_MARKINGS"],
        [MONGOCRYPT_CTX_NEED_MONGO_KEYS, "MONGOCRYPT_CTX_NEED_MONGO_KEYS"],
        [MONGOCRYPT_CTX_NEED_KMS, "MONGOCRYPT_CTX_NEED_KMS"],
        [MONGOCRYPT_CTX_READY, "MONGOCRYPT_CTX_READY"],
        [MONGOCRYPT_CTX_DONE, "MONGOCRYPT_CTX_DONE"]
      ]);
      class StateMachine {
        constructor(options2) {
          this.options = options2 || {};
          this.bson = options2.bson;
        }
        execute(autoEncrypter, context, callback) {
          const bson = this.bson;
          const keyVaultNamespace = autoEncrypter._keyVaultNamespace;
          const keyVaultClient = autoEncrypter._keyVaultClient;
          const metaDataClient = autoEncrypter._metaDataClient;
          const mongocryptdClient = autoEncrypter._mongocryptdClient;
          const mongocryptdManager = autoEncrypter._mongocryptdManager;
          debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);
          switch (context.state) {
            case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
              const filter = bson.deserialize(context.nextMongoOperation());
              this.fetchCollectionInfo(metaDataClient, context.ns, filter, (err, collInfo) => {
                if (err) {
                  return callback(err, null);
                }
                if (collInfo) {
                  context.addMongoOperationResponse(collInfo);
                }
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
              const command = context.nextMongoOperation();
              this.markCommand(mongocryptdClient, context.ns, command, (err, markedCommand) => {
                if (err) {
                  if (err instanceof MongoTimeoutError && mongocryptdManager && !mongocryptdManager.bypassSpawn) {
                    mongocryptdManager.spawn(() => {
                      this.markCommand(mongocryptdClient, context.ns, command, (err2, markedCommand2) => {
                        if (err2)
                          return callback(err2, null);
                        context.addMongoOperationResponse(markedCommand2);
                        context.finishMongoOperation();
                        this.execute(autoEncrypter, context, callback);
                      });
                    });
                    return;
                  }
                  return callback(err, null);
                }
                context.addMongoOperationResponse(markedCommand);
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
              const filter = context.nextMongoOperation();
              this.fetchKeys(keyVaultClient, keyVaultNamespace, filter, (err, keys) => {
                if (err)
                  return callback(err, null);
                keys.forEach((key) => {
                  context.addMongoOperationResponse(bson.serialize(key));
                });
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_KMS: {
              const promises = [];
              let request;
              while (request = context.nextKMSRequest()) {
                promises.push(this.kmsRequest(request));
              }
              Promise.all(promises).then(() => {
                context.finishKMSRequests();
                this.execute(autoEncrypter, context, callback);
              }).catch((err) => {
                callback(err, null);
              });
              return;
            }
            case MONGOCRYPT_CTX_READY: {
              const finalizedContext = context.finalize();
              if (context.state === MONGOCRYPT_CTX_ERROR) {
                const message = context.status.message || "Finalization error";
                callback(new MongoCryptError(message));
                return;
              }
              callback(null, bson.deserialize(finalizedContext, this.options));
              return;
            }
            case MONGOCRYPT_CTX_ERROR: {
              const message = context.status.message;
              callback(new MongoCryptError(message));
              return;
            }
            case MONGOCRYPT_CTX_DONE:
              return;
            default:
              callback(new MongoCryptError(`Unknown state: ${context.state}`));
              return;
          }
        }
        kmsRequest(request) {
          const parsedUrl = request.endpoint.split(":");
          const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
          const options2 = {host: parsedUrl[0], servername: parsedUrl[0], port};
          const message = request.message;
          return new Promise((resolve2, reject) => {
            const buffer = new BufferList();
            const socket = tls.connect(options2, () => {
              socket.write(message);
            });
            socket.once("timeout", () => {
              socket.removeAllListeners();
              socket.destroy();
              reject(new MongoCryptError("KMS request timed out"));
            });
            socket.once("error", (err) => {
              socket.removeAllListeners();
              socket.destroy();
              const mcError = new MongoCryptError("KMS request failed");
              mcError.originalError = err;
              reject(mcError);
            });
            socket.on("data", (data) => {
              buffer.append(data);
              while (request.bytesNeeded > 0 && buffer.length) {
                const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);
                request.addResponse(buffer.slice(0, bytesNeeded));
                buffer.consume(bytesNeeded);
              }
              if (request.bytesNeeded <= 0) {
                socket.end(resolve2);
              }
            });
          });
        }
        fetchCollectionInfo(client, ns, filter, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(ns);
          client.db(dbName).listCollections(filter).toArray((err, collections) => {
            if (err) {
              callback(err, null);
              return;
            }
            const info = collections.length > 0 ? bson.serialize(collections[0]) : null;
            callback(null, info);
          });
        }
        markCommand(client, ns, command, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(ns);
          const rawCommand = bson.deserialize(command, {promoteLongs: false, promoteValues: false});
          client.db(dbName).command(rawCommand, (err, response) => {
            if (err) {
              callback(err, null);
              return;
            }
            callback(err, bson.serialize(response, this.options));
          });
        }
        fetchKeys(client, keyVaultNamespace, filter, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(keyVaultNamespace);
          const collectionName = collectionNamespace(keyVaultNamespace);
          filter = bson.deserialize(filter);
          client.db(dbName).collection(collectionName, {readConcern: {level: "majority"}}).find(filter).toArray((err, keys) => {
            if (err) {
              callback(err, null);
              return;
            }
            callback(null, keys);
          });
        }
      }
      return {StateMachine};
    };
  }
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "node_modules/file-uri-to-path/index.js"(exports2, module2) {
    var sep = require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if (host == "localhost")
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        ["module_root", "build", "bindings"],
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        ["module_root", "build", "default", "bindings"],
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = {bindings: opts};
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports2.getRoot(exports2.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(null, opts.try[i].map(function(p) {
          return opts[p] || p;
        }));
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
        return opts.arrow + a;
      }).join("\n"));
      err.tries = tries;
      throw err;
    }
    module2.exports = exports2 = bindings;
    exports2.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    };
    exports2.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// node_modules/mongodb-client-encryption/lib/mongocryptdManager.js
var require_mongocryptdManager = __commonJS({
  "node_modules/mongodb-client-encryption/lib/mongocryptdManager.js"(exports2, module2) {
    "use strict";
    var spawn = require("child_process").spawn;
    var MongocryptdManager = class {
      constructor(extraOptions) {
        extraOptions = extraOptions || {};
        if (extraOptions.mongocryptdURI) {
          this.uri = extraOptions.mongocryptdURI;
        } else {
          this.uri = "mongodb://localhost:27020/?serverSelectionTimeoutMS=1000";
        }
        this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
        this.spawnPath = extraOptions.mongocryptdSpawnPath || "";
        this.spawnArgs = [];
        if (Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
          this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
        }
        if (this.spawnArgs.filter((arg) => typeof arg === "string").every((arg) => arg.indexOf("--idleShutdownTimeoutSecs") < 0)) {
          this.spawnArgs.push("--idleShutdownTimeoutSecs", 60);
        }
      }
      spawn(callback) {
        const cmdName = this.spawnPath || "mongocryptd";
        this._child = spawn(cmdName, this.spawnArgs, {
          stdio: "ignore",
          detached: true
        });
        this._child.on("error", () => {
        });
        this._child.unref();
        process.nextTick(callback);
      }
    };
    module2.exports = {MongocryptdManager};
  }
});

// node_modules/mongodb-client-encryption/lib/cryptoCallbacks.js
var require_cryptoCallbacks = __commonJS({
  "node_modules/mongodb-client-encryption/lib/cryptoCallbacks.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    function aes256CbcEncryptHook(key, iv, input, output) {
      let result;
      try {
        let cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function aes256CbcDecryptHook(key, iv, input, output) {
      let result;
      try {
        let cipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function randomHook(buffer, count) {
      try {
        crypto.randomFillSync(buffer, 0, count);
      } catch (e) {
        return e;
      }
      return count;
    }
    function randomHookNode4(buffer, count) {
      let result;
      try {
        result = crypto.randomBytes(count);
      } catch (e) {
        return e;
      }
      result.copy(buffer);
      return count;
    }
    function sha256Hook(input, output) {
      let result;
      try {
        result = crypto.createHash("sha256").update(input).digest();
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function makeHmacHook(algorithm) {
      return (key, input, output) => {
        let result;
        try {
          result = crypto.createHmac(algorithm, key).update(input).digest();
        } catch (e) {
          return e;
        }
        result.copy(output);
        return result.length;
      };
    }
    function signRsaSha256Hook(key, input, output) {
      let result;
      try {
        const signer = crypto.createSign("sha256WithRSAEncryption");
        const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----
${key.toString("base64")}
-----END PRIVATE KEY-----
`);
        result = signer.update(input).end().sign(privateKey);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    module2.exports = {
      aes256CbcEncryptHook,
      aes256CbcDecryptHook,
      randomHook: typeof crypto.randomFillSync === "function" ? randomHook : randomHookNode4,
      hmacSha512Hook: makeHmacHook("sha512"),
      hmacSha256Hook: makeHmacHook("sha256"),
      sha256Hook,
      signRsaSha256Hook
    };
  }
});

// node_modules/mongodb-client-encryption/lib/autoEncrypter.js
var require_autoEncrypter = __commonJS({
  "node_modules/mongodb-client-encryption/lib/autoEncrypter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(modules) {
      const mc = require_bindings()("mongocrypt");
      const common = require_common3();
      const databaseNamespace = common.databaseNamespace;
      const StateMachine = modules.stateMachine.StateMachine;
      const MongocryptdManager = require_mongocryptdManager().MongocryptdManager;
      const MongoClient2 = modules.mongodb.MongoClient;
      const MongoError = modules.mongodb.MongoError;
      const cryptoCallbacks = require_cryptoCallbacks();
      class AutoEncrypter {
        constructor(client, options2) {
          this._client = client;
          this._bson = options2.bson || client.topology.bson;
          this._mongocryptdManager = new MongocryptdManager(options2.extraOptions);
          this._mongocryptdClient = new MongoClient2(this._mongocryptdManager.uri, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            serverSelectionTimeoutMS: 1e3
          });
          this._keyVaultNamespace = options2.keyVaultNamespace || "admin.datakeys";
          this._keyVaultClient = options2.keyVaultClient || client;
          this._metaDataClient = options2.metadataClient || client;
          this._bypassEncryption = typeof options2.bypassAutoEncryption === "boolean" ? options2.bypassAutoEncryption : false;
          const mongoCryptOptions = {};
          if (options2.schemaMap) {
            mongoCryptOptions.schemaMap = Buffer.isBuffer(options2.schemaMap) ? options2.schemaMap : this._bson.serialize(options2.schemaMap);
          }
          if (options2.kmsProviders) {
            mongoCryptOptions.kmsProviders = !Buffer.isBuffer(options2.kmsProviders) ? this._bson.serialize(options2.kmsProviders) : options2.kmsProviders;
          }
          if (options2.logger) {
            mongoCryptOptions.logger = options2.logger;
          }
          Object.assign(mongoCryptOptions, {cryptoCallbacks});
          this._mongocrypt = new mc.MongoCrypt(mongoCryptOptions);
          this._contextCounter = 0;
        }
        init(callback) {
          const _callback = (err, res) => {
            if (err && err.message && (err.message.match(/timed out after/) || err.message.match(/ENOTFOUND/))) {
              callback(new MongoError("Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn"));
              return;
            }
            callback(err, res);
          };
          if (this._mongocryptdManager.bypassSpawn) {
            return this._mongocryptdClient.connect(_callback);
          }
          this._mongocryptdManager.spawn(() => this._mongocryptdClient.connect(_callback));
        }
        teardown(force, callback) {
          this._mongocryptdClient.close(force, callback);
        }
        encrypt(ns, cmd, options2, callback) {
          if (typeof ns !== "string") {
            throw new TypeError("Parameter `ns` must be a string");
          }
          if (typeof cmd !== "object") {
            throw new TypeError("Parameter `cmd` must be an object");
          }
          if (typeof options2 === "function" && callback == null) {
            callback = options2;
            options2 = {};
          }
          if (this._bypassEncryption) {
            callback(void 0, cmd);
            return;
          }
          const bson = this._bson;
          const commandBuffer = Buffer.isBuffer(cmd) ? cmd : bson.serialize(cmd, options2);
          let context;
          try {
            context = this._mongocrypt.makeEncryptionContext(databaseNamespace(ns), commandBuffer);
          } catch (err) {
            callback(err, null);
            return;
          }
          context.id = this._contextCounter++;
          context.ns = ns;
          context.document = cmd;
          const stateMachine = new StateMachine(Object.assign({bson}, options2));
          stateMachine.execute(this, context, callback);
        }
        decrypt(response, options2, callback) {
          if (typeof options2 === "function" && callback == null) {
            callback = options2;
            options2 = {};
          }
          const bson = this._bson;
          const buffer = Buffer.isBuffer(response) ? response : bson.serialize(response, options2);
          let context;
          try {
            context = this._mongocrypt.makeDecryptionContext(buffer);
          } catch (err) {
            callback(err, null);
            return;
          }
          context.id = this._contextCounter++;
          const stateMachine = new StateMachine(Object.assign({bson}, options2));
          stateMachine.execute(this, context, callback);
        }
      }
      return {AutoEncrypter};
    };
  }
});

// node_modules/mongodb-client-encryption/lib/clientEncryption.js
var require_clientEncryption = __commonJS({
  "node_modules/mongodb-client-encryption/lib/clientEncryption.js"(exports2, module2) {
    "use strict";
    module2.exports = function(modules) {
      const mc = require_bindings()("mongocrypt");
      const common = require_common3();
      const databaseNamespace = common.databaseNamespace;
      const collectionNamespace = common.collectionNamespace;
      const promiseOrCallback = common.promiseOrCallback;
      const StateMachine = modules.stateMachine.StateMachine;
      const cryptoCallbacks = require_cryptoCallbacks();
      function sanitizeDataKeyOptions(bson, options2) {
        options2 = Object.assign({}, options2);
        if (options2.keyAltNames) {
          if (!Array.isArray(options2.keyAltNames)) {
            throw new TypeError(`Option "keyAltNames" must be an array of string, but was of type ${typeof options2.keyAltNames}.`);
          }
          const serializedKeyAltNames = [];
          for (let i = 0; i < options2.keyAltNames.length; i += 1) {
            const item = options2.keyAltNames[i];
            const itemType = typeof item;
            if (itemType !== "string") {
              throw new TypeError(`Option "keyAltNames" must be an array of string, but item at index ${i} was of type ${itemType} `);
            }
            serializedKeyAltNames.push(bson.serialize({keyAltName: item}));
          }
          options2.keyAltNames = serializedKeyAltNames;
        } else if (options2.keyAltNames == null) {
          delete options2.keyAltNames;
        }
        return options2;
      }
      class ClientEncryption {
        constructor(client, options2) {
          this._client = client;
          this._bson = options2.bson || client.topology.bson;
          if (options2.keyVaultNamespace == null) {
            throw new TypeError("Missing required option `keyVaultNamespace`");
          }
          Object.assign(options2, {cryptoCallbacks});
          if (options2.kmsProviders && !Buffer.isBuffer(options2.kmsProviders)) {
            options2.kmsProviders = this._bson.serialize(options2.kmsProviders);
          }
          this._keyVaultNamespace = options2.keyVaultNamespace;
          this._keyVaultClient = options2.keyVaultClient || client;
          this._mongoCrypt = new mc.MongoCrypt(options2);
        }
        createDataKey(provider, options2, callback) {
          if (typeof options2 === "function")
            callback = options2, options2 = {};
          const bson = this._bson;
          options2 = sanitizeDataKeyOptions(bson, options2);
          const dataKeyBson = bson.serialize(Object.assign({provider}, options2.masterKey));
          const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson);
          const stateMachine = new StateMachine({bson});
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, dataKey) => {
              if (err) {
                cb(err, null);
                return;
              }
              const dbName = databaseNamespace(this._keyVaultNamespace);
              const collectionName = collectionNamespace(this._keyVaultNamespace);
              this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {w: "majority"}, (err2, result) => {
                if (err2) {
                  cb(err2, null);
                  return;
                }
                cb(null, result.insertedId);
              });
            });
          });
        }
        encrypt(value, options2, callback) {
          const bson = this._bson;
          const valueBuffer = bson.serialize({v: value});
          const contextOptions = Object.assign({}, options2);
          if (options2.keyId) {
            contextOptions.keyId = options2.keyId.buffer;
          }
          if (options2.keyAltName) {
            const keyAltName = options2.keyAltName;
            if (options2.keyId) {
              throw new TypeError(`"options" cannot contain both "keyId" and "keyAltName"`);
            }
            const keyAltNameType = typeof keyAltName;
            if (keyAltNameType !== "string") {
              throw new TypeError(`"options.keyAltName" must be of type string, but was of type ${keyAltNameType}`);
            }
            contextOptions.keyAltName = bson.serialize({keyAltName});
          }
          const stateMachine = new StateMachine({bson});
          const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, result) => {
              if (err) {
                cb(err, null);
                return;
              }
              cb(null, result.v);
            });
          });
        }
        decrypt(value, callback) {
          const bson = this._bson;
          const valueBuffer = bson.serialize({v: value});
          const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
          const stateMachine = new StateMachine({bson});
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, result) => {
              if (err) {
                cb(err, null);
                return;
              }
              cb(null, result.v);
            });
          });
        }
      }
      return {ClientEncryption};
    };
  }
});

// node_modules/mongodb-client-encryption/index.js
var require_mongodb_client_encryption = __commonJS({
  "node_modules/mongodb-client-encryption/index.js"(exports2, module2) {
    "use strict";
    var defaultModule;
    function loadDefaultModule() {
      if (!defaultModule) {
        defaultModule = extension(require_mongodb());
      }
      return defaultModule;
    }
    var MongoCryptError = require_common3().MongoCryptError;
    function extension(mongodb) {
      const modules = {mongodb};
      modules.stateMachine = require_stateMachine()(modules);
      modules.autoEncrypter = require_autoEncrypter()(modules);
      modules.clientEncryption = require_clientEncryption()(modules);
      return {
        AutoEncrypter: modules.autoEncrypter.AutoEncrypter,
        ClientEncryption: modules.clientEncryption.ClientEncryption,
        MongoCryptError
      };
    }
    module2.exports = {
      extension,
      MongoCryptError,
      get AutoEncrypter() {
        const m = loadDefaultModule();
        delete module2.exports.AutoEncrypter;
        module2.exports.AutoEncrypter = m.AutoEncrypter;
        return m.AutoEncrypter;
      },
      get ClientEncryption() {
        const m = loadDefaultModule();
        delete module2.exports.ClientEncryption;
        module2.exports.ClientEncryption = m.ClientEncryption;
        return m.ClientEncryption;
      }
    };
  }
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/mongodb/lib/encrypter.js"(exports2, module2) {
    "use strict";
    var MongoClient2 = require_mongo_client();
    var BSON2 = require_utils3().retrieveBSON();
    var MongoError = require_error().MongoError;
    try {
      require.resolve("mongodb-client-encryption");
    } catch (err) {
      throw new MongoError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project");
    }
    var mongodbClientEncryption = require_mongodb_client_encryption();
    if (typeof mongodbClientEncryption.extension !== "function") {
      throw new MongoError("loaded version of `mongodb-client-encryption` does not have property `extension`. Please make sure you are loading the correct version of `mongodb-client-encryption`");
    }
    var AutoEncrypter = mongodbClientEncryption.extension(require_mongodb()).AutoEncrypter;
    var kInternalClient = Symbol("internalClient");
    var Encrypter = class {
      constructor(client, options2) {
        this.bypassAutoEncryption = !!options2.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options2.maxPoolSize === 0 && options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = client;
        } else if (options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = this.getInternalClient(client);
        }
        if (this.bypassAutoEncryption) {
          options2.autoEncryption.metadataClient = void 0;
        } else if (options2.maxPoolSize === 0) {
          options2.autoEncryption.metadataClient = client;
        } else {
          options2.autoEncryption.metadataClient = this.getInternalClient(client);
        }
        options2.autoEncryption.bson = Encrypter.makeBSON(options2);
        this.autoEncrypter = new AutoEncrypter(client, options2.autoEncryption);
      }
      getInternalClient(client) {
        if (!this[kInternalClient]) {
          const clonedOptions = {};
          for (const key of Object.keys(client.s.options)) {
            if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].indexOf(key) !== -1)
              continue;
            clonedOptions[key] = client.s.options[key];
          }
          clonedOptions.minPoolSize = 0;
          const allEvents = [
            "commandStarted",
            "commandSucceeded",
            "commandFailed",
            "serverOpening",
            "serverClosed",
            "serverDescriptionChanged",
            "serverHeartbeatStarted",
            "serverHeartbeatSucceeded",
            "serverHeartbeatFailed",
            "topologyOpening",
            "topologyClosed",
            "topologyDescriptionChanged",
            "joined",
            "left",
            "ping",
            "ha",
            "connectionPoolCreated",
            "connectionPoolClosed",
            "connectionCreated",
            "connectionReady",
            "connectionClosed",
            "connectionCheckOutStarted",
            "connectionCheckOutFailed",
            "connectionCheckedOut",
            "connectionCheckedIn",
            "connectionPoolCleared"
          ];
          this[kInternalClient] = new MongoClient2(client.s.url, clonedOptions);
          for (const eventName of allEvents) {
            for (const listener of client.listeners(eventName)) {
              this[kInternalClient].on(eventName, listener);
            }
          }
          client.on("newListener", (eventName, listener) => {
            this[kInternalClient].on(eventName, listener);
          });
          this.needsConnecting = true;
        }
        return this[kInternalClient];
      }
      connectInternalClient(callback) {
        if (this.needsConnecting) {
          this.needsConnecting = false;
          return this[kInternalClient].connect(callback);
        }
        return callback();
      }
      close(client, force, callback) {
        this.autoEncrypter.teardown((e) => {
          if (this[kInternalClient] && client !== this[kInternalClient]) {
            return this[kInternalClient].close(force, callback);
          }
          callback(e);
        });
      }
      static makeBSON(options2) {
        return (options2 || {}).bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]);
      }
    };
    module2.exports = {Encrypter};
  }
});

// node_modules/mongodb/lib/operations/connect.js
var require_connect2 = __commonJS({
  "node_modules/mongodb/lib/operations/connect.js"(exports2, module2) {
    "use strict";
    var deprecate = require("util").deprecate;
    var Logger = require_core().Logger;
    var MongoCredentials = require_core().MongoCredentials;
    var MongoError = require_core().MongoError;
    var Mongos = require_mongos2();
    var NativeTopology = require_native_topology();
    var parse = require_core().parseConnectionString;
    var ReadConcern = require_read_concern();
    var ReadPreference = require_core().ReadPreference;
    var ReplSet = require_replset2();
    var Server = require_server3();
    var ServerSessionPool = require_core().Sessions.ServerSessionPool;
    var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var fs = require("fs");
    var WriteConcern = require_write_concern();
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var client;
    function loadClient() {
      if (!client) {
        client = require_mongo_client();
      }
      return client;
    }
    var legacyParse = deprecate(require_url_parser(), "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.");
    var AUTH_MECHANISM_INTERNAL_MAP = {
      DEFAULT: "default",
      PLAIN: "plain",
      GSSAPI: "gssapi",
      "MONGODB-CR": "mongocr",
      "MONGODB-X509": "x509",
      "MONGODB-AWS": "mongodb-aws",
      "SCRAM-SHA-1": "scram-sha-1",
      "SCRAM-SHA-256": "scram-sha-256"
    };
    var monitoringEvents = [
      "timeout",
      "close",
      "serverOpening",
      "serverDescriptionChanged",
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "serverClosed",
      "topologyOpening",
      "topologyClosed",
      "topologyDescriptionChanged",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ];
    var VALID_AUTH_MECHANISMS = new Set([
      "DEFAULT",
      "PLAIN",
      "GSSAPI",
      "MONGODB-CR",
      "MONGODB-X509",
      "MONGODB-AWS",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    var validOptionNames = [
      "poolSize",
      "ssl",
      "sslValidate",
      "sslCA",
      "sslCert",
      "sslKey",
      "sslPass",
      "sslCRL",
      "autoReconnect",
      "noDelay",
      "keepAlive",
      "keepAliveInitialDelay",
      "connectTimeoutMS",
      "family",
      "socketTimeoutMS",
      "reconnectTries",
      "reconnectInterval",
      "ha",
      "haInterval",
      "replicaSet",
      "secondaryAcceptableLatencyMS",
      "acceptableLatencyMS",
      "connectWithNoPrimary",
      "authSource",
      "w",
      "wtimeout",
      "j",
      "writeConcern",
      "forceServerObjectId",
      "serializeFunctions",
      "ignoreUndefined",
      "raw",
      "bufferMaxEntries",
      "readPreference",
      "pkFactory",
      "promiseLibrary",
      "readConcern",
      "maxStalenessSeconds",
      "loggerLevel",
      "logger",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs",
      "domainsEnabled",
      "checkServerIdentity",
      "validateOptions",
      "appname",
      "auth",
      "user",
      "password",
      "authMechanism",
      "compression",
      "fsync",
      "readPreferenceTags",
      "numberOfRetries",
      "auto_reconnect",
      "minSize",
      "monitorCommands",
      "retryWrites",
      "retryReads",
      "useNewUrlParser",
      "useUnifiedTopology",
      "serverSelectionTimeoutMS",
      "useRecoveryToken",
      "autoEncryption",
      "driverInfo",
      "tls",
      "tlsInsecure",
      "tlsinsecure",
      "tlsAllowInvalidCertificates",
      "tlsAllowInvalidHostnames",
      "tlsCAFile",
      "tlsCertificateFile",
      "tlsCertificateKeyFile",
      "tlsCertificateKeyFilePassword",
      "minHeartbeatFrequencyMS",
      "heartbeatFrequencyMS",
      "directConnection",
      "appName",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ];
    var ignoreOptionNames = ["native_parser"];
    var legacyOptionNames = ["server", "replset", "replSet", "mongos", "db"];
    function validOptions(options2) {
      const _validOptions = validOptionNames.concat(legacyOptionNames);
      for (const name in options2) {
        if (ignoreOptionNames.indexOf(name) !== -1) {
          continue;
        }
        if (_validOptions.indexOf(name) === -1) {
          if (options2.validateOptions) {
            return new MongoError(`option ${name} is not supported`);
          } else {
            emitWarningOnce(`the options [${name}] is not supported`);
          }
        }
        if (legacyOptionNames.indexOf(name) !== -1) {
          emitWarningOnce(`the server/replset/mongos/db options are deprecated, all their options are supported at the top level of the options object [${validOptionNames}]`);
        }
      }
    }
    var LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {
      obj[name.toLowerCase()] = name;
      return obj;
    }, {});
    function addListeners(mongoClient, topology) {
      topology.on("authenticated", createListener(mongoClient, "authenticated"));
      topology.on("error", createListener(mongoClient, "error"));
      topology.on("timeout", createListener(mongoClient, "timeout"));
      topology.on("close", createListener(mongoClient, "close"));
      topology.on("parseError", createListener(mongoClient, "parseError"));
      topology.once("open", createListener(mongoClient, "open"));
      topology.once("fullsetup", createListener(mongoClient, "fullsetup"));
      topology.once("all", createListener(mongoClient, "all"));
      topology.on("reconnect", createListener(mongoClient, "reconnect"));
    }
    function assignTopology(client2, topology) {
      client2.topology = topology;
      if (!(topology instanceof NativeTopology)) {
        topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);
      }
    }
    function clearAllEvents(topology) {
      monitoringEvents.forEach((event) => topology.removeAllListeners(event));
    }
    function collectEvents(mongoClient, topology) {
      let MongoClient2 = loadClient();
      const collectedEvents = [];
      if (mongoClient instanceof MongoClient2) {
        monitoringEvents.forEach((event) => {
          topology.on(event, (object1, object2) => {
            if (event === "open") {
              collectedEvents.push({event, object1: mongoClient});
            } else {
              collectedEvents.push({event, object1, object2});
            }
          });
        });
      }
      return collectedEvents;
    }
    function resolveTLSOptions(options2) {
      if (options2.tls == null) {
        return;
      }
      ["sslCA", "sslKey", "sslCert"].forEach((optionName) => {
        if (options2[optionName]) {
          options2[optionName] = fs.readFileSync(options2[optionName]);
        }
      });
    }
    function connect(mongoClient, url, options2, callback) {
      options2 = Object.assign({}, options2);
      if (callback == null) {
        throw new Error("no callback function provided");
      }
      let didRequestAuthentication = false;
      const logger = Logger("MongoClient", options2);
      if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {
        return connectWithUrl(mongoClient, url, options2, connectCallback);
      }
      const useNewUrlParser = options2.useNewUrlParser !== false;
      const parseFn = useNewUrlParser ? parse : legacyParse;
      const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;
      parseFn(url, options2, (err, _object) => {
        if (err)
          return callback(err);
        const object = transform(_object);
        const _finalOptions = createUnifiedOptions(object, options2);
        if (_finalOptions.socketTimeoutMS == null)
          _finalOptions.socketTimeoutMS = 0;
        if (_finalOptions.connectTimeoutMS == null)
          _finalOptions.connectTimeoutMS = 1e4;
        if (_finalOptions.retryWrites == null)
          _finalOptions.retryWrites = true;
        if (_finalOptions.useRecoveryToken == null)
          _finalOptions.useRecoveryToken = true;
        if (_finalOptions.readPreference == null)
          _finalOptions.readPreference = "primary";
        if (_finalOptions.db_options && _finalOptions.db_options.auth) {
          delete _finalOptions.db_options.auth;
        }
        resolveTLSOptions(_finalOptions);
        mongoClient.s.options = _finalOptions;
        mongoClient.s.readPreference = ReadPreference.fromOptions(_finalOptions);
        mongoClient.s.writeConcern = WriteConcern.fromOptions(_finalOptions);
        if (object.servers.length === 0) {
          return callback(new Error("connection string must contain at least one seed host"));
        }
        if (_finalOptions.auth && !_finalOptions.credentials) {
          try {
            didRequestAuthentication = true;
            _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);
          } catch (err2) {
            return callback(err2);
          }
        }
        if (_finalOptions.useUnifiedTopology) {
          return createTopology(mongoClient, "unified", _finalOptions, connectCallback);
        }
        emitWarningOnce("Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.");
        if (_finalOptions.replicaSet || _finalOptions.rs_name) {
          return createTopology(mongoClient, "replicaset", _finalOptions, connectCallback);
        } else if (object.servers.length > 1) {
          return createTopology(mongoClient, "mongos", _finalOptions, connectCallback);
        } else {
          return createServer(mongoClient, _finalOptions, connectCallback);
        }
      });
      function connectCallback(err, topology) {
        const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;
        if (err && err.message === "no mongos proxies found in seed list") {
          if (logger.isWarn()) {
            logger.warn(warningMessage);
          }
          return callback(new MongoError(warningMessage));
        }
        if (didRequestAuthentication) {
          mongoClient.emit("authenticated", null, true);
        }
        callback(err, topology);
      }
    }
    function connectWithUrl(mongoClient, url, options2, connectCallback) {
      assignTopology(mongoClient, url);
      addListeners(mongoClient, url);
      relayEvents(mongoClient, url);
      let finalOptions = Object.assign({}, options2);
      if (typeof options2.readPreference === "string" || typeof options2.read_preference === "string") {
        finalOptions.readPreference = new ReadPreference(options2.readPreference || options2.read_preference);
      }
      const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;
      if (isDoingAuth && !finalOptions.credentials) {
        try {
          finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);
        } catch (err) {
          return connectCallback(err, url);
        }
      }
      return url.connect(finalOptions, connectCallback);
    }
    function createListener(mongoClient, event) {
      const eventSet = new Set(["all", "fullsetup", "open", "reconnect"]);
      return (v1, v2) => {
        if (eventSet.has(event)) {
          return mongoClient.emit(event, mongoClient);
        }
        mongoClient.emit(event, v1, v2);
      };
    }
    function createServer(mongoClient, options2, callback) {
      options2.promiseLibrary = mongoClient.s.promiseLibrary;
      const servers = translateOptions(options2);
      const server = servers[0];
      const collectedEvents = collectEvents(mongoClient, server);
      server.connect(options2, (err, topology) => {
        if (err) {
          server.close(true);
          return callback(err);
        }
        clearAllEvents(server);
        relayEvents(mongoClient, server);
        addListeners(mongoClient, server);
        const ismaster = topology.lastIsMaster();
        assignTopology(mongoClient, topology);
        if (ismaster && ismaster.msg === "isdbgrid") {
          topology.close();
          return createTopology(mongoClient, "mongos", options2, callback);
        }
        replayEvents(mongoClient, collectedEvents);
        callback(err, topology);
      });
    }
    var DEPRECATED_UNIFIED_EVENTS = new Set([
      "reconnect",
      "reconnectFailed",
      "attemptReconnect",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ]);
    function registerDeprecatedEventNotifiers(client2) {
      client2.on("newListener", (eventName) => {
        if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {
          emitDeprecationWarning(`The \`${eventName}\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
        }
      });
    }
    function createTopology(mongoClient, topologyType, options2, callback) {
      options2.promiseLibrary = mongoClient.s.promiseLibrary;
      const translationOptions = {};
      if (topologyType === "unified")
        translationOptions.createServers = false;
      const servers = translateOptions(options2, translationOptions);
      if (options2.autoEncryption != null) {
        const Encrypter = require_encrypter().Encrypter;
        options2.encrypter = new Encrypter(mongoClient, options2);
        options2.autoEncrypter = options2.encrypter.autoEncrypter;
      }
      let topology;
      if (topologyType === "mongos") {
        topology = new Mongos(servers, options2);
      } else if (topologyType === "replicaset") {
        topology = new ReplSet(servers, options2);
      } else if (topologyType === "unified") {
        topology = new NativeTopology(options2.servers, options2);
        registerDeprecatedEventNotifiers(mongoClient);
      }
      addListeners(mongoClient, topology);
      relayEvents(mongoClient, topology);
      assignTopology(mongoClient, topology);
      if (options2.autoEncrypter) {
        options2.autoEncrypter.init((err) => {
          if (err) {
            callback(err);
            return;
          }
          topology.connect(options2, (err2) => {
            if (err2) {
              topology.close(true);
              callback(err2);
              return;
            }
            options2.encrypter.connectInternalClient((error3) => {
              if (error3)
                return callback(error3);
              callback(void 0, topology);
            });
          });
        });
        return;
      }
      topology.connect(options2, (err) => {
        if (err) {
          topology.close(true);
          return callback(err);
        }
        callback(void 0, topology);
        return;
      });
    }
    function createUnifiedOptions(finalOptions, options2) {
      const childOptions = [
        "mongos",
        "server",
        "db",
        "replset",
        "db_options",
        "server_options",
        "rs_options",
        "mongos_options"
      ];
      const noMerge = ["readconcern", "compression", "autoencryption"];
      const skip = ["w", "wtimeout", "j", "journal", "fsync", "writeconcern"];
      for (const name in options2) {
        if (skip.indexOf(name.toLowerCase()) !== -1) {
          continue;
        } else if (noMerge.indexOf(name.toLowerCase()) !== -1) {
          finalOptions[name] = options2[name];
        } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {
          finalOptions = mergeOptions(finalOptions, options2[name], false);
        } else {
          if (options2[name] && typeof options2[name] === "object" && !Buffer.isBuffer(options2[name]) && !Array.isArray(options2[name])) {
            finalOptions = mergeOptions(finalOptions, options2[name], true);
          } else {
            finalOptions[name] = options2[name];
          }
        }
      }
      const optionsWriteConcern = WriteConcern.fromOptions(options2);
      if (optionsWriteConcern) {
        finalOptions.writeConcern = Object.assign({}, finalOptions.writeConcern, optionsWriteConcern);
      }
      return finalOptions;
    }
    function generateCredentials(client2, username, password, options2) {
      options2 = Object.assign({}, options2);
      const source = options2.authSource || options2.authdb || options2.dbName;
      const authMechanismRaw = options2.authMechanism || "DEFAULT";
      const authMechanism = authMechanismRaw.toUpperCase();
      const mechanismProperties = options2.authMechanismProperties;
      if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {
        throw MongoError.create({
          message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,
          driver: true
        });
      }
      return new MongoCredentials({
        mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],
        mechanismProperties,
        source,
        username,
        password
      });
    }
    function legacyTransformUrlOptions(object) {
      return mergeOptions(createUnifiedOptions({}, object), object, false);
    }
    function mergeOptions(target, source, flatten) {
      for (const name in source) {
        if (source[name] && typeof source[name] === "object" && flatten) {
          target = mergeOptions(target, source[name], flatten);
        } else {
          target[name] = source[name];
        }
      }
      return target;
    }
    function relayEvents(mongoClient, topology) {
      const serverOrCommandEvents = [
        "commandStarted",
        "commandSucceeded",
        "commandFailed",
        "serverOpening",
        "serverClosed",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "joined",
        "left",
        "ping",
        "ha"
      ].concat(CMAP_EVENT_NAMES);
      serverOrCommandEvents.forEach((event) => {
        topology.on(event, (object1, object2) => {
          mongoClient.emit(event, object1, object2);
        });
      });
    }
    function replayEvents(mongoClient, events) {
      for (let i = 0; i < events.length; i++) {
        mongoClient.emit(events[i].event, events[i].object1, events[i].object2);
      }
    }
    function transformUrlOptions(_object) {
      let object = Object.assign({servers: _object.hosts}, _object.options);
      for (let name in object) {
        const camelCaseName = LEGACY_OPTIONS_MAP[name];
        if (camelCaseName) {
          object[camelCaseName] = object[name];
        }
      }
      const hasUsername = _object.auth && _object.auth.username;
      const hasAuthMechanism = _object.options && _object.options.authMechanism;
      if (hasUsername || hasAuthMechanism) {
        object.auth = Object.assign({}, _object.auth);
        if (object.auth.db) {
          object.authSource = object.authSource || object.auth.db;
        }
        if (object.auth.username) {
          object.auth.user = object.auth.username;
        }
      }
      if (_object.defaultDatabase) {
        object.dbName = _object.defaultDatabase;
      }
      if (object.maxPoolSize) {
        object.poolSize = object.maxPoolSize;
      }
      if (object.readConcernLevel) {
        object.readConcern = new ReadConcern(object.readConcernLevel);
      }
      if (object.wTimeoutMS) {
        object.wtimeout = object.wTimeoutMS;
        object.wTimeoutMS = void 0;
      }
      if (_object.srvHost) {
        object.srvHost = _object.srvHost;
      }
      const wcKeys = ["w", "wtimeout", "j", "journal", "fsync"];
      for (const key of wcKeys) {
        if (object[key] !== void 0) {
          if (object.writeConcern === void 0)
            object.writeConcern = {};
          object.writeConcern[key] = object[key];
          object[key] = void 0;
        }
      }
      return object;
    }
    function translateOptions(options2, translationOptions) {
      translationOptions = Object.assign({}, {createServers: true}, translationOptions);
      if (typeof options2.readPreference === "string" || typeof options2.read_preference === "string") {
        options2.readPreference = new ReadPreference(options2.readPreference || options2.read_preference);
      }
      if (options2.readPreference && (options2.readPreferenceTags || options2.read_preference_tags)) {
        options2.readPreference.tags = options2.readPreferenceTags || options2.read_preference_tags;
      }
      if (options2.maxStalenessSeconds) {
        options2.readPreference.maxStalenessSeconds = options2.maxStalenessSeconds;
      }
      if (options2.socketTimeoutMS == null)
        options2.socketTimeoutMS = 0;
      if (options2.connectTimeoutMS == null)
        options2.connectTimeoutMS = 1e4;
      if (!translationOptions.createServers) {
        return;
      }
      return options2.servers.map((serverObj) => {
        return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options2) : new Server(serverObj.host, serverObj.port, options2);
      });
    }
    module2.exports = {validOptions, connect};
  }
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS({
  "node_modules/mongodb/lib/mongo_client.js"(exports2, module2) {
    "use strict";
    var ChangeStream = require_change_stream();
    var Db = require_db();
    var EventEmitter = require("events").EventEmitter;
    var inherits = require("util").inherits;
    var MongoError = require_core().MongoError;
    var deprecate = require("util").deprecate;
    var WriteConcern = require_write_concern();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils4().maybePromise;
    var NativeTopology = require_native_topology();
    var connect = require_connect2().connect;
    var validOptions = require_connect2().validOptions;
    function MongoClient2(url, options2) {
      if (!(this instanceof MongoClient2))
        return new MongoClient2(url, options2);
      EventEmitter.call(this);
      if (options2 && options2.autoEncryption)
        require_encrypter();
      this.s = {
        url,
        options: options2 || {},
        promiseLibrary: options2 && options2.promiseLibrary || Promise,
        dbCache: new Map(),
        sessions: new Set(),
        writeConcern: WriteConcern.fromOptions(options2),
        readPreference: ReadPreference.fromOptions(options2) || ReadPreference.primary,
        namespace: new MongoDBNamespace("admin")
      };
    }
    inherits(MongoClient2, EventEmitter);
    Object.defineProperty(MongoClient2.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(MongoClient2.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        return this.s.readPreference;
      }
    });
    MongoClient2.prototype.connect = function(callback) {
      if (typeof callback === "string") {
        throw new TypeError("`connect` only accepts a callback");
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const err = validOptions(client.s.options);
        if (err)
          return cb(err);
        connect(client, client.s.url, client.s.options, (err2) => {
          if (err2)
            return cb(err2);
          cb(null, client);
        });
      });
    };
    MongoClient2.prototype.logout = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      if (typeof callback === "function")
        callback(null, true);
    }, "Multiple authentication is prohibited on a connected client, please only authenticate once per MongoClient");
    MongoClient2.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const completeClose = (err) => {
          client.emit("close", client);
          if (!(client.topology instanceof NativeTopology)) {
            for (const item of client.s.dbCache) {
              item[1].emit("close", client);
            }
          }
          client.removeAllListeners("close");
          cb(err);
        };
        if (client.topology == null) {
          completeClose();
          return;
        }
        client.topology.close(force, (err) => {
          const encrypter = client.topology.s.options.encrypter;
          if (encrypter) {
            return encrypter.close(client, force, (err2) => {
              completeClose(err || err2);
            });
          }
          completeClose(err);
        });
      });
    };
    MongoClient2.prototype.db = function(dbName, options2) {
      options2 = options2 || {};
      if (!dbName) {
        dbName = this.s.options.dbName;
      }
      const finalOptions = Object.assign({}, this.s.options, options2);
      if (this.s.dbCache.has(dbName) && finalOptions.returnNonCachedInstance !== true) {
        return this.s.dbCache.get(dbName);
      }
      finalOptions.promiseLibrary = this.s.promiseLibrary;
      if (!this.topology) {
        throw new MongoError("MongoClient must be connected before calling MongoClient.prototype.db");
      }
      const db = new Db(dbName, this.topology, finalOptions);
      this.s.dbCache.set(dbName, db);
      return db;
    };
    MongoClient2.prototype.isConnected = function(options2) {
      options2 = options2 || {};
      if (!this.topology)
        return false;
      return this.topology.isConnected(options2);
    };
    MongoClient2.connect = function(url, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      const mongoClient = new MongoClient2(url, options2);
      return mongoClient.connect(callback);
    };
    MongoClient2.prototype.startSession = function(options2) {
      options2 = Object.assign({explicit: true}, options2);
      if (!this.topology) {
        throw new MongoError("Must connect to a server before calling this method");
      }
      return this.topology.startSession(options2, this.s.options);
    };
    MongoClient2.prototype.withSession = function(options2, operation) {
      if (typeof options2 === "function")
        operation = options2, options2 = void 0;
      const session = this.startSession(options2);
      let cleanupHandler = (err, result, opts) => {
        cleanupHandler = () => {
          throw new ReferenceError("cleanupHandler was called too many times");
        };
        opts = Object.assign({throw: true}, opts);
        session.endSession();
        if (err) {
          if (opts.throw)
            throw err;
          return Promise.reject(err);
        }
      };
      try {
        const result = operation(session);
        return Promise.resolve(result).then((result2) => cleanupHandler(null, result2)).catch((err) => cleanupHandler(err, null, {throw: true}));
      } catch (err) {
        return cleanupHandler(err, null, {throw: false});
      }
    };
    MongoClient2.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    MongoClient2.prototype.getLogger = function() {
      return this.s.options.logger;
    };
    module2.exports = MongoClient2;
  }
});

// node_modules/mongodb/lib/gridfs/chunk.js
var require_chunk = __commonJS({
  "node_modules/mongodb/lib/gridfs/chunk.js"(exports2, module2) {
    "use strict";
    var Binary2 = require_core().BSON.Binary;
    var ObjectID2 = require_core().BSON.ObjectID;
    var Buffer2 = require_safe_buffer().Buffer;
    var Chunk = function(file, mongoObject, writeConcern) {
      if (!(this instanceof Chunk))
        return new Chunk(file, mongoObject);
      this.file = file;
      var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
      this.writeConcern = writeConcern || {w: 1};
      this.objectId = mongoObjectFinal._id == null ? new ObjectID2() : mongoObjectFinal._id;
      this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
      this.data = new Binary2();
      if (typeof mongoObjectFinal.data === "string") {
        var buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (Array.isArray(mongoObjectFinal.data)) {
        buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        var data = mongoObjectFinal.data.join("");
        buffer.write(data, 0, data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === "Binary") {
        this.data = mongoObjectFinal.data;
      } else if (!Buffer2.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
        throw Error("Illegal chunk format");
      }
      this.internalPosition = 0;
    };
    Chunk.prototype.write = function(data, callback) {
      this.data.write(data, this.internalPosition, data.length, "binary");
      this.internalPosition = this.data.length();
      if (callback != null)
        return callback(null, this);
      return this;
    };
    Chunk.prototype.read = function(length) {
      length = length == null || length === 0 ? this.length() : length;
      if (this.length() - this.internalPosition + 1 >= length) {
        var data = this.data.read(this.internalPosition, length);
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return "";
      }
    };
    Chunk.prototype.readSlice = function(length) {
      if (this.length() - this.internalPosition >= length) {
        var data = null;
        if (this.data.buffer != null) {
          data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
        } else {
          data = Buffer2.alloc(length);
          length = this.data.readInto(data, this.internalPosition);
        }
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return null;
      }
    };
    Chunk.prototype.eof = function() {
      return this.internalPosition === this.length() ? true : false;
    };
    Chunk.prototype.getc = function() {
      return this.read(1);
    };
    Chunk.prototype.rewind = function() {
      this.internalPosition = 0;
      this.data = new Binary2();
    };
    Chunk.prototype.save = function(options2, callback) {
      var self = this;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      self.file.chunkCollection(function(err, collection) {
        if (err)
          return callback(err);
        var writeOptions = {upsert: true};
        for (var name in options2)
          writeOptions[name] = options2[name];
        for (name in self.writeConcern)
          writeOptions[name] = self.writeConcern[name];
        if (self.data.length() > 0) {
          self.buildMongoObject(function(mongoObject) {
            var options3 = {forceServerObjectId: true};
            for (var name2 in self.writeConcern) {
              options3[name2] = self.writeConcern[name2];
            }
            collection.replaceOne({_id: self.objectId}, mongoObject, writeOptions, function(err2) {
              callback(err2, self);
            });
          });
        } else {
          callback(null, self);
        }
      });
    };
    Chunk.prototype.buildMongoObject = function(callback) {
      var mongoObject = {
        files_id: this.file.fileId,
        n: this.chunkNumber,
        data: this.data
      };
      if (this.objectId != null)
        mongoObject._id = this.objectId;
      callback(mongoObject);
    };
    Chunk.prototype.length = function() {
      return this.data.length();
    };
    Object.defineProperty(Chunk.prototype, "position", {
      enumerable: true,
      get: function() {
        return this.internalPosition;
      },
      set: function(value) {
        this.internalPosition = value;
      }
    });
    Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
    module2.exports = Chunk;
  }
});

// node_modules/mongodb/lib/gridfs/grid_store.js
var require_grid_store = __commonJS({
  "node_modules/mongodb/lib/gridfs/grid_store.js"(exports2, module2) {
    "use strict";
    var Chunk = require_chunk();
    var ObjectID2 = require_core().BSON.ObjectID;
    var ReadPreference = require_core().ReadPreference;
    var Buffer2 = require_safe_buffer().Buffer;
    var fs = require("fs");
    var f = require("util").format;
    var util = require("util");
    var MongoError = require_core().MongoError;
    var inherits = util.inherits;
    var Duplex = require("stream").Duplex;
    var shallowClone = require_utils4().shallowClone;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var deprecate = require("util").deprecate;
    var REFERENCE_BY_FILENAME = 0;
    var REFERENCE_BY_ID = 1;
    var deprecationFn = deprecate(() => {
    }, "GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead");
    var GridStore = function GridStore2(db, id, filename, mode, options2) {
      deprecationFn();
      if (!(this instanceof GridStore2))
        return new GridStore2(db, id, filename, mode, options2);
      this.db = db;
      if (typeof options2 === "undefined")
        options2 = {};
      if (typeof mode === "undefined") {
        mode = filename;
        filename = void 0;
      } else if (typeof mode === "object") {
        options2 = mode;
        mode = filename;
        filename = void 0;
      }
      if (id && id._bsontype === "ObjectID") {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      } else if (typeof filename === "undefined") {
        this.referenceBy = REFERENCE_BY_FILENAME;
        this.filename = id;
        if (mode.indexOf("w") != null) {
          this.fileId = new ObjectID2();
        }
      } else {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      }
      this.mode = mode == null ? "r" : mode;
      this.options = options2 || {};
      this.isOpen = false;
      this.root = this.options["root"] == null ? GridStore2.DEFAULT_ROOT_COLLECTION : this.options["root"];
      this.position = 0;
      this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.primary;
      this.writeConcern = _getWriteConcern(db, this.options);
      this.internalChunkSize = this.options["chunkSize"] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options["chunkSize"];
      var promiseLibrary = this.options.promiseLibrary || Promise;
      this.promiseLibrary = promiseLibrary;
      Object.defineProperty(this, "chunkSize", {
        enumerable: true,
        get: function() {
          return this.internalChunkSize;
        },
        set: function(value) {
          if (!(this.mode[0] === "w" && this.position === 0 && this.uploadDate == null)) {
            this.internalChunkSize = this.internalChunkSize;
          } else {
            this.internalChunkSize = value;
          }
        }
      });
      Object.defineProperty(this, "md5", {
        enumerable: true,
        get: function() {
          return this.internalMd5;
        }
      });
      Object.defineProperty(this, "chunkNumber", {
        enumerable: true,
        get: function() {
          return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
        }
      });
    };
    GridStore.prototype.open = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.mode !== "w" && this.mode !== "w+" && this.mode !== "r") {
        throw MongoError.create({message: "Illegal mode " + this.mode, driver: true});
      }
      return executeLegacyOperation(this.db.s.topology, open, [this, options2, callback], {
        skipSessions: true
      });
    };
    var open = function(self, options2, callback) {
      var writeConcern = _getWriteConcern(self.db, self.options);
      if (self.mode === "w" || self.mode === "w+") {
        var collection = self.collection();
        collection.ensureIndex([["filename", 1]], writeConcern, function() {
          var chunkCollection = self.chunkCollection();
          var chunkIndexOptions = shallowClone(writeConcern);
          chunkIndexOptions.unique = true;
          chunkCollection.ensureIndex([
            ["files_id", 1],
            ["n", 1]
          ], chunkIndexOptions, function() {
            _open(self, writeConcern, function(err, r) {
              if (err)
                return callback(err);
              self.isOpen = true;
              callback(err, r);
            });
          });
        });
      } else {
        _open(self, writeConcern, function(err, r) {
          if (err)
            return callback(err);
          self.isOpen = true;
          callback(err, r);
        });
      }
    };
    GridStore.prototype.eof = function() {
      return this.position === this.length ? true : false;
    };
    GridStore.prototype.getc = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, getc, [this, options2, callback], {
        skipSessions: true
      });
    };
    var getc = function(self, options2, callback) {
      if (self.eof()) {
        callback(null, null);
      } else if (self.currentChunk.eof()) {
        nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
          self.currentChunk = chunk;
          self.position = self.position + 1;
          callback(err, self.currentChunk.getc());
        });
      } else {
        self.position = self.position + 1;
        callback(null, self.currentChunk.getc());
      }
    };
    GridStore.prototype.puts = function(string, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      var finalString = string.match(/\n$/) == null ? string + "\n" : string;
      return executeLegacyOperation(this.db.s.topology, this.write.bind(this), [finalString, options2, callback], {skipSessions: true});
    };
    GridStore.prototype.stream = function() {
      return new GridStoreStream(this);
    };
    GridStore.prototype.write = function write(data, close2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, _writeNormal, [this, data, close2, options2, callback], {skipSessions: true});
    };
    GridStore.prototype.destroy = function destroy() {
      if (!this.writable)
        return;
      this.readable = false;
      if (this.writable) {
        this.writable = false;
        this._q.length = 0;
        this.emit("close");
      }
    };
    GridStore.prototype.writeFile = function(file, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options2, callback], {
        skipSessions: true
      });
    };
    var writeFile = function(self, file, options2, callback) {
      if (typeof file === "string") {
        fs.open(file, "r", function(err, fd) {
          if (err)
            return callback(err);
          self.writeFile(fd, callback);
        });
        return;
      }
      self.open(function(err, self2) {
        if (err)
          return callback(err, self2);
        fs.fstat(file, function(err2, stats) {
          if (err2)
            return callback(err2, self2);
          var offset = 0;
          var index2 = 0;
          var writeChunk = function() {
            var _buffer = Buffer2.alloc(self2.chunkSize);
            fs.read(file, _buffer, 0, _buffer.length, offset, function(err3, bytesRead, data) {
              if (err3)
                return callback(err3, self2);
              offset = offset + bytesRead;
              var chunk = new Chunk(self2, {n: index2++}, self2.writeConcern);
              chunk.write(data.slice(0, bytesRead), function(err4, chunk2) {
                if (err4)
                  return callback(err4, self2);
                chunk2.save({}, function(err5) {
                  if (err5)
                    return callback(err5, self2);
                  self2.position = self2.position + bytesRead;
                  self2.currentChunk = chunk2;
                  if (offset >= stats.size) {
                    fs.close(file, function(err6) {
                      if (err6)
                        return callback(err6);
                      self2.close(function(err7) {
                        if (err7)
                          return callback(err7, self2);
                        return callback(null, self2);
                      });
                    });
                  } else {
                    return process.nextTick(writeChunk);
                  }
                });
              });
            });
          };
          process.nextTick(writeChunk);
        });
      });
    };
    GridStore.prototype.close = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, close, [this, options2, callback], {
        skipSessions: true
      });
    };
    var close = function(self, options2, callback) {
      if (self.mode[0] === "w") {
        options2 = Object.assign({}, self.writeConcern, options2);
        if (self.currentChunk != null && self.currentChunk.position > 0) {
          self.currentChunk.save({}, function(err) {
            if (err && typeof callback === "function")
              return callback(err);
            self.collection(function(err2, files) {
              if (err2 && typeof callback === "function")
                return callback(err2);
              if (self.uploadDate != null) {
                buildMongoObject(self, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options2, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              } else {
                self.uploadDate = new Date();
                buildMongoObject(self, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options2, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              }
            });
          });
        } else {
          self.collection(function(err, files) {
            if (err && typeof callback === "function")
              return callback(err);
            self.uploadDate = new Date();
            buildMongoObject(self, function(err2, mongoObject) {
              if (err2) {
                if (typeof callback === "function")
                  return callback(err2);
                else
                  throw err2;
              }
              files.save(mongoObject, options2, function(err3) {
                if (typeof callback === "function")
                  callback(err3, mongoObject);
              });
            });
          });
        }
      } else if (self.mode[0] === "r") {
        if (typeof callback === "function")
          callback(null, null);
      } else {
        if (typeof callback === "function")
          callback(MongoError.create({message: f("Illegal mode %s", self.mode), driver: true}));
      }
    };
    GridStore.prototype.chunkCollection = function(callback) {
      if (typeof callback === "function")
        return this.db.collection(this.root + ".chunks", callback);
      return this.db.collection(this.root + ".chunks");
    };
    GridStore.prototype.unlink = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, unlink, [this, options2, callback], {
        skipSessions: true
      });
    };
    var unlink = function(self, options2, callback) {
      deleteChunks(self, function(err) {
        if (err !== null) {
          err.message = "at deleteChunks: " + err.message;
          return callback(err);
        }
        self.collection(function(err2, collection) {
          if (err2 !== null) {
            err2.message = "at collection: " + err2.message;
            return callback(err2);
          }
          collection.remove({_id: self.fileId}, self.writeConcern, function(err3) {
            callback(err3, self);
          });
        });
      });
    };
    GridStore.prototype.collection = function(callback) {
      if (typeof callback === "function")
        this.db.collection(this.root + ".files", callback);
      return this.db.collection(this.root + ".files");
    };
    GridStore.prototype.readlines = function(separator, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : "\n";
      separator = separator || "\n";
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, readlines, [this, separator, options2, callback], {skipSessions: true});
    };
    var readlines = function(self, separator, options2, callback) {
      self.read(function(err, data) {
        if (err)
          return callback(err);
        var items = data.toString().split(separator);
        items = items.length > 0 ? items.splice(0, items.length - 1) : [];
        for (var i = 0; i < items.length; i++) {
          items[i] = items[i] + separator;
        }
        callback(null, items);
      });
    };
    GridStore.prototype.rewind = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, rewind, [this, options2, callback], {
        skipSessions: true
      });
    };
    var rewind = function(self, options2, callback) {
      if (self.currentChunk.chunkNumber !== 0) {
        if (self.mode[0] === "w") {
          deleteChunks(self, function(err) {
            if (err)
              return callback(err);
            self.currentChunk = new Chunk(self, {n: 0}, self.writeConcern);
            self.position = 0;
            callback(null, self);
          });
        } else {
          self.currentChunk(0, function(err, chunk) {
            if (err)
              return callback(err);
            self.currentChunk = chunk;
            self.currentChunk.rewind();
            self.position = 0;
            callback(null, self);
          });
        }
      } else {
        self.currentChunk.rewind();
        self.position = 0;
        callback(null, self);
      }
    };
    GridStore.prototype.read = function(length, buffer, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      buffer = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, read2, [this, length, buffer, options2, callback], {skipSessions: true});
    };
    var read2 = function(self, length, buffer, options2, callback) {
      var finalLength = length == null ? self.length - self.position : length;
      var finalBuffer = buffer == null ? Buffer2.alloc(finalLength) : buffer;
      finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
      if (self.currentChunk.length() - self.currentChunk.position + finalBuffer._index >= finalLength) {
        var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index);
        slice.copy(finalBuffer, finalBuffer._index);
        self.position = self.position + finalBuffer.length;
        if (finalLength === 0 && finalBuffer.length === 0)
          return callback(MongoError.create({message: "File does not exist", driver: true}), null);
        return callback(null, finalBuffer);
      }
      slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position);
      slice.copy(finalBuffer, finalBuffer._index);
      finalBuffer._index += slice.length;
      nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
        if (err)
          return callback(err);
        if (chunk.length() > 0) {
          self.currentChunk = chunk;
          self.read(length, finalBuffer, callback);
        } else {
          if (finalBuffer._index > 0) {
            callback(null, finalBuffer);
          } else {
            callback(MongoError.create({
              message: "no chunks found for file, possibly corrupt",
              driver: true
            }), null);
          }
        }
      });
    };
    GridStore.prototype.tell = function(callback) {
      var self = this;
      if (typeof callback === "function")
        return callback(null, this.position);
      return new self.promiseLibrary(function(resolve2) {
        resolve2(self.position);
      });
    };
    GridStore.prototype.seek = function(position, seekLocation, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      seekLocation = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, seek, [this, position, seekLocation, options2, callback], {skipSessions: true});
    };
    var seek = function(self, position, seekLocation, options2, callback) {
      if (self.mode !== "r") {
        return callback(MongoError.create({message: "seek is only supported for mode r", driver: true}));
      }
      var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
      var finalPosition = position;
      var targetPosition = 0;
      if (seekLocationFinal === GridStore.IO_SEEK_CUR) {
        targetPosition = self.position + finalPosition;
      } else if (seekLocationFinal === GridStore.IO_SEEK_END) {
        targetPosition = self.length + finalPosition;
      } else {
        targetPosition = finalPosition;
      }
      var newChunkNumber = Math.floor(targetPosition / self.chunkSize);
      var seekChunk = function() {
        nthChunk(self, newChunkNumber, function(err, chunk) {
          if (err)
            return callback(err, null);
          if (chunk == null)
            return callback(new Error("no chunk found"));
          self.currentChunk = chunk;
          self.position = targetPosition;
          self.currentChunk.position = self.position % self.chunkSize;
          callback(err, self);
        });
      };
      seekChunk();
    };
    var _open = function(self, options2, callback) {
      var collection = self.collection();
      var query = self.referenceBy === REFERENCE_BY_ID ? {_id: self.fileId} : {filename: self.filename};
      query = self.fileId == null && self.filename == null ? null : query;
      options2.readPreference = self.readPreference;
      if (query != null) {
        collection.findOne(query, options2, function(err, doc) {
          if (err) {
            return error3(err);
          }
          if (doc != null) {
            self.fileId = doc._id;
            self.filename = self.mode === "r" || self.filename === void 0 ? doc.filename : self.filename;
            self.contentType = doc.contentType;
            self.internalChunkSize = doc.chunkSize;
            self.uploadDate = doc.uploadDate;
            self.aliases = doc.aliases;
            self.length = doc.length;
            self.metadata = doc.metadata;
            self.internalMd5 = doc.md5;
          } else if (self.mode !== "r") {
            self.fileId = self.fileId == null ? new ObjectID2() : self.fileId;
            self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
            self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
            self.length = 0;
          } else {
            self.length = 0;
            var txtId = self.fileId._bsontype === "ObjectID" ? self.fileId.toHexString() : self.fileId;
            return error3(MongoError.create({
              message: f("file with id %s not opened for writing", self.referenceBy === REFERENCE_BY_ID ? txtId : self.filename),
              driver: true
            }), self);
          }
          if (self.mode === "r") {
            nthChunk(self, 0, options2, function(err2, chunk) {
              if (err2)
                return error3(err2);
              self.currentChunk = chunk;
              self.position = 0;
              callback(null, self);
            });
          } else if (self.mode === "w" && doc) {
            deleteChunks(self, options2, function(err2) {
              if (err2)
                return error3(err2);
              self.currentChunk = new Chunk(self, {n: 0}, self.writeConcern);
              self.contentType = self.options["content_type"] == null ? self.contentType : self.options["content_type"];
              self.internalChunkSize = self.options["chunk_size"] == null ? self.internalChunkSize : self.options["chunk_size"];
              self.metadata = self.options["metadata"] == null ? self.metadata : self.options["metadata"];
              self.aliases = self.options["aliases"] == null ? self.aliases : self.options["aliases"];
              self.position = 0;
              callback(null, self);
            });
          } else if (self.mode === "w") {
            self.currentChunk = new Chunk(self, {n: 0}, self.writeConcern);
            self.contentType = self.options["content_type"] == null ? self.contentType : self.options["content_type"];
            self.internalChunkSize = self.options["chunk_size"] == null ? self.internalChunkSize : self.options["chunk_size"];
            self.metadata = self.options["metadata"] == null ? self.metadata : self.options["metadata"];
            self.aliases = self.options["aliases"] == null ? self.aliases : self.options["aliases"];
            self.position = 0;
            callback(null, self);
          } else if (self.mode === "w+") {
            nthChunk(self, lastChunkNumber(self), options2, function(err2, chunk) {
              if (err2)
                return error3(err2);
              self.currentChunk = chunk == null ? new Chunk(self, {n: 0}, self.writeConcern) : chunk;
              self.currentChunk.position = self.currentChunk.data.length();
              self.metadata = self.options["metadata"] == null ? self.metadata : self.options["metadata"];
              self.aliases = self.options["aliases"] == null ? self.aliases : self.options["aliases"];
              self.position = self.length;
              callback(null, self);
            });
          }
        });
      } else {
        self.fileId = self.fileId == null ? new ObjectID2() : self.fileId;
        self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
        self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
        self.length = 0;
        if (self.mode === "w") {
          deleteChunks(self, options2, function(err) {
            if (err)
              return error3(err);
            self.currentChunk = new Chunk(self, {n: 0}, self.writeConcern);
            self.contentType = self.options["content_type"] == null ? self.contentType : self.options["content_type"];
            self.internalChunkSize = self.options["chunk_size"] == null ? self.internalChunkSize : self.options["chunk_size"];
            self.metadata = self.options["metadata"] == null ? self.metadata : self.options["metadata"];
            self.aliases = self.options["aliases"] == null ? self.aliases : self.options["aliases"];
            self.position = 0;
            callback(null, self);
          });
        } else if (self.mode === "w+") {
          nthChunk(self, lastChunkNumber(self), options2, function(err, chunk) {
            if (err)
              return error3(err);
            self.currentChunk = chunk == null ? new Chunk(self, {n: 0}, self.writeConcern) : chunk;
            self.currentChunk.position = self.currentChunk.data.length();
            self.metadata = self.options["metadata"] == null ? self.metadata : self.options["metadata"];
            self.aliases = self.options["aliases"] == null ? self.aliases : self.options["aliases"];
            self.position = self.length;
            callback(null, self);
          });
        }
      }
      function error3(err) {
        if (error3.err)
          return;
        callback(error3.err = err);
      }
    };
    var writeBuffer = function(self, buffer, close2, callback) {
      if (typeof close2 === "function") {
        callback = close2;
        close2 = null;
      }
      var finalClose = typeof close2 === "boolean" ? close2 : false;
      if (self.mode !== "w") {
        callback(MongoError.create({
          message: f("file with id %s not opened for writing", self.referenceBy === REFERENCE_BY_ID ? self.referenceBy : self.filename),
          driver: true
        }), null);
      } else {
        if (self.currentChunk.position + buffer.length >= self.chunkSize) {
          var previousChunkNumber = self.currentChunk.chunkNumber;
          var leftOverDataSize = self.chunkSize - self.currentChunk.position;
          var firstChunkData = buffer.slice(0, leftOverDataSize);
          var leftOverData = buffer.slice(leftOverDataSize);
          var chunksToWrite = [self.currentChunk.write(firstChunkData)];
          while (leftOverData.length >= self.chunkSize) {
            var newChunk = new Chunk(self, {n: previousChunkNumber + 1}, self.writeConcern);
            firstChunkData = leftOverData.slice(0, self.chunkSize);
            leftOverData = leftOverData.slice(self.chunkSize);
            previousChunkNumber = previousChunkNumber + 1;
            newChunk.write(firstChunkData);
            chunksToWrite.push(newChunk);
          }
          self.currentChunk = new Chunk(self, {n: previousChunkNumber + 1}, self.writeConcern);
          if (leftOverData.length > 0)
            self.currentChunk.write(leftOverData);
          self.position = self.position + buffer.length;
          var numberOfChunksToWrite = chunksToWrite.length;
          for (var i = 0; i < chunksToWrite.length; i++) {
            chunksToWrite[i].save({}, function(err) {
              if (err)
                return callback(err);
              numberOfChunksToWrite = numberOfChunksToWrite - 1;
              if (numberOfChunksToWrite <= 0) {
                if (finalClose) {
                  return self.close(function(err2) {
                    callback(err2, self);
                  });
                }
                return callback(null, self);
              }
            });
          }
        } else {
          self.position = self.position + buffer.length;
          self.currentChunk.write(buffer);
          if (finalClose) {
            return self.close(function(err) {
              callback(err, self);
            });
          }
          return callback(null, self);
        }
      }
    };
    var buildMongoObject = function(self, callback) {
      var mongoObject = {
        _id: self.fileId,
        filename: self.filename,
        contentType: self.contentType,
        length: self.position ? self.position : 0,
        chunkSize: self.chunkSize,
        uploadDate: self.uploadDate,
        aliases: self.aliases,
        metadata: self.metadata
      };
      var md5Command = {filemd5: self.fileId, root: self.root};
      self.db.command(md5Command, function(err, results) {
        if (err)
          return callback(err);
        mongoObject.md5 = results.md5;
        callback(null, mongoObject);
      });
    };
    var nthChunk = function(self, chunkNumber, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || self.writeConcern;
      options2.readPreference = self.readPreference;
      self.chunkCollection().findOne({files_id: self.fileId, n: chunkNumber}, options2, function(err, chunk) {
        if (err)
          return callback(err);
        var finalChunk = chunk == null ? {} : chunk;
        callback(null, new Chunk(self, finalChunk, self.writeConcern));
      });
    };
    var lastChunkNumber = function(self) {
      return Math.floor((self.length ? self.length - 1 : 0) / self.chunkSize);
    };
    var deleteChunks = function(self, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || self.writeConcern;
      if (self.fileId != null) {
        self.chunkCollection().remove({files_id: self.fileId}, options2, function(err) {
          if (err)
            return callback(err, false);
          callback(null, true);
        });
      } else {
        callback(null, true);
      }
    };
    GridStore.DEFAULT_ROOT_COLLECTION = "fs";
    GridStore.DEFAULT_CONTENT_TYPE = "binary/octet-stream";
    GridStore.IO_SEEK_SET = 0;
    GridStore.IO_SEEK_CUR = 1;
    GridStore.IO_SEEK_END = 2;
    GridStore.exist = function(db, fileIdObject, rootCollection, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, exists, [db, fileIdObject, rootCollection, options2, callback], {skipSessions: true});
    };
    var exists = function(db, fileIdObject, rootCollection, options2, callback) {
      var readPreference = options2.readPreference || ReadPreference.PRIMARY;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        var query = typeof fileIdObject === "string" || Object.prototype.toString.call(fileIdObject) === "[object RegExp]" ? {filename: fileIdObject} : {_id: fileIdObject};
        if (fileIdObject != null && typeof fileIdObject === "object" && Object.prototype.toString.call(fileIdObject) !== "[object RegExp]") {
          query = fileIdObject;
        }
        collection.findOne(query, {readPreference}, function(err2, item) {
          if (err2)
            return callback(err2);
          callback(null, item == null ? false : true);
        });
      });
    };
    GridStore.list = function(db, rootCollection, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, list, [db, rootCollection, options2, callback], {
        skipSessions: true
      });
    };
    var list = function(db, rootCollection, options2, callback) {
      if (rootCollection != null && typeof rootCollection === "object") {
        options2 = rootCollection;
        rootCollection = null;
      }
      var readPreference = options2.readPreference || ReadPreference.primary;
      var byId = options2["id"] != null ? options2["id"] : false;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      var items = [];
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        collection.find({}, {readPreference}, function(err2, cursor) {
          if (err2)
            return callback(err2);
          cursor.each(function(err3, item) {
            if (item != null) {
              items.push(byId ? item._id : item.filename);
            } else {
              callback(err3, items);
            }
          });
        });
      });
    };
    GridStore.read = function(db, name, length, offset, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      offset = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, readStatic, [db, name, length, offset, options2, callback], {skipSessions: true});
    };
    var readStatic = function(db, name, length, offset, options2, callback) {
      new GridStore(db, name, "r", options2).open(function(err, gridStore) {
        if (err)
          return callback(err);
        if (offset && offset >= gridStore.length)
          return callback("offset larger than size of file", null);
        if (length && length > gridStore.length)
          return callback("length is larger than the size of the file", null);
        if (offset && length && offset + length > gridStore.length)
          return callback("offset and length is larger than the size of the file", null);
        if (offset != null) {
          gridStore.seek(offset, function(err2, gridStore2) {
            if (err2)
              return callback(err2);
            gridStore2.read(length, callback);
          });
        } else {
          gridStore.read(length, callback);
        }
      });
    };
    GridStore.readlines = function(db, name, separator, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, readlinesStatic, [db, name, separator, options2, callback], {skipSessions: true});
    };
    var readlinesStatic = function(db, name, separator, options2, callback) {
      var finalSeperator = separator == null ? "\n" : separator;
      new GridStore(db, name, "r", options2).open(function(err, gridStore) {
        if (err)
          return callback(err);
        gridStore.readlines(finalSeperator, callback);
      });
    };
    GridStore.unlink = function(db, names, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options2, callback], {
        skipSessions: true
      });
    };
    var unlinkStatic = function(self, db, names, options2, callback) {
      var writeConcern = _getWriteConcern(db, options2);
      if (names.constructor === Array) {
        var tc = 0;
        for (var i = 0; i < names.length; i++) {
          ++tc;
          GridStore.unlink(db, names[i], options2, function() {
            if (--tc === 0) {
              callback(null, self);
            }
          });
        }
      } else {
        new GridStore(db, names, "w", options2).open(function(err, gridStore) {
          if (err)
            return callback(err);
          deleteChunks(gridStore, function(err2) {
            if (err2)
              return callback(err2);
            gridStore.collection(function(err3, collection) {
              if (err3)
                return callback(err3);
              collection.remove({_id: gridStore.fileId}, writeConcern, function(err4) {
                callback(err4, self);
              });
            });
          });
        });
      }
    };
    var _writeNormal = function(self, data, close2, options2, callback) {
      if (Buffer2.isBuffer(data)) {
        return writeBuffer(self, data, close2, callback);
      } else {
        return writeBuffer(self, Buffer2.from(data, "binary"), close2, callback);
      }
    };
    var _setWriteConcernHash = function(options2) {
      const baseOptions = Object.assign(options2, options2.writeConcern);
      var finalOptions = {};
      if (baseOptions.w != null)
        finalOptions.w = baseOptions.w;
      if (baseOptions.journal === true)
        finalOptions.j = baseOptions.journal;
      if (baseOptions.j === true)
        finalOptions.j = baseOptions.j;
      if (baseOptions.fsync === true)
        finalOptions.fsync = baseOptions.fsync;
      if (baseOptions.wtimeout != null)
        finalOptions.wtimeout = baseOptions.wtimeout;
      return finalOptions;
    };
    var _getWriteConcern = function(self, options2) {
      var finalOptions = {w: 1};
      options2 = options2 || {};
      if (options2.writeConcern != null || options2.w != null || typeof options2.j === "boolean" || typeof options2.journal === "boolean" || typeof options2.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(options2);
      } else if (options2.safe != null && typeof options2.safe === "object") {
        finalOptions = _setWriteConcernHash(options2.safe);
      } else if (typeof options2.safe === "boolean") {
        finalOptions = {w: options2.safe ? 1 : 0};
      } else if (self.options.writeConcern != null || self.options.w != null || typeof self.options.j === "boolean" || typeof self.options.journal === "boolean" || typeof self.options.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(self.options);
      } else if (self.safe && (self.safe.w != null || typeof self.safe.j === "boolean" || typeof self.safe.journal === "boolean" || typeof self.safe.fsync === "boolean")) {
        finalOptions = _setWriteConcernHash(self.safe);
      } else if (typeof self.safe === "boolean") {
        finalOptions = {w: self.safe ? 1 : 0};
      }
      if (finalOptions.w < 1 && (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true))
        throw MongoError.create({
          message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true",
          driver: true
        });
      return finalOptions;
    };
    var GridStoreStream = function(gs) {
      Duplex.call(this);
      this.gs = gs;
      this.endCalled = false;
      this.totalBytesToRead = this.gs.length - this.gs.position;
      this.seekPosition = this.gs.position;
    };
    inherits(GridStoreStream, Duplex);
    GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
    GridStoreStream.prototype.pipe = function(destination) {
      var self = this;
      if (!self.gs.isOpen) {
        self.gs.open(function(err) {
          if (err)
            return self.emit("error", err);
          self.totalBytesToRead = self.gs.length - self.gs.position;
          self._pipe.apply(self, [destination]);
        });
      } else {
        self.totalBytesToRead = self.gs.length - self.gs.position;
        self._pipe.apply(self, [destination]);
      }
      return destination;
    };
    GridStoreStream.prototype._read = function() {
      var self = this;
      var read3 = function() {
        self.gs.read(length, function(err, buffer) {
          if (err && !self.endCalled)
            return self.emit("error", err);
          if (self.endCalled || buffer == null)
            return self.push(null);
          if (buffer.length <= self.totalBytesToRead) {
            self.totalBytesToRead = self.totalBytesToRead - buffer.length;
            self.push(buffer);
          } else if (buffer.length > self.totalBytesToRead) {
            self.totalBytesToRead = self.totalBytesToRead - buffer._index;
            self.push(buffer.slice(0, buffer._index));
          }
          if (self.totalBytesToRead <= 0) {
            self.endCalled = true;
          }
        });
      };
      var length = self.gs.length < self.gs.chunkSize ? self.gs.length - self.seekPosition : self.gs.chunkSize;
      if (!self.gs.isOpen) {
        self.gs.open(function(err) {
          self.totalBytesToRead = self.gs.length - self.gs.position;
          if (err)
            return self.emit("error", err);
          read3();
        });
      } else {
        read3();
      }
    };
    GridStoreStream.prototype.destroy = function() {
      this.pause();
      this.endCalled = true;
      this.gs.close();
      this.emit("end");
    };
    GridStoreStream.prototype.write = function(chunk) {
      var self = this;
      if (self.endCalled)
        return self.emit("error", MongoError.create({message: "attempting to write to stream after end called", driver: true}));
      if (!self.gs.isOpen) {
        self.gs.open(function() {
          self.gs.isOpen = true;
          self.gs.write(chunk, function() {
            process.nextTick(function() {
              self.emit("drain");
            });
          });
        });
        return false;
      } else {
        self.gs.write(chunk, function() {
          self.emit("drain");
        });
        return true;
      }
    };
    GridStoreStream.prototype.end = function(chunk, encoding, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      chunk = args.length ? args.shift() : null;
      encoding = args.length ? args.shift() : null;
      self.endCalled = true;
      if (chunk) {
        self.gs.write(chunk, function() {
          self.gs.close(function() {
            if (typeof callback === "function")
              callback();
            self.emit("end");
          });
        });
      }
      self.gs.close(function() {
        if (typeof callback === "function")
          callback();
        self.emit("end");
      });
    };
    module2.exports = GridStore;
  }
});

// node_modules/mongodb/lib/gridfs-stream/download.js
var require_download = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/download.js"(exports2, module2) {
    "use strict";
    var stream = require("stream");
    var util = require("util");
    module2.exports = GridFSBucketReadStream;
    function GridFSBucketReadStream(chunks, files, readPreference, filter, options2) {
      this.s = {
        bytesRead: 0,
        chunks,
        cursor: null,
        expected: 0,
        files,
        filter,
        init: false,
        expectedEnd: 0,
        file: null,
        options: options2,
        readPreference
      };
      stream.Readable.call(this);
    }
    util.inherits(GridFSBucketReadStream, stream.Readable);
    GridFSBucketReadStream.prototype._read = function() {
      var _this = this;
      if (this.destroyed) {
        return;
      }
      waitForFile(_this, function() {
        doRead(_this);
      });
    };
    GridFSBucketReadStream.prototype.start = function(start) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    };
    GridFSBucketReadStream.prototype.end = function(end) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    };
    GridFSBucketReadStream.prototype.abort = function(callback) {
      var _this = this;
      this.push(null);
      this.destroyed = true;
      if (this.s.cursor) {
        this.s.cursor.close(function(error3) {
          _this.emit("close");
          callback && callback(error3);
        });
      } else {
        if (!this.s.init) {
          _this.emit("close");
        }
        callback && callback();
      }
    };
    function throwIfInitialized(self) {
      if (self.s.init) {
        throw new Error("You cannot change options after the stream has enteredflowing mode!");
      }
    }
    function doRead(_this) {
      if (_this.destroyed) {
        return;
      }
      _this.s.cursor.next(function(error3, doc) {
        if (_this.destroyed) {
          return;
        }
        if (error3) {
          return __handleError(_this, error3);
        }
        if (!doc) {
          _this.push(null);
          process.nextTick(() => {
            _this.s.cursor.close(function(error4) {
              if (error4) {
                __handleError(_this, error4);
                return;
              }
              _this.emit("close");
            });
          });
          return;
        }
        var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
        var expectedN = _this.s.expected++;
        var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);
        if (doc.n > expectedN) {
          var errmsg = "ChunkIsMissing: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        if (doc.n < expectedN) {
          errmsg = "ExtraChunk: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
        if (buf.length !== expectedLength) {
          if (bytesRemaining <= 0) {
            errmsg = "ExtraChunk: Got unexpected n: " + doc.n;
            return __handleError(_this, new Error(errmsg));
          }
          errmsg = "ChunkIsWrongSize: Got unexpected length: " + buf.length + ", expected: " + expectedLength;
          return __handleError(_this, new Error(errmsg));
        }
        _this.s.bytesRead += buf.length;
        if (buf.length === 0) {
          return _this.push(null);
        }
        var sliceStart = null;
        var sliceEnd = null;
        if (_this.s.bytesToSkip != null) {
          sliceStart = _this.s.bytesToSkip;
          _this.s.bytesToSkip = 0;
        }
        const atEndOfStream = expectedN === _this.s.expectedEnd - 1;
        const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;
        if (atEndOfStream && _this.s.bytesToTrim != null) {
          sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;
        } else if (_this.s.options.end && bytesLeftToRead < doc.data.length()) {
          sliceEnd = bytesLeftToRead;
        }
        if (sliceStart != null || sliceEnd != null) {
          buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
        }
        _this.push(buf);
      });
    }
    function init2(self) {
      var findOneOptions = {};
      if (self.s.readPreference) {
        findOneOptions.readPreference = self.s.readPreference;
      }
      if (self.s.options && self.s.options.sort) {
        findOneOptions.sort = self.s.options.sort;
      }
      if (self.s.options && self.s.options.skip) {
        findOneOptions.skip = self.s.options.skip;
      }
      self.s.files.findOne(self.s.filter, findOneOptions, function(error3, doc) {
        if (error3) {
          return __handleError(self, error3);
        }
        if (!doc) {
          var identifier = self.s.filter._id ? self.s.filter._id.toString() : self.s.filter.filename;
          var errmsg = "FileNotFound: file " + identifier + " was not found";
          var err = new Error(errmsg);
          err.code = "ENOENT";
          return __handleError(self, err);
        }
        if (doc.length <= 0) {
          self.push(null);
          return;
        }
        if (self.destroyed) {
          self.emit("close");
          return;
        }
        try {
          self.s.bytesToSkip = handleStartOption(self, doc, self.s.options);
        } catch (error4) {
          return __handleError(self, error4);
        }
        var filter = {files_id: doc._id};
        if (self.s.options && self.s.options.start != null) {
          var skip = Math.floor(self.s.options.start / doc.chunkSize);
          if (skip > 0) {
            filter["n"] = {$gte: skip};
          }
        }
        self.s.cursor = self.s.chunks.find(filter).sort({n: 1});
        if (self.s.readPreference) {
          self.s.cursor.setReadPreference(self.s.readPreference);
        }
        self.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
        self.s.file = doc;
        try {
          self.s.bytesToTrim = handleEndOption(self, doc, self.s.cursor, self.s.options);
        } catch (error4) {
          return __handleError(self, error4);
        }
        self.emit("file", doc);
      });
    }
    function waitForFile(_this, callback) {
      if (_this.s.file) {
        return callback();
      }
      if (!_this.s.init) {
        init2(_this);
        _this.s.init = true;
      }
      _this.once("file", function() {
        callback();
      });
    }
    function handleStartOption(stream2, doc, options2) {
      if (options2 && options2.start != null) {
        if (options2.start > doc.length) {
          throw new Error("Stream start (" + options2.start + ") must not be more than the length of the file (" + doc.length + ")");
        }
        if (options2.start < 0) {
          throw new Error("Stream start (" + options2.start + ") must not be negative");
        }
        if (options2.end != null && options2.end < options2.start) {
          throw new Error("Stream start (" + options2.start + ") must not be greater than stream end (" + options2.end + ")");
        }
        stream2.s.bytesRead = Math.floor(options2.start / doc.chunkSize) * doc.chunkSize;
        stream2.s.expected = Math.floor(options2.start / doc.chunkSize);
        return options2.start - stream2.s.bytesRead;
      }
    }
    function handleEndOption(stream2, doc, cursor, options2) {
      if (options2 && options2.end != null) {
        if (options2.end > doc.length) {
          throw new Error("Stream end (" + options2.end + ") must not be more than the length of the file (" + doc.length + ")");
        }
        if (options2.start < 0) {
          throw new Error("Stream end (" + options2.end + ") must not be negative");
        }
        var start = options2.start != null ? Math.floor(options2.start / doc.chunkSize) : 0;
        cursor.limit(Math.ceil(options2.end / doc.chunkSize) - start);
        stream2.s.expectedEnd = Math.ceil(options2.end / doc.chunkSize);
        return Math.ceil(options2.end / doc.chunkSize) * doc.chunkSize - options2.end;
      }
    }
    function __handleError(_this, error3) {
      _this.emit("error", error3);
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/upload.js
var require_upload = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/upload.js"(exports2, module2) {
    "use strict";
    var core = require_core();
    var crypto = require("crypto");
    var stream = require("stream");
    var util = require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    var ERROR_NAMESPACE_NOT_FOUND = 26;
    module2.exports = GridFSBucketWriteStream;
    function GridFSBucketWriteStream(bucket, filename, options2) {
      options2 = options2 || {};
      stream.Writable.call(this, options2);
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options2;
      this.done = false;
      this.id = options2.id ? options2.id : core.BSON.ObjectId();
      this.chunkSizeBytes = this.options.chunkSizeBytes;
      this.bufToStore = Buffer2.alloc(this.chunkSizeBytes);
      this.length = 0;
      this.md5 = !options2.disableMD5 && crypto.createHash("md5");
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false,
        promiseLibrary: this.bucket.s.promiseLibrary
      };
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        var _this = this;
        checkIndexes(this, function() {
          _this.bucket.s.checkedIndexes = true;
          _this.bucket.emit("index");
        });
      }
    }
    util.inherits(GridFSBucketWriteStream, stream.Writable);
    GridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {
      var _this = this;
      return waitForIndexes(this, function() {
        return doWrite(_this, chunk, encoding, callback);
      });
    };
    GridFSBucketWriteStream.prototype.abort = function(callback) {
      if (this.state.streamEnd) {
        var error3 = new Error("Cannot abort a stream that has already completed");
        if (typeof callback === "function") {
          return callback(error3);
        }
        return this.state.promiseLibrary.reject(error3);
      }
      if (this.state.aborted) {
        error3 = new Error("Cannot call abort() on a stream twice");
        if (typeof callback === "function") {
          return callback(error3);
        }
        return this.state.promiseLibrary.reject(error3);
      }
      this.state.aborted = true;
      this.chunks.deleteMany({files_id: this.id}, function(error4) {
        if (typeof callback === "function")
          callback(error4);
      });
    };
    GridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {
      var _this = this;
      if (typeof chunk === "function") {
        callback = chunk, chunk = null, encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding, encoding = null;
      }
      if (checkAborted(this, callback)) {
        return;
      }
      this.state.streamEnd = true;
      if (callback) {
        this.once("finish", function(result) {
          callback(null, result);
        });
      }
      if (!chunk) {
        waitForIndexes(this, function() {
          writeRemnant(_this);
        });
        return;
      }
      this.write(chunk, encoding, function() {
        writeRemnant(_this);
      });
    };
    function __handleError(_this, error3, callback) {
      if (_this.state.errored) {
        return;
      }
      _this.state.errored = true;
      if (callback) {
        return callback(error3);
      }
      _this.emit("error", error3);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: core.BSON.ObjectId(),
        files_id: filesId,
        n,
        data
      };
    }
    function checkChunksIndex(_this, callback) {
      _this.chunks.listIndexes().toArray(function(error3, indexes) {
        if (error3) {
          if (error3.code === ERROR_NAMESPACE_NOT_FOUND) {
            var index2 = {files_id: 1, n: 1};
            _this.chunks.createIndex(index2, {background: false, unique: true}, function(error4) {
              if (error4) {
                return callback(error4);
              }
              callback();
            });
            return;
          }
          return callback(error3);
        }
        var hasChunksIndex = false;
        indexes.forEach(function(index3) {
          if (index3.key) {
            var keys = Object.keys(index3.key);
            if (keys.length === 2 && index3.key.files_id === 1 && index3.key.n === 1) {
              hasChunksIndex = true;
            }
          }
        });
        if (hasChunksIndex) {
          callback();
        } else {
          index2 = {files_id: 1, n: 1};
          var indexOptions = getWriteOptions(_this);
          indexOptions.background = false;
          indexOptions.unique = true;
          _this.chunks.createIndex(index2, indexOptions, function(error4) {
            if (error4) {
              return callback(error4);
            }
            callback();
          });
        }
      });
    }
    function checkDone(_this, callback) {
      if (_this.done)
        return true;
      if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {
        _this.done = true;
        var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5 && _this.md5.digest("hex"), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);
        if (checkAborted(_this, callback)) {
          return false;
        }
        _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error3) {
          if (error3) {
            return __handleError(_this, error3, callback);
          }
          _this.emit("finish", filesDoc);
          _this.emit("close");
        });
        return true;
      }
      return false;
    }
    function checkIndexes(_this, callback) {
      _this.files.findOne({}, {_id: 1}, function(error3, doc) {
        if (error3) {
          return callback(error3);
        }
        if (doc) {
          return callback();
        }
        _this.files.listIndexes().toArray(function(error4, indexes) {
          if (error4) {
            if (error4.code === ERROR_NAMESPACE_NOT_FOUND) {
              var index2 = {filename: 1, uploadDate: 1};
              _this.files.createIndex(index2, {background: false}, function(error5) {
                if (error5) {
                  return callback(error5);
                }
                checkChunksIndex(_this, callback);
              });
              return;
            }
            return callback(error4);
          }
          var hasFileIndex = false;
          indexes.forEach(function(index3) {
            var keys = Object.keys(index3.key);
            if (keys.length === 2 && index3.key.filename === 1 && index3.key.uploadDate === 1) {
              hasFileIndex = true;
            }
          });
          if (hasFileIndex) {
            checkChunksIndex(_this, callback);
          } else {
            index2 = {filename: 1, uploadDate: 1};
            var indexOptions = getWriteOptions(_this);
            indexOptions.background = false;
            _this.files.createIndex(index2, indexOptions, function(error5) {
              if (error5) {
                return callback(error5);
              }
              checkChunksIndex(_this, callback);
            });
          }
        });
      });
    }
    function createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {
      var ret = {
        _id,
        length,
        chunkSize,
        uploadDate: new Date(),
        filename
      };
      if (md5) {
        ret.md5 = md5;
      }
      if (contentType) {
        ret.contentType = contentType;
      }
      if (aliases) {
        ret.aliases = aliases;
      }
      if (metadata) {
        ret.metadata = metadata;
      }
      return ret;
    }
    function doWrite(_this, chunk, encoding, callback) {
      if (checkAborted(_this, callback)) {
        return false;
      }
      var inputBuf = Buffer2.isBuffer(chunk) ? chunk : Buffer2.from(chunk, encoding);
      _this.length += inputBuf.length;
      if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
        inputBuf.copy(_this.bufToStore, _this.pos);
        _this.pos += inputBuf.length;
        callback && callback();
        return true;
      }
      var inputBufRemaining = inputBuf.length;
      var spaceRemaining = _this.chunkSizeBytes - _this.pos;
      var numToCopy = Math.min(spaceRemaining, inputBuf.length);
      var outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        var inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);
        _this.pos += numToCopy;
        spaceRemaining -= numToCopy;
        if (spaceRemaining === 0) {
          if (_this.md5) {
            _this.md5.update(_this.bufToStore);
          }
          var doc = createChunkDoc(_this.id, _this.n, Buffer2.from(_this.bufToStore));
          ++_this.state.outstandingRequests;
          ++outstandingRequests;
          if (checkAborted(_this, callback)) {
            return false;
          }
          _this.chunks.insertOne(doc, getWriteOptions(_this), function(error3) {
            if (error3) {
              return __handleError(_this, error3);
            }
            --_this.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              _this.emit("drain", doc);
              callback && callback();
              checkDone(_this);
            }
          });
          spaceRemaining = _this.chunkSizeBytes;
          _this.pos = 0;
          ++_this.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
      return false;
    }
    function getWriteOptions(_this) {
      var obj = {};
      if (_this.options.writeConcern) {
        obj.w = _this.options.writeConcern.w;
        obj.wtimeout = _this.options.writeConcern.wtimeout;
        obj.j = _this.options.writeConcern.j;
      }
      return obj;
    }
    function waitForIndexes(_this, callback) {
      if (_this.bucket.s.checkedIndexes) {
        return callback(false);
      }
      _this.bucket.once("index", function() {
        callback(true);
      });
      return true;
    }
    function writeRemnant(_this, callback) {
      if (_this.pos === 0) {
        return checkDone(_this, callback);
      }
      ++_this.state.outstandingRequests;
      var remnant = Buffer2.alloc(_this.pos);
      _this.bufToStore.copy(remnant, 0, 0, _this.pos);
      if (_this.md5) {
        _this.md5.update(remnant);
      }
      var doc = createChunkDoc(_this.id, _this.n, remnant);
      if (checkAborted(_this, callback)) {
        return false;
      }
      _this.chunks.insertOne(doc, getWriteOptions(_this), function(error3) {
        if (error3) {
          return __handleError(_this, error3);
        }
        --_this.state.outstandingRequests;
        checkDone(_this);
      });
    }
    function checkAborted(_this, callback) {
      if (_this.state.aborted) {
        if (typeof callback === "function") {
          callback(new Error("this stream has been aborted"));
        }
        return true;
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/index.js
var require_gridfs_stream = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/index.js"(exports2, module2) {
    "use strict";
    var Emitter = require("events").EventEmitter;
    var GridFSBucketReadStream = require_download();
    var GridFSBucketWriteStream = require_upload();
    var shallowClone = require_utils4().shallowClone;
    var toError = require_utils4().toError;
    var util = require("util");
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
      bucketName: "fs",
      chunkSizeBytes: 255 * 1024
    };
    module2.exports = GridFSBucket;
    function GridFSBucket(db, options2) {
      Emitter.apply(this);
      this.setMaxListeners(0);
      if (options2 && typeof options2 === "object") {
        options2 = shallowClone(options2);
        var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
        for (var i = 0; i < keys.length; ++i) {
          if (!options2[keys[i]]) {
            options2[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
          }
        }
      } else {
        options2 = DEFAULT_GRIDFS_BUCKET_OPTIONS;
      }
      this.s = {
        db,
        options: options2,
        _chunksCollection: db.collection(options2.bucketName + ".chunks"),
        _filesCollection: db.collection(options2.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false,
        promiseLibrary: db.s.promiseLibrary || Promise
      };
    }
    util.inherits(GridFSBucket, Emitter);
    GridFSBucket.prototype.openUploadStream = function(filename, options2) {
      if (options2) {
        options2 = shallowClone(options2);
      } else {
        options2 = {};
      }
      if (!options2.chunkSizeBytes) {
        options2.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      return new GridFSBucketWriteStream(this, filename, options2);
    };
    GridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options2) {
      if (options2) {
        options2 = shallowClone(options2);
      } else {
        options2 = {};
      }
      if (!options2.chunkSizeBytes) {
        options2.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      options2.id = id;
      return new GridFSBucketWriteStream(this, filename, options2);
    };
    GridFSBucket.prototype.openDownloadStream = function(id, options2) {
      var filter = {_id: id};
      options2 = {
        start: options2 && options2.start,
        end: options2 && options2.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options2);
    };
    GridFSBucket.prototype.delete = function(id, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {
        skipSessions: true
      });
    };
    function _delete(_this, id, callback) {
      _this.s._filesCollection.deleteOne({_id: id}, function(error3, res) {
        if (error3) {
          return callback(error3);
        }
        _this.s._chunksCollection.deleteMany({files_id: id}, function(error4) {
          if (error4) {
            return callback(error4);
          }
          if (!res.result.n) {
            var errmsg = "FileNotFound: no file with id " + id + " found";
            return callback(new Error(errmsg));
          }
          callback();
        });
      });
    }
    GridFSBucket.prototype.find = function(filter, options2) {
      filter = filter || {};
      options2 = options2 || {};
      var cursor = this.s._filesCollection.find(filter);
      if (options2.batchSize != null) {
        cursor.batchSize(options2.batchSize);
      }
      if (options2.limit != null) {
        cursor.limit(options2.limit);
      }
      if (options2.maxTimeMS != null) {
        cursor.maxTimeMS(options2.maxTimeMS);
      }
      if (options2.noCursorTimeout != null) {
        cursor.addCursorFlag("noCursorTimeout", options2.noCursorTimeout);
      }
      if (options2.skip != null) {
        cursor.skip(options2.skip);
      }
      if (options2.sort != null) {
        cursor.sort(options2.sort);
      }
      return cursor;
    };
    GridFSBucket.prototype.openDownloadStreamByName = function(filename, options2) {
      var sort = {uploadDate: -1};
      var skip = null;
      if (options2 && options2.revision != null) {
        if (options2.revision >= 0) {
          sort = {uploadDate: 1};
          skip = options2.revision;
        } else {
          skip = -options2.revision - 1;
        }
      }
      var filter = {filename};
      options2 = {
        sort,
        skip,
        start: options2 && options2.start,
        end: options2 && options2.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options2);
    };
    GridFSBucket.prototype.rename = function(id, filename, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {
        skipSessions: true
      });
    };
    function _rename(_this, id, filename, callback) {
      var filter = {_id: id};
      var update = {$set: {filename}};
      _this.s._filesCollection.updateOne(filter, update, function(error3, res) {
        if (error3) {
          return callback(error3);
        }
        if (!res.result.n) {
          return callback(toError("File with id " + id + " not found"));
        }
        callback();
      });
    }
    GridFSBucket.prototype.drop = function(callback) {
      return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {
        skipSessions: true
      });
    };
    GridFSBucket.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    function _drop(_this, callback) {
      _this.s._filesCollection.drop(function(error3) {
        if (error3) {
          return callback(error3);
        }
        _this.s._chunksCollection.drop(function(error4) {
          if (error4) {
            return callback(error4);
          }
          return callback();
        });
      });
    }
  }
});

// node_modules/mongodb/index.js
var require_mongodb = __commonJS({
  "node_modules/mongodb/index.js"(exports2, module2) {
    "use strict";
    var core = require_core();
    var Instrumentation = require_apm2();
    var connect = require_mongo_client().connect;
    connect.MongoError = core.MongoError;
    connect.MongoNetworkError = core.MongoNetworkError;
    connect.MongoTimeoutError = core.MongoTimeoutError;
    connect.MongoServerSelectionError = core.MongoServerSelectionError;
    connect.MongoParseError = core.MongoParseError;
    connect.MongoWriteConcernError = core.MongoWriteConcernError;
    connect.MongoBulkWriteError = require_common2().BulkWriteError;
    connect.BulkWriteError = connect.MongoBulkWriteError;
    connect.Admin = require_admin();
    connect.MongoClient = require_mongo_client();
    connect.Db = require_db();
    connect.Collection = require_collection();
    connect.Server = require_server3();
    connect.ReplSet = require_replset2();
    connect.Mongos = require_mongos2();
    connect.ReadPreference = core.ReadPreference;
    connect.GridStore = require_grid_store();
    connect.Chunk = require_chunk();
    connect.Logger = core.Logger;
    connect.AggregationCursor = require_aggregation_cursor();
    connect.CommandCursor = require_command_cursor();
    connect.Cursor = require_cursor2();
    connect.GridFSBucket = require_gridfs_stream();
    connect.CoreServer = core.Server;
    connect.CoreConnection = core.Connection;
    connect.Binary = core.BSON.Binary;
    connect.Code = core.BSON.Code;
    connect.Map = core.BSON.Map;
    connect.DBRef = core.BSON.DBRef;
    connect.Double = core.BSON.Double;
    connect.Int32 = core.BSON.Int32;
    connect.Long = core.BSON.Long;
    connect.MinKey = core.BSON.MinKey;
    connect.MaxKey = core.BSON.MaxKey;
    connect.ObjectID = core.BSON.ObjectID;
    connect.ObjectId = core.BSON.ObjectID;
    connect.Symbol = core.BSON.Symbol;
    connect.Timestamp = core.BSON.Timestamp;
    connect.BSONRegExp = core.BSON.BSONRegExp;
    connect.Decimal128 = core.BSON.Decimal128;
    connect.connect = connect;
    connect.instrument = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      const instrumentation = new Instrumentation();
      instrumentation.instrument(connect.MongoClient, callback);
      return instrumentation;
    };
    module2.exports = connect;
  }
});

// .svelte-kit/netlify/entry.js
__markAsModule(exports);
__export(exports, {
  handler: () => handler
});

// node_modules/@sveltejs/kit/dist/install-fetch.js
var import_http = __toModule(require("http"));
var import_https = __toModule(require("https"));
var import_zlib = __toModule(require("zlib"));
var import_stream = __toModule(require("stream"));
var import_util = __toModule(require("util"));
var import_crypto = __toModule(require("crypto"));
var import_url = __toModule(require("url"));
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var src = dataUriToBuffer;
var {Readable} = import_stream.default;
var wm = new WeakMap();
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
var Blob = class {
  constructor(blobParts = [], options2 = {}) {
    let size = 0;
    const parts = blobParts.map((element) => {
      let buffer;
      if (element instanceof Buffer) {
        buffer = element;
      } else if (ArrayBuffer.isView(element)) {
        buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
      } else if (element instanceof ArrayBuffer) {
        buffer = Buffer.from(element);
      } else if (element instanceof Blob) {
        buffer = element;
      } else {
        buffer = Buffer.from(typeof element === "string" ? element : String(element));
      }
      size += buffer.length || buffer.size || 0;
      return buffer;
    });
    const type = options2.type === void 0 ? "" : String(options2.type).toLowerCase();
    wm.set(this, {
      type: /[^\u0020-\u007E]/.test(type) ? "" : type,
      size,
      parts
    });
  }
  get size() {
    return wm.get(this).size;
  }
  get type() {
    return wm.get(this).type;
  }
  async text() {
    return Buffer.from(await this.arrayBuffer()).toString();
  }
  async arrayBuffer() {
    const data = new Uint8Array(this.size);
    let offset = 0;
    for await (const chunk of this.stream()) {
      data.set(chunk, offset);
      offset += chunk.length;
    }
    return data.buffer;
  }
  stream() {
    return Readable.from(read(wm.get(this).parts));
  }
  slice(start = 0, end = this.size, type = "") {
    const {size} = this;
    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(relativeEnd - relativeStart, 0);
    const parts = wm.get(this).parts.values();
    const blobParts = [];
    let added = 0;
    for (const part of parts) {
      const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
      if (relativeStart && size2 <= relativeStart) {
        relativeStart -= size2;
        relativeEnd -= size2;
      } else {
        const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
        blobParts.push(chunk);
        added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
        relativeStart = 0;
        if (added >= span) {
          break;
        }
      }
    }
    const blob = new Blob([], {type: String(type).toLowerCase()});
    Object.assign(wm.get(blob), {size: span, parts: blobParts});
    return blob;
  }
  get [Symbol.toStringTag]() {
    return "Blob";
  }
  static [Symbol.hasInstance](object) {
    return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
};
Object.defineProperties(Blob.prototype, {
  size: {enumerable: true},
  type: {enumerable: true},
  slice: {enumerable: true}
});
var fetchBlob = Blob;
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};
var FetchError = class extends FetchBaseError {
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
var isAbortSignal = (object) => {
  return typeof object === "object" && object[NAME] === "AbortSignal";
};
var carriage = "\r\n";
var dashes = "-".repeat(2);
var carriageLength = Buffer.byteLength(carriage);
var getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
var getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
var INTERNALS$2 = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (import_util.types.isAnyArrayBuffer(body)) {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream.default)
      ;
    else if (isFormData(body)) {
      boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
      body = import_stream.default.Readable.from(formDataIterator(body, boundary));
    } else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS$2] = {
      body,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof import_stream.default) {
      body.on("error", (err) => {
        const error3 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
        this[INTERNALS$2].error = error3;
      });
    }
  }
  get body() {
    return this[INTERNALS$2].body;
  }
  get bodyUsed() {
    return this[INTERNALS$2].disturbed;
  }
  async arrayBuffer() {
    const {buffer, byteOffset, byteLength} = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
    const buf = await this.buffer();
    return new fetchBlob([buf], {
      type: ct
    });
  }
  async json() {
    const buffer = await consumeBody(this);
    return JSON.parse(buffer.toString());
  }
  async text() {
    const buffer = await consumeBody(this);
    return buffer.toString();
  }
  buffer() {
    return consumeBody(this);
  }
};
Object.defineProperties(Body.prototype, {
  body: {enumerable: true},
  bodyUsed: {enumerable: true},
  arrayBuffer: {enumerable: true},
  blob: {enumerable: true},
  json: {enumerable: true},
  text: {enumerable: true}
});
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let {body} = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error3) {
    if (error3 instanceof FetchBaseError) {
      throw error3;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error3.message}`, "system", error3);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error3) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error3.message}`, "system", error3);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let {body} = instance;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
    p1 = new import_stream.PassThrough({highWaterMark});
    p2 = new import_stream.PassThrough({highWaterMark});
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS$2].body = p1;
    body = p2;
  }
  return body;
};
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  }
  if (isFormData(body)) {
    return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
  }
  if (body instanceof import_stream.default) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const {body} = request;
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (Buffer.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  if (isFormData(body)) {
    return getFormDataLength(request[INTERNALS$2].boundary);
  }
  return null;
};
var writeToStream = (dest, {body}) => {
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
};
var validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(err, "code", {value: "ERR_INVALID_HTTP_TOKEN"});
    throw err;
  }
};
var validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const err = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(err, "code", {value: "ERR_INVALID_CHAR"});
    throw err;
  }
};
var Headers = class extends URLSearchParams {
  constructor(init2) {
    let result = [];
    if (init2 instanceof Headers) {
      const raw = init2.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name, value]));
      }
    } else if (init2 == null)
      ;
    else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
      const method = init2[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init2));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init2].map((pair) => {
          if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase(), String(value));
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase());
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback) {
    for (const name of this.keys()) {
      callback(this.get(name), name);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
  result[property] = {enumerable: true};
  return result;
}, {}));
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
var redirectStatus = new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};
var INTERNALS$1 = Symbol("Response internals");
var Response2 = class extends Body {
  constructor(body = null, options2 = {}) {
    super(body, options2);
    const status = options2.status || 200;
    const headers = new Headers(options2.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS$1] = {
      url: options2.url,
      status,
      statusText: options2.statusText || "",
      headers,
      counter: options2.counter,
      highWaterMark: options2.highWaterMark
    };
  }
  get url() {
    return this[INTERNALS$1].url || "";
  }
  get status() {
    return this[INTERNALS$1].status;
  }
  get ok() {
    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  }
  get redirected() {
    return this[INTERNALS$1].counter > 0;
  }
  get statusText() {
    return this[INTERNALS$1].statusText;
  }
  get headers() {
    return this[INTERNALS$1].headers;
  }
  get highWaterMark() {
    return this[INTERNALS$1].highWaterMark;
  }
  clone() {
    return new Response2(clone(this, this.highWaterMark), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size
    });
  }
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response2(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response2.prototype, {
  url: {enumerable: true},
  status: {enumerable: true},
  ok: {enumerable: true},
  redirected: {enumerable: true},
  statusText: {enumerable: true},
  headers: {enumerable: true},
  clone: {enumerable: true}
});
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
};
var INTERNALS = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS] === "object";
};
var Request = class extends Body {
  constructor(input, init2 = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    let method = init2.method || input.method || "GET";
    method = method.toUpperCase();
    if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init2.size || input.size || 0
    });
    const headers = new Headers(init2.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init2) {
      signal = init2.signal;
    }
    if (signal !== null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal");
    }
    this[INTERNALS] = {
      method,
      redirect: init2.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
    };
    this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
    this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
    this.counter = init2.counter || input.counter || 0;
    this.agent = init2.agent || input.agent;
    this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
  }
  get method() {
    return this[INTERNALS].method;
  }
  get url() {
    return (0, import_url.format)(this[INTERNALS].parsedURL);
  }
  get headers() {
    return this[INTERNALS].headers;
  }
  get redirect() {
    return this[INTERNALS].redirect;
  }
  get signal() {
    return this[INTERNALS].signal;
  }
  clone() {
    return new Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: {enumerable: true},
  url: {enumerable: true},
  headers: {enumerable: true},
  redirect: {enumerable: true},
  clone: {enumerable: true},
  signal: {enumerable: true}
});
var getNodeRequestOptions = (request) => {
  const {parsedURL} = request[INTERNALS];
  const headers = new Headers(request[INTERNALS].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate,br");
  }
  let {agent} = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const requestOptions = {
    path: parsedURL.pathname + search,
    pathname: parsedURL.pathname,
    hostname: parsedURL.hostname,
    protocol: parsedURL.protocol,
    port: parsedURL.port,
    hash: parsedURL.hash,
    search: parsedURL.search,
    query: parsedURL.query,
    href: parsedURL.href,
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return requestOptions;
};
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};
var supportedSchemas = new Set(["data:", "http:", "https:"]);
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = src(request.url);
      const response2 = new Response2(data, {headers: {"Content-Type": data.typeFull}});
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const {signal} = request;
    let response = null;
    const abort = () => {
      const error3 = new AbortError("The operation was aborted.");
      reject(error3);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error3);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error3);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error3) {
                reject(error3);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch2(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
        reject(error3);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), (error3) => {
          reject(error3);
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
          reject(error3);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), (error3) => {
              reject(error3);
            });
          } else {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), (error3) => {
              reject(error3);
            });
          }
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), (error3) => {
          reject(error3);
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
globalThis.fetch = fetch2;
globalThis.Response = Response2;
globalThis.Request = Request;
globalThis.Headers = Headers;

// node_modules/@sveltejs/kit/dist/ssr.js
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return {set, update, subscribe};
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  options: options2,
  $session,
  page_config,
  status,
  error: error3,
  branch,
  page
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error3) {
    error3.stack = options2.get_stack(error3);
  }
  if (branch) {
    branch.forEach(({node, loaded, fetched, uses_credentials}) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({node}) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = {head: "", html: "", css: {code: "", map: null}};
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"></script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error4) => {
      throw new Error(`Failed to serialize session data: ${error4.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error3)},
					nodes: [
						${branch.map(({node}) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page.path)},
						query: new URLSearchParams(${s$1(page.query.toString())}),
						params: ${s$1(page.params)}
					}
				}` : "null"}
			});
		</script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({url, body: body2, json}) => {
    return body2 ? `<script type="svelte-data" url="${url}" body="${hash(body2)}">${json}</script>` : `<script type="svelte-data" url="${url}">${json}</script>`;
  }).join("\n\n			")}
		`.replace(/^\t{2}/gm, "");
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({head, body})
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error3) {
  if (!error3)
    return null;
  let serialized = try_serialize(error3);
  if (!serialized) {
    const {name, message, stack} = error3;
    serialized = try_serialize({name, message, stack});
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  if (loaded.error) {
    const error3 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    const status = loaded.status;
    if (!(error3 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error3}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return {status: 500, error: error3};
    }
    return {status, error: error3};
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
function resolve(base, path) {
  const baseparts = path[0] === "/" ? [] : base.slice(1).split("/");
  const pathparts = path[0] === "/" ? path.slice(1).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  return `/${baseparts.join("/")}`;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  context,
  is_leaf,
  is_error,
  status,
  error: error3
}) {
  const {module: module2} = node;
  let uses_credentials = false;
  const fetched = [];
  let loaded;
  if (module2.load) {
    const load_input = {
      page,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        if (options2.read && url.startsWith(options2.paths.assets)) {
          url = url.replace(options2.paths.assets, "");
        }
        if (url.startsWith("//")) {
          throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
        }
        let response;
        if (/^[a-zA-Z]+:/.test(url)) {
          response = await fetch(url, opts);
        } else {
          const [path, search] = url.split("?");
          const resolved = resolve(request.path, path);
          const filename = resolved.slice(1);
          const filename_html = `${filename}/index.html`;
          const asset = options2.manifest.assets.find((d) => d.file === filename || d.file === filename_html);
          if (asset) {
            if (options2.read) {
              response = new Response(options2.read(asset.file), {
                headers: {
                  "content-type": asset.type
                }
              });
            } else {
              response = await fetch(`http://${page.host}/${asset.file}`, opts);
            }
          }
          if (!response) {
            const headers = {...opts.headers};
            if (opts.credentials !== "omit") {
              uses_credentials = true;
              headers.cookie = request.headers.cookie;
              if (!headers.authorization) {
                headers.authorization = request.headers.authorization;
              }
            }
            if (opts.body && typeof opts.body !== "string") {
              throw new Error("Request body must be a string");
            }
            const rendered = await respond({
              host: request.host,
              method: opts.method || "GET",
              headers,
              path: resolved,
              rawBody: opts.body,
              query: new URLSearchParams(search)
            }, options2, {
              fetched: url,
              initiator: route
            });
            if (rendered) {
              if (state.prerender) {
                state.prerender.dependencies.set(resolved, rendered);
              }
              response = new Response(rendered.body, {
                status: rendered.status,
                headers: rendered.headers
              });
            }
          }
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 !== "etag" && key2 !== "set-cookie")
                    headers[key2] = value;
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      context: {...context}
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error3;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  return {
    node,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    uses_credentials
  };
}
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
async function respond_with_error({request, options: options2, state, $session, status, error: error3}) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    context: {},
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      context: loaded.context,
      is_leaf: false,
      is_error: true,
      status,
      error: error3
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error3,
      branch,
      page
    });
  } catch (error4) {
    options2.handle_error(error4);
    return {
      status: 500,
      headers: {},
      body: error4.stack
    };
  }
}
async function respond$1({request, options: options2, state, $session, route}) {
  const match = route.pattern.exec(request.path);
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id && options2.load_component(id)));
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  const page_config = {
    ssr: "ssr" in leaf ? leaf.ssr : options2.ssr,
    router: "router" in leaf ? leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? leaf.hydrate : options2.hydrate
  };
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: null
    };
  }
  let branch;
  let status = 200;
  let error3;
  ssr:
    if (page_config.ssr) {
      let context = {};
      branch = [];
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              request,
              options: options2,
              state,
              route,
              page,
              node,
              $session,
              context,
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            if (loaded.loaded.redirect) {
              return {
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              };
            }
            if (loaded.loaded.error) {
              ({status, error: error3} = loaded.loaded);
            }
          } catch (e) {
            options2.handle_error(e);
            status = 500;
            error3 = e;
          }
          if (error3) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let error_loaded;
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  error_loaded = await load_node({
                    request,
                    options: options2,
                    state,
                    route,
                    page,
                    node: error_node,
                    $session,
                    context: node_loaded.context,
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error3
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (e) {
                  options2.handle_error(e);
                  continue;
                }
              }
            }
            return await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error3
            });
          }
        }
        branch.push(loaded);
        if (loaded && loaded.loaded.context) {
          context = {
            ...context,
            ...loaded.loaded.context
          };
        }
      }
    }
  try {
    return await render_response({
      options: options2,
      $session,
      page_config,
      status,
      error: error3,
      branch: branch && branch.filter(Boolean),
      page
    });
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
}
async function render_page(request, route, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const $session = await options2.hooks.getSession(request);
  if (route) {
    const response = await respond$1({
      request,
      options: options2,
      state,
      $session,
      route
    });
    if (response) {
      return response;
    }
    if (state.fetched) {
      return {
        status: 500,
        headers: {},
        body: `Bad request in load function: failed to fetch ${state.fetched}`
      };
    }
  } else {
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 404,
      error: new Error(`Not found: ${request.path}`)
    });
  }
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
async function render_route(request, route) {
  const mod = await route.load();
  const handler2 = mod[request.method.toLowerCase().replace("delete", "del")];
  if (handler2) {
    const match = route.pattern.exec(request.path);
    const params = route.params(match);
    const response = await handler2({...request, params});
    if (response) {
      if (typeof response !== "object") {
        return error(`Invalid response from route ${request.path}: expected an object, got ${typeof response}`);
      }
      let {status = 200, body, headers = {}} = response;
      headers = lowercase_keys(headers);
      const type = headers["content-type"];
      if (type === "application/octet-stream" && !(body instanceof Uint8Array)) {
        return error(`Invalid response from route ${request.path}: body must be an instance of Uint8Array if content type is application/octet-stream`);
      }
      if (body instanceof Uint8Array && type !== "application/octet-stream") {
        return error(`Invalid response from route ${request.path}: Uint8Array body must be accompanied by content-type: application/octet-stream header`);
      }
      let normalized_body;
      if (typeof body === "object" && (!type || type === "application/json")) {
        headers = {...headers, "content-type": "application/json"};
        normalized_body = JSON.stringify(body);
      } else {
        normalized_body = body;
      }
      return {status, body: normalized_body, headers};
    }
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        map.get(key).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  #map;
  constructor(map) {
    this.#map = map;
  }
  get(key) {
    const value = this.#map.get(key);
    return value && value[0];
  }
  getAll(key) {
    return this.#map.get(key);
  }
  has(key) {
    return this.#map.has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield key;
      }
    }
  }
  *values() {
    for (const [, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield value;
      }
    }
  }
};
function parse_body(req) {
  const raw = req.rawBody;
  if (!raw)
    return raw;
  const [type, ...directives] = req.headers["content-type"].split(/;\s*/);
  if (typeof raw === "string") {
    switch (type) {
      case "text/plain":
        return raw;
      case "application/json":
        return JSON.parse(raw);
      case "application/x-www-form-urlencoded":
        return get_urlencoded(raw);
      case "multipart/form-data": {
        const boundary = directives.find((directive) => directive.startsWith("boundary="));
        if (!boundary)
          throw new Error("Missing boundary");
        return get_multipart(raw, boundary.slice("boundary=".length));
      }
      default:
        throw new Error(`Invalid Content-Type ${type}`);
    }
  }
  return raw;
}
function get_urlencoded(text) {
  const {data, append} = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  const nope = () => {
    throw new Error("Malformed form data");
  };
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    nope();
  }
  const {data, append} = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          nope();
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      nope();
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !incoming.path.split("/").pop().includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: encodeURI(path + (q ? `?${q}` : ""))
        }
      };
    }
  }
  try {
    return await options2.hooks.handle({
      request: {
        ...incoming,
        headers: lowercase_keys(incoming.headers),
        body: parse_body(incoming),
        params: null,
        locals: {}
      },
      resolve: async (request) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request),
            page_config: {ssr: false, router: true, hydrate: true},
            status: 200,
            error: null,
            branch: [],
            page: null
          });
        }
        for (const route of options2.manifest.routes) {
          if (!route.pattern.test(request.path))
            continue;
          const response = route.type === "endpoint" ? await render_route(request, route) : await render_page(request, route, options2, state);
          if (response) {
            if (response.status === 200) {
              if (!/(no-store|immutable)/.test(response.headers["cache-control"])) {
                const etag = `"${hash(response.body)}"`;
                if (request.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: null
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        return await render_page(request, null, options2, state);
      }
    });
  } catch (e) {
    options2.handle_error(e);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}

// node_modules/svelte/internal/index.mjs
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var tasks = new Set();
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
var resolved_promise = Promise.resolve();
var seen_callbacks = new Set();
var outroing = new Set();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
var escaped2 = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape2(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : context || []),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({$$});
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, {$$slots = {}, context = new Map()} = {}) => {
      on_destroy = [];
      const result = {title: "", head: "", css: new Set()};
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: "open"});
    }
    connectedCallback() {
      const {on_mount} = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop2;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index2 = callbacks.indexOf(callback);
        if (index2 !== -1)
          callbacks.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// .svelte-kit/output/server/app.js
var import_dotenv = __toModule(require_main());
var import_mongodb = __toModule(require_mongodb());
var css$1 = {
  code: "#svelte-announcer.svelte-1pdgbjn{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;left:0;overflow:hidden;position:absolute;top:0;white-space:nowrap;width:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n</script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>#svelte-announcer{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;left:0;overflow:hidden;position:absolute;top:0;white-space:nowrap;width:1px}</style>"],"names":[],"mappings":"AAqDO,gCAAiB,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,kBAAkB,MAAM,GAAG,CAAC,CAAC,UAAU,MAAM,GAAG,CAAC,CAAC,OAAO,GAAG,CAAC,KAAK,CAAC,CAAC,SAAS,MAAM,CAAC,SAAS,QAAQ,CAAC,IAAI,CAAC,CAAC,YAAY,MAAM,CAAC,MAAM,GAAG,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {stores} = $$props;
  let {page} = $$props;
  let {components} = $$props;
  let {props_0 = null} = $$props;
  let {props_1 = null} = $$props;
  let {props_2 = null} = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores.page.subscribe(() => {
      if (mounted) {
        navigated = true;
        title = document.title || "untitled page";
      }
    });
    mounted = true;
    return unsubscribe;
  });
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$1);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${mounted ? `<div id="${"svelte-announcer"}" aria-live="${"assertive"}" aria-atomic="${"true"}" class="${"svelte-1pdgbjn"}">${navigated ? `${escape2(title)}` : ``}</div>` : ``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({head, body}) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
var options = null;
function init(settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-2c12c7eb.js",
      css: ["/./_app/assets/start-0826e215.css"],
      js: ["/./_app/start-2c12c7eb.js", "/./_app/chunks/vendor-9177ee6c.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error22) => String(error22),
    handle_error: (error22) => {
      console.error(error22.stack);
      error22.stack = options.get_stack(error22);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var empty = () => ({});
var manifest = {
  assets: [{"file": "favicon.png", "size": 1571, "type": "image/png"}],
  layout: "src/routes/__layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/completed\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/completed/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/todos\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return index$2;
      })
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({request, resolve: resolve2}) => resolve2(request))
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error2;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/completed/index.svelte": () => Promise.resolve().then(function() {
    return index;
  })
};
var metadata_lookup = {"src/routes/__layout.svelte": {"entry": "/./_app/pages/__layout.svelte-1001f738.js", "css": ["/./_app/assets/pages/__layout.svelte-ea588ecf.css"], "js": ["/./_app/pages/__layout.svelte-1001f738.js", "/./_app/chunks/vendor-9177ee6c.js"], "styles": null}, ".svelte-kit/build/components/error.svelte": {"entry": "/./_app/error.svelte-25bfd572.js", "css": [], "js": ["/./_app/error.svelte-25bfd572.js", "/./_app/chunks/vendor-9177ee6c.js"], "styles": null}, "src/routes/index.svelte": {"entry": "/./_app/pages/index.svelte-2010d9da.js", "css": [], "js": ["/./_app/pages/index.svelte-2010d9da.js", "/./_app/chunks/vendor-9177ee6c.js"], "styles": null}, "src/routes/completed/index.svelte": {"entry": "/./_app/pages/completed/index.svelte-a4d5d864.js", "css": [], "js": ["/./_app/pages/completed/index.svelte-a4d5d864.js", "/./_app/chunks/vendor-9177ee6c.js"], "styles": null}};
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
init({paths: {"base": "", "assets": "/."}});
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({...request, host}, options, {prerender});
}
var {MongoClient} = import_mongodb.default;
import_dotenv.default.config();
var {MONGODB_URI, MONGODB_DB} = process.env;
if (!MONGODB_URI) {
  throw new Error("Please define the MONGODB_URI environment variable inside .env.local");
}
if (!MONGODB_DB) {
  throw new Error("Please define the MONGODB_DB environment variable inside .env.local");
}
var cached = global.mongo;
if (!cached) {
  cached = global.mongo = {conn: null, promise: null};
}
async function connectToDatabase() {
  if (cached.conn) {
    return cached.conn;
  }
  if (!cached.promise) {
    const opts = {
      useNewUrlParser: true,
      useUnifiedTopology: true
    };
    cached.promise = MongoClient.connect(MONGODB_URI, opts).then((client) => {
      return {
        client,
        db: client.db(MONGODB_DB)
      };
    });
  }
  cached.conn = await cached.promise;
  return cached.conn;
}
async function get(request) {
  try {
    const completed = request.query.get("completed") === "true";
    const dbConnection = await connectToDatabase();
    const db = dbConnection.db;
    const collection = db.collection("test");
    const todos = await collection.find({completed}).toArray();
    return {
      status: 200,
      body: {
        todos
      }
    };
  } catch (err) {
    return {
      status: 500,
      body: {
        error: "Error"
      }
    };
  }
}
async function post(request) {
  try {
    const dbConnection = await connectToDatabase();
    const db = dbConnection.db;
    const collection = db.collection("test");
    const todo = JSON.parse(request.body);
    await collection.insertOne(todo);
    return {
      status: 200,
      body: {
        status: "Success"
      }
    };
  } catch (err) {
    return {
      status: 500,
      body: {
        error: "Error"
      }
    };
  }
}
async function put(request) {
}
async function del(request) {
}
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get,
  post,
  put,
  del
});
var css = {
  code: "html{-webkit-text-size-adjust:100%;line-height:1.15;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;margin:0}hr{color:inherit;height:0}abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}button{background-color:transparent;background-image:none}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset,ol,ul{margin:0;padding:0}ol,ul{list-style:none}html{font-family:Arial,sans-serif;line-height:1.5}body{font-family:inherit;line-height:inherit}*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{color:inherit;line-height:inherit;padding:0}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}*{--tw-shadow:0 0 #0000;--tw-ring-inset:var(--tw-empty,/*!*/ /*!*/);--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000}.mb-10{margin-bottom:2.5rem}.mr-2{margin-right:.5rem}.mb-2{margin-bottom:.5rem}.mb-5{margin-bottom:1.25rem}.rounded-md{border-radius:.375rem}.border-2{border-width:2px}.bg-blue-700{--tw-bg-opacity:1;background-color:rgba(29,78,216,var(--tw-bg-opacity))}.bg-gray-100{--tw-bg-opacity:1;background-color:rgba(243,244,246,var(--tw-bg-opacity))}.p-10{padding:2.5rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.py-2{padding-bottom:.5rem;padding-top:.5rem}.px-4{padding-left:1rem;padding-right:1rem}.font-sans{font-family:Arial,sans-serif}.text-lg{font-size:1.125rem;line-height:1.75rem}.font-bold{font-weight:700}.text-white{--tw-text-opacity:1;color:rgba(255,255,255,var(--tw-text-opacity))}",
  map: '{"version":3,"file":"__layout.svelte","sources":["__layout.svelte"],"sourcesContent":["<main class=\\"font-sans p-10\\">\\n\\t<nav class=\\"mb-10\\">\\n\\t\\t<a class=\\"mr-2\\" href=\\"/\\">Todo list</a>\\n\\t\\t<a href=\\"/completed\\">Completed</a>\\n\\t</nav>\\n\\n\\t<slot />\\n</main>\\n\\n<style global>/*! tailwindcss v2.1.2 | MIT License | https://tailwindcss.com*//*! modern-normalize v1.1.0 | MIT License | https://github.com/sindresorhus/modern-normalize */:global(html){-webkit-text-size-adjust:100%;line-height:1.15;-moz-tab-size:4;-o-tab-size:4;tab-size:4}:global(body){font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;margin:0}:global(hr){color:inherit;height:0}:global(abbr[title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}:global(b),:global(strong){font-weight:bolder}:global(code),:global(kbd),:global(pre),:global(samp){font-family:ui-monospace,SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:1em}:global(small){font-size:80%}:global(sub),:global(sup){font-size:75%;line-height:0;position:relative;vertical-align:baseline}:global(sub){bottom:-.25em}:global(sup){top:-.5em}:global(table){border-color:inherit;text-indent:0}:global(button),:global(input),:global(optgroup),:global(select),:global(textarea){font-family:inherit;font-size:100%;line-height:1.15;margin:0}:global(button),:global(select){text-transform:none}:global([type=button]),:global([type=reset]),:global([type=submit]),:global(button){-webkit-appearance:button}:global(::-moz-focus-inner){border-style:none;padding:0}:global(:-moz-focusring){outline:1px dotted ButtonText}:global(:-moz-ui-invalid){box-shadow:none}:global(legend){padding:0}:global(progress){vertical-align:baseline}:global(::-webkit-inner-spin-button),:global(::-webkit-outer-spin-button){height:auto}:global([type=search]){-webkit-appearance:textfield;outline-offset:-2px}:global(::-webkit-search-decoration){-webkit-appearance:none}:global(::-webkit-file-upload-button){-webkit-appearance:button;font:inherit}:global(summary){display:list-item}:global(blockquote),:global(dd),:global(dl),:global(figure),:global(h1),:global(h2),:global(h3),:global(h4),:global(h5),:global(h6),:global(hr),:global(p),:global(pre){margin:0}:global(button){background-color:transparent;background-image:none}:global(button:focus){outline:1px dotted;outline:5px auto -webkit-focus-ring-color}:global(fieldset),:global(ol),:global(ul){margin:0;padding:0}:global(ol),:global(ul){list-style:none}:global(html){font-family:Arial,sans-serif;line-height:1.5}:global(body){font-family:inherit;line-height:inherit}:global(*),:global(:after),:global(:before){border:0 solid #e5e7eb;box-sizing:border-box}:global(hr){border-top-width:1px}:global(img){border-style:solid}:global(textarea){resize:vertical}:global(input::-moz-placeholder),:global(textarea::-moz-placeholder){color:#9ca3af;opacity:1}:global(input:-ms-input-placeholder),:global(textarea:-ms-input-placeholder){color:#9ca3af;opacity:1}:global(input::placeholder),:global(textarea::placeholder){color:#9ca3af;opacity:1}:global([role=button]),:global(button){cursor:pointer}:global(table){border-collapse:collapse}:global(h1),:global(h2),:global(h3),:global(h4),:global(h5),:global(h6){font-size:inherit;font-weight:inherit}:global(a){color:inherit;text-decoration:inherit}:global(button),:global(input),:global(optgroup),:global(select),:global(textarea){color:inherit;line-height:inherit;padding:0}:global(code),:global(kbd),:global(pre),:global(samp){font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}:global(audio),:global(canvas),:global(embed),:global(iframe),:global(img),:global(object),:global(svg),:global(video){display:block;vertical-align:middle}:global(img),:global(video){height:auto;max-width:100%}:global(*){--tw-shadow:0 0 #0000;--tw-ring-inset:var(--tw-empty,/*!*/ /*!*/);--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000}:global(.mb-10){margin-bottom:2.5rem}:global(.mr-2){margin-right:.5rem}:global(.mb-2){margin-bottom:.5rem}:global(.mb-5){margin-bottom:1.25rem}:global(.rounded-md){border-radius:.375rem}:global(.border-2){border-width:2px}:global(.bg-blue-700){--tw-bg-opacity:1;background-color:rgba(29,78,216,var(--tw-bg-opacity))}:global(.bg-gray-100){--tw-bg-opacity:1;background-color:rgba(243,244,246,var(--tw-bg-opacity))}:global(.p-10){padding:2.5rem}:global(.p-2){padding:.5rem}:global(.p-3){padding:.75rem}:global(.py-2){padding-bottom:.5rem;padding-top:.5rem}:global(.px-4){padding-left:1rem;padding-right:1rem}:global(.font-sans){font-family:Arial,sans-serif}:global(.text-lg){font-size:1.125rem;line-height:1.75rem}:global(.font-bold){font-weight:700}:global(.text-white){--tw-text-opacity:1;color:rgba(255,255,255,var(--tw-text-opacity))}</style>\\n"],"names":[],"mappings":"AASqL,IAAI,AAAC,CAAC,yBAAyB,IAAI,CAAC,YAAY,IAAI,CAAC,cAAc,CAAC,CAAC,YAAY,CAAC,CAAC,SAAS,CAAC,CAAC,AAAQ,IAAI,AAAC,CAAC,YAAY,SAAS,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,MAAM,OAAO,CAAC,OAAO,CAAC,CAAC,AAAQ,WAAW,AAAC,CAAC,wBAAwB,SAAS,CAAC,MAAM,CAAC,gBAAgB,SAAS,CAAC,MAAM,CAAC,AAAQ,CAAC,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,YAAY,MAAM,CAAC,AAAQ,IAAI,AAAC,CAAC,AAAQ,GAAG,AAAC,CAAC,AAAQ,GAAG,AAAC,CAAC,AAAQ,IAAI,AAAC,CAAC,YAAY,YAAY,CAAC,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,UAAU,GAAG,CAAC,AAAQ,KAAK,AAAC,CAAC,UAAU,GAAG,CAAC,AAAQ,GAAG,AAAC,CAAC,AAAQ,GAAG,AAAC,CAAC,UAAU,GAAG,CAAC,YAAY,CAAC,CAAC,SAAS,QAAQ,CAAC,eAAe,QAAQ,CAAC,AAAQ,GAAG,AAAC,CAAC,OAAO,MAAM,CAAC,AAAQ,GAAG,AAAC,CAAC,IAAI,KAAK,CAAC,AAAQ,KAAK,AAAC,CAAC,aAAa,OAAO,CAAC,YAAY,CAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,KAAK,AAAC,CAAC,AAAQ,QAAQ,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,QAAQ,AAAC,CAAC,YAAY,OAAO,CAAC,UAAU,IAAI,CAAC,YAAY,IAAI,CAAC,OAAO,CAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,eAAe,IAAI,CAAC,AAAQ,aAAa,AAAC,CAAC,AAAQ,YAAY,AAAC,CAAC,AAAQ,aAAa,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,mBAAmB,MAAM,CAAC,AAAQ,kBAAkB,AAAC,CAAC,aAAa,IAAI,CAAC,QAAQ,CAAC,CAAC,AAAQ,eAAe,AAAC,CAAC,QAAQ,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,AAAQ,gBAAgB,AAAC,CAAC,WAAW,IAAI,CAAC,AAAQ,MAAM,AAAC,CAAC,QAAQ,CAAC,CAAC,AAAQ,QAAQ,AAAC,CAAC,eAAe,QAAQ,CAAC,AAAQ,2BAA2B,AAAC,CAAC,AAAQ,2BAA2B,AAAC,CAAC,OAAO,IAAI,CAAC,AAAQ,aAAa,AAAC,CAAC,mBAAmB,SAAS,CAAC,eAAe,IAAI,CAAC,AAAQ,2BAA2B,AAAC,CAAC,mBAAmB,IAAI,CAAC,AAAQ,4BAA4B,AAAC,CAAC,mBAAmB,MAAM,CAAC,KAAK,OAAO,CAAC,AAAQ,OAAO,AAAC,CAAC,QAAQ,SAAS,CAAC,AAAQ,UAAU,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,CAAC,AAAC,CAAC,AAAQ,GAAG,AAAC,CAAC,OAAO,CAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,iBAAiB,WAAW,CAAC,iBAAiB,IAAI,CAAC,AAAQ,YAAY,AAAC,CAAC,QAAQ,GAAG,CAAC,MAAM,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,wBAAwB,CAAC,AAAQ,QAAQ,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,WAAW,IAAI,CAAC,AAAQ,IAAI,AAAC,CAAC,YAAY,KAAK,CAAC,UAAU,CAAC,YAAY,GAAG,CAAC,AAAQ,IAAI,AAAC,CAAC,YAAY,OAAO,CAAC,YAAY,OAAO,CAAC,AAAQ,CAAC,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,OAAO,AAAC,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,UAAU,CAAC,AAAQ,EAAE,AAAC,CAAC,iBAAiB,GAAG,CAAC,AAAQ,GAAG,AAAC,CAAC,aAAa,KAAK,CAAC,AAAQ,QAAQ,AAAC,CAAC,OAAO,QAAQ,CAAC,AAAQ,uBAAuB,AAAC,CAAC,AAAQ,0BAA0B,AAAC,CAAC,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC,AAAQ,2BAA2B,AAAC,CAAC,AAAQ,8BAA8B,AAAC,CAAC,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC,AAAQ,kBAAkB,AAAC,CAAC,AAAQ,qBAAqB,AAAC,CAAC,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC,AAAQ,aAAa,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,OAAO,OAAO,CAAC,AAAQ,KAAK,AAAC,CAAC,gBAAgB,QAAQ,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,AAAQ,EAAE,AAAC,CAAC,UAAU,OAAO,CAAC,YAAY,OAAO,CAAC,AAAQ,CAAC,AAAC,CAAC,MAAM,OAAO,CAAC,gBAAgB,OAAO,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,KAAK,AAAC,CAAC,AAAQ,QAAQ,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,QAAQ,AAAC,CAAC,MAAM,OAAO,CAAC,YAAY,OAAO,CAAC,QAAQ,CAAC,CAAC,AAAQ,IAAI,AAAC,CAAC,AAAQ,GAAG,AAAC,CAAC,AAAQ,GAAG,AAAC,CAAC,AAAQ,IAAI,AAAC,CAAC,YAAY,YAAY,CAAC,cAAc,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,AAAQ,KAAK,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,KAAK,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,GAAG,AAAC,CAAC,AAAQ,MAAM,AAAC,CAAC,AAAQ,GAAG,AAAC,CAAC,AAAQ,KAAK,AAAC,CAAC,QAAQ,KAAK,CAAC,eAAe,MAAM,CAAC,AAAQ,GAAG,AAAC,CAAC,AAAQ,KAAK,AAAC,CAAC,OAAO,IAAI,CAAC,UAAU,IAAI,CAAC,AAAQ,CAAC,AAAC,CAAC,YAAY,SAAS,CAAC,gBAAgB,2BAA2B,CAAC,uBAAuB,GAAG,CAAC,uBAAuB,IAAI,CAAC,gBAAgB,oBAAoB,CAAC,wBAAwB,SAAS,CAAC,iBAAiB,SAAS,CAAC,AAAQ,MAAM,AAAC,CAAC,cAAc,MAAM,CAAC,AAAQ,KAAK,AAAC,CAAC,aAAa,KAAK,CAAC,AAAQ,KAAK,AAAC,CAAC,cAAc,KAAK,CAAC,AAAQ,KAAK,AAAC,CAAC,cAAc,OAAO,CAAC,AAAQ,WAAW,AAAC,CAAC,cAAc,OAAO,CAAC,AAAQ,SAAS,AAAC,CAAC,aAAa,GAAG,CAAC,AAAQ,YAAY,AAAC,CAAC,gBAAgB,CAAC,CAAC,iBAAiB,KAAK,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,AAAQ,YAAY,AAAC,CAAC,gBAAgB,CAAC,CAAC,iBAAiB,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,AAAQ,KAAK,AAAC,CAAC,QAAQ,MAAM,CAAC,AAAQ,IAAI,AAAC,CAAC,QAAQ,KAAK,CAAC,AAAQ,IAAI,AAAC,CAAC,QAAQ,MAAM,CAAC,AAAQ,KAAK,AAAC,CAAC,eAAe,KAAK,CAAC,YAAY,KAAK,CAAC,AAAQ,KAAK,AAAC,CAAC,aAAa,IAAI,CAAC,cAAc,IAAI,CAAC,AAAQ,UAAU,AAAC,CAAC,YAAY,KAAK,CAAC,UAAU,CAAC,AAAQ,QAAQ,AAAC,CAAC,UAAU,QAAQ,CAAC,YAAY,OAAO,CAAC,AAAQ,UAAU,AAAC,CAAC,YAAY,GAAG,CAAC,AAAQ,WAAW,AAAC,CAAC,kBAAkB,CAAC,CAAC,MAAM,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,iBAAiB,CAAC,CAAC,CAAC"}'
};
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css);
  return `<main class="${"font-sans p-10"}"><nav class="${"mb-10"}"><a class="${"mr-2"}" href="${"/"}">Todo list</a>
		<a href="${"/completed"}">Completed</a></nav>

	${slots.default ? slots.default({}) : ``}
</main>`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
function load$1({error: error22, status}) {
  return {props: {error: error22, status}};
}
var Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {status} = $$props;
  let {error: error22} = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error22 !== void 0)
    $$bindings.error(error22);
  return `<h1>${escape2(status)}</h1>

<p>${escape2(error22.message)}</p>


${error22.stack ? `<pre>${escape2(error22.stack)}</pre>` : ``}`;
});
var error2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load: load$1
});
async function load({fetch: fetch3}) {
  const res = await fetch3("/todos");
  const jsonRes = await res.json();
  return {props: {todos: jsonRes.todos}};
}
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {todos} = $$props;
  let value = "";
  let todosList = todos;
  if ($$props.todos === void 0 && $$bindings.todos && todos !== void 0)
    $$bindings.todos(todos);
  return `<h2 class="${"text-lg font-bold mb-2"}">Add todo</h2>

<div class="${"mb-5"}"><input class="${"border-2 p-2"}" type="${"text"}"${add_attribute("value", value, 1)}>

	<button ${value.trim() === "" ? "disabled" : ""} class="${"py-2 px-4 bg-blue-700 text-white"}">Add
	</button></div>

<div class="${"list"}"><h2 class="${"text-lg font-bold mb-2"}">Todo list</h2>
	${each(todosList, (todo) => `<div class="${" bg-gray-100 p-3 rounded-md mb-2"}">${escape2(todo == null ? void 0 : todo.text)}</div>`)}</div>`;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes,
  load
});
var Completed = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<h1 class="${"mb-2"}">Completed</h1>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Completed
});

// .svelte-kit/netlify/entry.js
async function handler(event) {
  const {path, httpMethod, headers, rawQuery, body, isBase64Encoded} = event;
  const query = new URLSearchParams(rawQuery);
  const rawBody = headers["content-type"] === "application/octet-stream" ? new TextEncoder("base64").encode(body) : isBase64Encoded ? Buffer.from(body, "base64").toString() : body;
  const rendered = await render({
    method: httpMethod,
    headers,
    path,
    query,
    rawBody
  });
  if (rendered) {
    return {
      isBase64Encoded: false,
      statusCode: rendered.status,
      headers: rendered.headers,
      body: rendered.body
    };
  }
  return {
    statusCode: 404,
    body: "Not found"
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
